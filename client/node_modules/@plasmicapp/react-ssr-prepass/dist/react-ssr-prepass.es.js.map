{"version":3,"file":"react-ssr-prepass.es.js","sources":["../src/symbols.js","../src/utils.js","../src/element.js","../src/internals/context.js","../src/internals/error.js","../src/internals/state.js","../src/internals/objectIs.js","../src/internals/dispatcher.js","../src/render/lazyComponent.js","../src/render/functionComponent.js","../src/render/classComponent.js","../src/render/clientReference.js","../src/visitor.js","../src/index.js"],"sourcesContent":["// @flow\n\nimport type { Node } from 'react'\n\n/**\n * Element is already legacy in NextJS v15 https://github.com/vercel/next.js/pull/65058\n * https://github.com/facebook/react/pull/28813\n */\nlet Element = 0xeac7\nlet TransitionalElement = 0xeac7\nlet Portal = 0xeaca\nlet Fragment = 0xeacb\nlet StrictMode = 0xeacc\nlet Profiler = 0xead2\nlet ContextProvider = 0xeacd\nlet ContextConsumer = undefined\nlet Context = 0xeace\nlet ConcurrentMode = 0xeacf\nlet ForwardRef = 0xead0\nlet Suspense = 0xead1\nlet Memo = 0xead3\nlet Lazy = 0xead4\nlet ClientReferenceTag = undefined\n\nif (typeof Symbol === 'function' && Symbol.for) {\n  const symbolFor = Symbol.for\n  Element = symbolFor('react.element')\n  TransitionalElement = symbolFor('react.transitional.element')\n  Portal = symbolFor('react.portal')\n  Fragment = symbolFor('react.fragment')\n  StrictMode = symbolFor('react.strict_mode')\n  Profiler = symbolFor('react.profiler')\n  ContextProvider = symbolFor('react.provider')\n  ContextConsumer = symbolFor('react.consumer')\n  Context = symbolFor('react.context')\n  ConcurrentMode = symbolFor('react.concurrent_mode')\n  ForwardRef = symbolFor('react.forward_ref')\n  Suspense = symbolFor('react.suspense')\n  Memo = symbolFor('react.memo')\n  Lazy = symbolFor('react.lazy')\n  ClientReferenceTag = symbolFor('react.client.reference')\n}\n\n/** Literal types representing the ReactSymbol values. These values do not actually match the values from react-is! */\nexport type ReactSymbol =\n  | 'react.element' /* 0xeac7 | Symbol(react.element) */\n  | 'react.transitional.element' /* 0xeac7 | Symbol(react.transitional.element) */\n  | 'react.portal' /* 0xeaca | Symbol(react.portal) */\n  | 'react.fragment' /* 0xeacb | Symbol(react.fragment) */\n  | 'react.strict_mode' /* 0xeacc | Symbol(react.strict_mode) */\n  | 'react.profiler' /* 0xead2 | Symbol(react.profiler) */\n  | 'react.provider' /* 0xeacd | Symbol(react.provider) */\n  | 'react.consumer' /* undefined | Symbol(react.consumer) */\n  | 'react.context' /* 0xeace | Symbol(react.context) */\n  | 'react.concurrent_mode' /* 0xeacf | Symbol(react.concurrent_mode) */\n  | 'react.forward_ref' /* 0xead0 | Symbol(react.forward_ref) */\n  | 'react.suspense' /* 0xead1 | Symbol(react.suspense) */\n  | 'react.memo' /* 0xead3 | Symbol(react.memo) */\n  | 'react.lazy' /* 0xead4 | Symbol(react.lazy) */\n\nexport const REACT_ELEMENT_TYPE: 'react.element' = (Element: any)\nexport const REACT_TRANSITIONAL_ELEMENT_TYPE: 'react.transitional.element' =\n  (TransitionalElement: any)\nexport const REACT_PORTAL_TYPE: 'react.portal' = (Portal: any)\nexport const REACT_FRAGMENT_TYPE: 'react.fragment' = (Fragment: any)\nexport const REACT_STRICT_MODE_TYPE: 'react.strict_mode' = (StrictMode: any)\nexport const REACT_PROFILER_TYPE: 'react.profiler' = (Profiler: any)\nexport const REACT_PROVIDER_TYPE: 'react.provider' = (ContextProvider: any)\nexport const REACT_CONSUMER_TYPE: 'react.consumer' = (ContextConsumer: any)\nexport const REACT_CONTEXT_TYPE: 'react.context' = (Context: any)\nexport const REACT_CONCURRENT_MODE_TYPE: 'react.concurrent_mode' =\n  (ConcurrentMode: any)\nexport const REACT_FORWARD_REF_TYPE: 'react.forward_ref' = (ForwardRef: any)\nexport const REACT_SUSPENSE_TYPE: 'react.suspense' = (Suspense: any)\nexport const REACT_MEMO_TYPE: 'react.memo' = (Memo: any)\nexport const REACT_LAZY_TYPE: 'react.lazy' = (Lazy: any)\nexport const CLIENT_REFERENCE_TAG: 'react.client.reference' =\n  (ClientReferenceTag: any)\n","// @flow\n\nimport { shouldConstruct } from './element'\nimport { CLIENT_REFERENCE_TAG } from './symbols'\nimport React, { type ComponentType } from 'react'\nimport type { DefaultProps, ComponentStatics } from './types'\n\nexport function isClientReference(reference: Object): boolean {\n  return reference.$$typeof === CLIENT_REFERENCE_TAG\n}\n\nexport const getComponentName = (\n  type: ComponentType<DefaultProps> & ComponentStatics\n): any => {\n  if (isClientReference(type)) {\n    return undefined\n  }\n  if (type.displayName) {\n    return type.displayName\n  }\n  if (shouldConstruct(type)) {\n    return type.constructor.name\n  } else {\n    return type.name\n  }\n}\n\nexport function isReact19() {\n  return !(React: any).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n}\n","// @flow\n\nimport { Children, type Node, type Element, type ComponentType } from 'react'\nimport type { AbstractContext, AbstractElement } from './types'\n\nimport {\n  type ReactSymbol,\n  REACT_ELEMENT_TYPE,\n  REACT_TRANSITIONAL_ELEMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_PROVIDER_TYPE,\n  REACT_CONTEXT_TYPE,\n  REACT_CONCURRENT_MODE_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_LAZY_TYPE,\n  REACT_CONSUMER_TYPE\n} from './symbols'\nimport { isReact19 } from './utils'\n\n/** Is a given Component a class component */\nexport const shouldConstruct = (Comp: ComponentType<*>): boolean %checks =>\n  (Comp: any).prototype && (Comp: any).prototype.isReactComponent\n\n/** Determine the type of element using react-is with applied fixes */\nexport const typeOf = (x: AbstractElement): ReactSymbol | void => {\n  switch (x.$$typeof) {\n    case REACT_PORTAL_TYPE:\n      return REACT_PORTAL_TYPE\n    case REACT_ELEMENT_TYPE:\n    case REACT_TRANSITIONAL_ELEMENT_TYPE:\n      switch (x.type) {\n        case REACT_CONCURRENT_MODE_TYPE:\n          return REACT_CONCURRENT_MODE_TYPE\n        case REACT_FRAGMENT_TYPE:\n          return REACT_FRAGMENT_TYPE\n        case REACT_PROFILER_TYPE:\n          return REACT_PROFILER_TYPE\n        case REACT_STRICT_MODE_TYPE:\n          return REACT_STRICT_MODE_TYPE\n        case REACT_SUSPENSE_TYPE:\n          return REACT_SUSPENSE_TYPE\n\n        default: {\n          switch (x.type && ((x.type: any).$$typeof: ReactSymbol)) {\n            case REACT_LAZY_TYPE:\n              return REACT_LAZY_TYPE\n            case REACT_MEMO_TYPE:\n              return REACT_MEMO_TYPE\n            case REACT_CONSUMER_TYPE:\n              return REACT_CONSUMER_TYPE\n            case REACT_CONTEXT_TYPE:\n              return isReact19() ? REACT_PROVIDER_TYPE : REACT_CONSUMER_TYPE\n            case REACT_PROVIDER_TYPE:\n              return REACT_PROVIDER_TYPE\n            case REACT_FORWARD_REF_TYPE:\n              return REACT_FORWARD_REF_TYPE\n            default:\n              return REACT_ELEMENT_TYPE\n          }\n        }\n      }\n\n    default:\n      return undefined\n  }\n}\n\ntype ScalarNode = null | boolean | string | number\n\n/** Rebound Children.toArray with modified AbstractElement types */\nconst toArray: (node?: Node) => Array<ScalarNode | AbstractElement> =\n  Children.toArray\n\n/** Checks whether the `node` is an AbstractElement */\nconst isAbstractElement = (\n  node: ScalarNode | AbstractElement\n): boolean %checks => node !== null && typeof node === 'object'\n\n/** Returns a flat AbstractElement array for a given AbstractElement node */\nexport const getChildrenArray = (node?: Node): AbstractElement[] => {\n  // $FlowFixMe\n  return toArray(node).filter(isAbstractElement)\n}\n\n/** Returns merged props given a props and defaultProps object */\nexport const computeProps = (props: Object, defaultProps: void | Object) => {\n  return typeof defaultProps === 'object'\n    ? Object.assign({}, defaultProps, props)\n    : props\n}\n","// @flow\n\nimport type {\n  AbstractContext,\n  UserElement,\n  ContextMap,\n  ContextStore,\n  ContextEntry\n} from '../types'\n\n/** The context is kept as a Map from a Context value to the current\n   value on the React element tree.\n   The legacy context is kept as a simple object.\n   When the tree is being walked modifications are made by assigning\n   new legacy context maps or new context values.\n   These changes are kept in the `prev` variables and must be flushed\n   before continuing to walk the tree.\n   After walking the children they can be restored.\n   This way the context recursively restores itself on the way up. */\n\nlet currentContextStore: ContextStore = new Map()\nlet currentContextMap: ContextMap = {}\n\nlet prevContextMap: void | ContextMap = undefined\nlet prevContextEntry: void | ContextEntry = undefined\n\nexport const getCurrentContextMap = (): ContextMap =>\n  Object.assign({}, currentContextMap)\nexport const getCurrentContextStore = (): ContextStore =>\n  new Map(currentContextStore)\n\nexport const flushPrevContextMap = (): void | ContextMap => {\n  const prev = prevContextMap\n  prevContextMap = undefined\n  return prev\n}\n\nexport const flushPrevContextStore = (): void | ContextEntry => {\n  const prev = prevContextEntry\n  prevContextEntry = undefined\n  return prev\n}\n\nexport const restoreContextMap = (prev: void | ContextMap) => {\n  if (prev !== undefined) {\n    Object.assign(currentContextMap, prev)\n  }\n}\n\nexport const restoreContextStore = (prev: void | ContextEntry) => {\n  if (prev !== undefined) {\n    currentContextStore.set(prev[0], prev[1])\n  }\n}\n\nexport const setCurrentContextMap = (map: ContextMap) => {\n  prevContextMap = undefined\n  currentContextMap = map\n}\n\nexport const setCurrentContextStore = (store: ContextStore) => {\n  prevContextEntry = undefined\n  currentContextStore = store\n}\n\nexport const assignContextMap = (map: ContextMap) => {\n  prevContextMap = {}\n  for (const name in map) {\n    prevContextMap[name] = currentContextMap[name]\n    currentContextMap[name] = map[name]\n  }\n}\n\nexport const setContextValue = (context: AbstractContext, value: mixed) => {\n  prevContextEntry = [context, currentContextStore.get(context)]\n  currentContextStore.set(context, value)\n}\n\nexport const readContextValue = (context: AbstractContext) => {\n  const value = currentContextStore.get(context)\n  if (value !== undefined) {\n    return value\n  }\n\n  // Return default if context has no value yet\n  return context._currentValue\n}\n\nconst emptyContext = {}\n\nexport const maskContext = (type: $PropertyType<UserElement, 'type'>) => {\n  const { contextType, contextTypes } = type\n\n  if (contextType) {\n    return readContextValue(contextType)\n  } else if (!contextTypes) {\n    return emptyContext\n  }\n\n  const maskedContext = {}\n  for (const name in contextTypes) {\n    maskedContext[name] = currentContextMap[name]\n  }\n\n  return maskedContext\n}\n","// @flow\n\nimport type { ClassFrame } from '../types'\n\n/** The current error boundary frame determines where to continue rendering when an error is raised */\nlet currentErrorFrame: null | ClassFrame = null\n\nexport const getCurrentErrorFrame = (): ClassFrame | null => currentErrorFrame\n\nexport const setCurrentErrorFrame = (frame?: ClassFrame | null) => {\n  currentErrorFrame = frame || null\n}\n","// @flow\n\nimport type { RendererState } from '../types'\n\n/** The current global renderer state per render cycle */\nexport const rendererStateRef: {| current: RendererState |} = {\n  current: { uniqueID: 0 }\n}\nexport const initRendererState = (): RendererState =>\n  (rendererStateRef.current = { uniqueID: 0 })\nexport const setCurrentRendererState = (state: RendererState) =>\n  (rendererStateRef.current = state)\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x: any, y: any) {\n  return (\n    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare\n  )\n}\n\nconst objectIs: (x: any, y: any) => boolean =\n  typeof Object.is === 'function' ? Object.is : is\n\nexport default objectIs\n","// @flow\n// Source: https://github.com/facebook/react/blob/c21c41e/packages/react-dom/src/server/ReactPartialRendererHooks.js\n\nimport { readContextValue } from './context'\nimport { rendererStateRef } from './state'\nimport is from './objectIs'\n\nimport type {\n  MutableSource,\n  MutableSourceGetSnapshotFn,\n  MutableSourceSubscribeFn,\n  AbstractContext,\n  BasicStateAction,\n  Dispatch,\n  Update,\n  UpdateQueue,\n  Hook\n} from '../types'\n\nexport opaque type Identity = {}\nexport opaque type OpaqueIDType = string\n\nlet currentIdentity: Identity | null = null\n\nexport const makeIdentity = (): Identity => ({})\n\nexport const setCurrentIdentity = (id: Identity | null) => {\n  currentIdentity = id\n}\n\nexport const getCurrentIdentity = (): Identity => {\n  if (currentIdentity === null) {\n    throw new Error(\n      '[react-ssr-prepass] Hooks can only be called inside the body of a function component. ' +\n        '(https://fb.me/react-invalid-hook-call)'\n    )\n  }\n\n  // NOTE: The warning that is used in ReactPartialRendererHooks is obsolete\n  // in a prepass, since it'll be caught by a subsequent renderer anyway\n  // https://github.com/facebook/react/blob/c21c41e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L63-L71\n\n  return (currentIdentity: Identity)\n}\n\nlet firstWorkInProgressHook: Hook | null = null\nlet workInProgressHook: Hook | null = null\n// Whether an update was scheduled during the currently executing render pass.\nlet didScheduleRenderPhaseUpdate: boolean = false\n// Lazily created map of render-phase updates\nlet renderPhaseUpdates: Map<UpdateQueue<any>, Update<any>> | null = null\n// Counter to prevent infinite loops.\nlet numberOfReRenders: number = 0\nconst RE_RENDER_LIMIT = 25\n\nexport const getFirstHook = (): Hook | null => firstWorkInProgressHook\n\nexport const setFirstHook = (hook: Hook | null) => {\n  firstWorkInProgressHook = hook\n}\n\nfunction areHookInputsEqual(\n  nextDeps: Array<mixed>,\n  prevDeps: Array<mixed> | null\n) {\n  // NOTE: The warnings that are used in ReactPartialRendererHooks are obsolete\n  // in a prepass, since these issues will be caught by a subsequent renderer anyway\n  if (prevDeps === null) return false\n\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (!is(nextDeps[i], prevDeps[i])) return false\n  }\n\n  return true\n}\n\nfunction createHook(): Hook {\n  return {\n    memoizedState: null,\n    queue: null,\n    next: null\n  }\n}\n\nfunction createWorkInProgressHook(): Hook {\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    if (firstWorkInProgressHook === null) {\n      return (firstWorkInProgressHook = workInProgressHook = createHook())\n    } else {\n      // There's already a work-in-progress. Reuse it.\n      return (workInProgressHook = firstWorkInProgressHook)\n    }\n  } else {\n    if (workInProgressHook.next === null) {\n      // Append to the end of the list\n      return (workInProgressHook = workInProgressHook.next = createHook())\n    } else {\n      // There's already a work-in-progress. Reuse it.\n      return (workInProgressHook = workInProgressHook.next)\n    }\n  }\n}\n\nexport function renderWithHooks(\n  Component: any,\n  props: any,\n  refOrContext: any\n): any {\n  workInProgressHook = null\n  let children = Component(props, refOrContext)\n\n  // NOTE: Excessive rerenders won't throw but will instead abort rendering\n  // since a subsequent renderer can throw when this issue occurs instead\n  while (numberOfReRenders < RE_RENDER_LIMIT && didScheduleRenderPhaseUpdate) {\n    // Updates were scheduled during the render phase. They are stored in\n    // the `renderPhaseUpdates` map. Call the component again, reusing the\n    // work-in-progress hooks and applying the additional updates on top. Keep\n    // restarting until no more updates are scheduled.\n    didScheduleRenderPhaseUpdate = false\n    numberOfReRenders += 1\n    // Start over from the beginning of the list\n    workInProgressHook = null\n    children = Component(props, refOrContext)\n  }\n\n  // This will be reset by renderer\n  // firstWorkInProgressHook = null\n\n  numberOfReRenders = 0\n  renderPhaseUpdates = null\n  workInProgressHook = null\n\n  return children\n}\n\nfunction readContext(context: AbstractContext, _: void | number | boolean) {\n  // NOTE: The warning that is used in ReactPartialRendererHooks is obsolete\n  // in a prepass, since it'll be caught by a subsequent renderer anyway\n  // https://github.com/facebook/react/blob/c21c41e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L215-L223\n  return readContextValue(context)\n}\n\nfunction useContext(context: AbstractContext, _: void | number | boolean) {\n  getCurrentIdentity()\n  return readContextValue(context)\n}\n\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  // $FlowFixMe\n  return typeof action === 'function' ? action(state) : action\n}\n\nfunction useState<S>(\n  initialState: (() => S) | S\n): [S, Dispatch<BasicStateAction<S>>] {\n  return useReducer(\n    basicStateReducer,\n    // useReducer has a special case to support lazy useState initializers\n    (initialState: any)\n  )\n}\n\nfunction useReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: (I) => S\n): [S, Dispatch<A>] {\n  const id = getCurrentIdentity()\n  workInProgressHook = createWorkInProgressHook()\n\n  // In the case of a re-render after a suspense, the initial state\n  // may not be set, so instead of initialising if `!isRerender`, we\n  // check whether `queue` is set\n  if (workInProgressHook.queue === null) {\n    let initialState\n    if (reducer === basicStateReducer) {\n      // Special case for `useState`.\n      initialState =\n        typeof initialArg === 'function'\n          ? ((initialArg: any): () => S)()\n          : ((initialArg: any): S)\n    } else {\n      initialState =\n        init !== undefined ? init(initialArg) : ((initialArg: any): S)\n    }\n\n    workInProgressHook.memoizedState = initialState\n  }\n\n  const queue: UpdateQueue<A> =\n    workInProgressHook.queue ||\n    (workInProgressHook.queue = { last: null, dispatch: null })\n  const dispatch: Dispatch<A> =\n    queue.dispatch || (queue.dispatch = dispatchAction.bind(null, id, queue))\n\n  if (renderPhaseUpdates !== null) {\n    // This is a re-render. Apply the new render phase updates to the previous\n    // current hook.\n    // Render phase updates are stored in a map of queue -> linked list\n    const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue)\n    if (firstRenderPhaseUpdate !== undefined) {\n      renderPhaseUpdates.delete(queue)\n      let newState = workInProgressHook.memoizedState\n      let update = firstRenderPhaseUpdate\n      do {\n        // Process this render phase update. We don't have to check the\n        // priority because it will always be the same as the current\n        // render's.\n        const action = update.action\n        newState = reducer(newState, action)\n        update = update.next\n      } while (update !== null)\n\n      workInProgressHook.memoizedState = newState\n    }\n  }\n\n  return [workInProgressHook.memoizedState, dispatch]\n}\n\nfunction useMemo<T>(nextCreate: () => T, deps: Array<mixed> | void | null): T {\n  getCurrentIdentity()\n  workInProgressHook = createWorkInProgressHook()\n\n  const nextDeps = deps === undefined ? null : deps\n  const prevState = workInProgressHook.memoizedState\n  if (prevState !== null && nextDeps !== null) {\n    const prevDeps = prevState[1]\n    if (areHookInputsEqual(nextDeps, prevDeps)) {\n      return prevState[0]\n    }\n  }\n\n  const nextValue = nextCreate()\n  workInProgressHook.memoizedState = [nextValue, nextDeps]\n  return nextValue\n}\n\nfunction useRef<T>(initialValue: T): { current: T } {\n  getCurrentIdentity()\n  workInProgressHook = createWorkInProgressHook()\n  const previousRef = workInProgressHook.memoizedState\n  if (previousRef === null) {\n    const ref = { current: initialValue }\n    workInProgressHook.memoizedState = ref\n    return ref\n  } else {\n    return previousRef\n  }\n}\n\nfunction useOpaqueIdentifier(): OpaqueIDType {\n  getCurrentIdentity()\n  workInProgressHook = createWorkInProgressHook()\n  if (!workInProgressHook.memoizedState)\n    workInProgressHook.memoizedState =\n      'R:' + (rendererStateRef.current.uniqueID++).toString(36)\n  return workInProgressHook.memoizedState\n}\n\nfunction dispatchAction<A>(\n  componentIdentity: Identity,\n  queue: UpdateQueue<A>,\n  action: A\n) {\n  if (componentIdentity === currentIdentity) {\n    // This is a render phase update. Stash it in a lazily-created map of\n    // queue -> linked list of updates. After this render pass, we'll restart\n    // and apply the stashed updates on top of the work-in-progress hook.\n    didScheduleRenderPhaseUpdate = true\n    const update: Update<A> = {\n      action,\n      next: null\n    }\n    if (renderPhaseUpdates === null) {\n      renderPhaseUpdates = new Map()\n    }\n    const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue)\n    if (firstRenderPhaseUpdate === undefined) {\n      renderPhaseUpdates.set(queue, update)\n    } else {\n      // Append the update to the end of the list.\n      let lastRenderPhaseUpdate = firstRenderPhaseUpdate\n      while (lastRenderPhaseUpdate.next !== null) {\n        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next\n      }\n      lastRenderPhaseUpdate.next = update\n    }\n  } else {\n    // This means an update has happened after the function component has\n    // returned. On the server this is a no-op. In React Fiber, the update\n    // would be scheduled for a future render.\n  }\n}\n\nfunction useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  return useMemo(() => callback, deps)\n}\n\nfunction useMutableSource<Source, Snapshot>(\n  source: MutableSource<Source>,\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n  _subscribe: MutableSourceSubscribeFn<Source, Snapshot>\n): Snapshot {\n  getCurrentIdentity()\n  return getSnapshot(source._source)\n}\n\nfunction noop(): void {}\n\nfunction useTransition(): [(callback: () => void) => void, boolean] {\n  const startTransition = (callback) => {\n    callback()\n  }\n  return [startTransition, false]\n}\n\nfunction useDeferredValue<T>(input: T): T {\n  return input\n}\n\n// See: https://github.com/facebook/react/blob/fe41934/packages/use-sync-external-store/src/useSyncExternalStoreShimServer.js#L10-L20\nfunction useSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T\n): T {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot()\n}\n\nexport const Dispatcher = {\n  readContext,\n  useSyncExternalStore,\n  useContext,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n  useCallback,\n  useMutableSource,\n  useTransition,\n  useDeferredValue,\n  useOpaqueIdentifier,\n  // aliased for now\n  // see: https://github.com/FormidableLabs/react-ssr-prepass/pull/75\n  useId: useOpaqueIdentifier,\n  unstable_useId: useOpaqueIdentifier,\n  unstable_useOpaqueIdentifier: useOpaqueIdentifier,\n  // ignore useLayout effect completely as usage of it will be caught\n  // in a subsequent render pass\n  useLayoutEffect: noop,\n  // useImperativeHandle is not run in the server environment\n  useImperativeHandle: noop,\n  // Effects are not run in the server environment.\n  useEffect: noop,\n  // Debugging effect\n  useDebugValue: noop,\n  // Don't care about css-in-js\n  useInsertionEffect: noop,\n  isPlasmicPrepass: true\n}\n","// @flow\n\nimport { createElement, type Node } from 'react'\nimport type {\n  LazyComponent,\n  LazyComponentPayload,\n  DefaultProps,\n  LazyFrame,\n  Frame\n} from '../types'\nimport { getChildrenArray } from '../element'\n\nimport {\n  setCurrentIdentity,\n  setCurrentContextStore,\n  getCurrentContextStore,\n  setCurrentContextMap,\n  getCurrentContextMap,\n  setCurrentErrorFrame,\n  getCurrentErrorFrame\n} from '../internals'\n\nconst resolve = (type: LazyComponent): Promise<void> => {\n  const payload = (type._payload || type: any)\n  if (payload._status === 0) {\n    return payload._result\n  } else if (payload._status === 1) {\n    return Promise.resolve(payload._result)\n  } else if (payload._status === 2) {\n    return Promise.reject(payload._result)\n  }\n\n  payload._status = 0 /* PENDING */\n\n  return (payload._result = (payload._ctor || payload._result)()\n    .then((Component) => {\n      payload._result = Component\n      if (typeof Component === 'function') {\n        payload._status = 1 /* SUCCESSFUL */\n      } else if (\n        Component !== null &&\n        typeof Component === 'object' &&\n        typeof Component.default === 'function'\n      ) {\n        payload._result = Component.default\n        payload._status = 1 /* SUCCESSFUL */\n      } else {\n        payload._status = 2 /* FAILED */\n      }\n    })\n    .catch((error) => {\n      payload._status = 2 /* FAILED */\n      payload._result = error\n      return Promise.reject(error)\n    }))\n}\n\nconst makeFrame = (\n  type: LazyComponent,\n  props: DefaultProps,\n  thenable: Promise<any>\n) => ({\n  kind: 'frame.lazy',\n  contextMap: getCurrentContextMap(),\n  contextStore: getCurrentContextStore(),\n  errorFrame: getCurrentErrorFrame(),\n  thenable,\n  props,\n  type\n})\n\nconst render = (\n  type: LazyComponent,\n  props: DefaultProps,\n  queue: Frame[]\n): Node => {\n  // Component has previously been fetched successfully,\n  // so create the element with passed props and return it\n  const payload = ((type._payload || type: any): LazyComponentPayload)\n  if (payload._status === 1 && payload._result) {\n    return createElement(payload._result, props)\n  }\n\n  try {\n    return createElement((type: any)._init((type: any)._payload), props)\n  } catch (err) {\n    if (!!err && typeof err.then === 'function') {\n      queue.push(makeFrame(type, props, err))\n    }\n    return null\n  }\n}\n\nexport const mount = (\n  type: LazyComponent,\n  props: DefaultProps,\n  queue: Frame[]\n): Node => {\n  // If the component has not been fetched yet, suspend this component\n  const payload = ((type._payload || type: any): LazyComponentPayload)\n  // For lazy components from resolved modules (e.g. Client Components)\n  // The `payload._status` is null.\n  // Reference code for \"normal\" lazy components: https://github.com/facebook/react/blob/main/packages/react/src/ReactLazy.js#L53\n  // Reference code for Client Component chunks: https://github.com/facebook/react/blob/main/packages/react-client/src/ReactFlightClient.js#L955\n  if (payload._status != null && payload._status <= 0) {\n    queue.push(makeFrame(type, props, resolve(type)))\n\n    return null\n  }\n\n  return render(type, props, queue)\n}\n\nexport const update = (queue: Frame[], frame: LazyFrame): Node => {\n  setCurrentIdentity(null)\n  setCurrentContextMap(frame.contextMap)\n  setCurrentContextStore(frame.contextStore)\n  setCurrentErrorFrame(frame.errorFrame)\n  return render(frame.type, frame.props, queue)\n}\n","// @flow\n\nimport type { Node, ComponentType } from 'react'\nimport { computeProps } from '../element'\n\nimport type {\n  Visitor,\n  Hook,\n  Frame,\n  HooksFrame,\n  DefaultProps,\n  ComponentStatics,\n  UserElement\n} from '../types'\n\nimport {\n  type Identity,\n  maskContext,\n  makeIdentity,\n  setCurrentIdentity,\n  getCurrentIdentity,\n  setCurrentContextStore,\n  getCurrentContextStore,\n  setCurrentContextMap,\n  getCurrentContextMap,\n  setCurrentErrorFrame,\n  getCurrentErrorFrame,\n  renderWithHooks,\n  setFirstHook,\n  getFirstHook\n} from '../internals'\nimport { getComponentName } from '../utils'\n\nconst makeFrame = (\n  type: ComponentType<DefaultProps> & ComponentStatics,\n  props: DefaultProps,\n  thenable: Promise<any>\n) => ({\n  contextMap: getCurrentContextMap(),\n  contextStore: getCurrentContextStore(),\n  id: getCurrentIdentity(),\n  hook: getFirstHook(),\n  kind: 'frame.hooks',\n  errorFrame: getCurrentErrorFrame(),\n  thenable,\n  props,\n  type\n})\n\nconst render = (\n  type: ComponentType<DefaultProps> & ComponentStatics,\n  props: DefaultProps,\n  queue: Frame[]\n): Node => {\n  try {\n    return renderWithHooks(\n      type,\n      computeProps(props, type.defaultProps),\n      maskContext(type)\n    )\n  } catch (error) {\n    if (typeof error.then !== 'function') {\n      console.warn(\n        `PLASMIC: Encountered error when pre-rendering ${getComponentName(\n          type\n        )}: ${error}`\n      )\n      return null\n    }\n\n    queue.push(makeFrame(type, props, error))\n    return null\n  }\n}\n\n/** Mount a function component */\nexport const mount = (\n  type: ComponentType<DefaultProps> & ComponentStatics,\n  props: DefaultProps,\n  queue: Frame[],\n  visitor: Visitor,\n  element: UserElement\n): Node => {\n  setFirstHook(null)\n  setCurrentIdentity(makeIdentity())\n\n  const promise = visitor(element)\n  if (promise) {\n    queue.push(makeFrame(type, props, promise))\n    return null\n  }\n\n  return render(type, props, queue)\n}\n\n/** Update a previously suspended function component */\nexport const update = (queue: Frame[], frame: HooksFrame) => {\n  setFirstHook(frame.hook)\n  setCurrentIdentity(frame.id)\n  setCurrentContextMap(frame.contextMap)\n  setCurrentContextStore(frame.contextStore)\n  setCurrentErrorFrame(frame.errorFrame)\n  return render(frame.type, frame.props, queue)\n}\n","// @flow\n\nimport type { Node, ComponentType } from 'react'\nimport { computeProps } from '../element'\n\nimport type {\n  Visitor,\n  Frame,\n  ClassFrame,\n  DefaultProps,\n  ComponentStatics,\n  UserElement\n} from '../types'\n\nimport {\n  maskContext,\n  assignContextMap,\n  setCurrentIdentity,\n  setCurrentContextMap,\n  getCurrentContextMap,\n  setCurrentContextStore,\n  getCurrentContextStore,\n  setCurrentErrorFrame,\n  getCurrentErrorFrame\n} from '../internals'\nimport { getComponentName } from '../utils'\n\nconst RE_RENDER_LIMIT = 25\n\nconst createUpdater = () => {\n  const queue = []\n\n  return {\n    _thrown: 0,\n    queue,\n    isMounted: () => false,\n    enqueueForceUpdate: () => null,\n    enqueueReplaceState: (instance, completeState) => {\n      if (instance._isMounted) {\n        queue.length = 0\n        queue.push(completeState)\n      }\n    },\n    enqueueSetState: (instance, currentPartialState) => {\n      if (instance._isMounted) {\n        queue.push(currentPartialState)\n      }\n    }\n  }\n}\n\nconst flushEnqueuedState = (instance: any) => {\n  const queue = (instance.updater.queue: any[])\n\n  if (queue.length > 0) {\n    let nextState = Object.assign({}, instance.state)\n\n    for (let i = 0, l = queue.length; i < l; i++) {\n      const partial = queue[i]\n      const partialState =\n        typeof partial === 'function'\n          ? partial.call(instance, nextState, instance.props, instance.context)\n          : partial\n      if (partialState !== null) {\n        Object.assign(nextState, partialState)\n      }\n    }\n\n    instance.state = nextState\n    queue.length = 0\n  }\n}\n\nconst createInstance = (type: any, props: DefaultProps) => {\n  const updater = createUpdater()\n  const computedProps = computeProps(props, type.defaultProps)\n  const context = maskContext(type)\n  const instance = new type(computedProps, context, updater)\n\n  instance.props = computedProps\n  instance.context = context\n  instance.updater = updater\n  instance._isMounted = true\n\n  if (instance.state === undefined) {\n    instance.state = null\n  }\n\n  if (\n    typeof instance.componentDidCatch === 'function' ||\n    typeof type.getDerivedStateFromError === 'function'\n  ) {\n    const frame = makeFrame(type, instance, null)\n    frame.errorFrame = frame\n    setCurrentErrorFrame(frame)\n  }\n\n  if (typeof type.getDerivedStateFromProps === 'function') {\n    const { getDerivedStateFromProps } = type\n    const state = getDerivedStateFromProps(instance.props, instance.state)\n    if (state !== null && state !== undefined) {\n      instance.state = Object.assign({}, instance.state, state)\n    }\n  } else if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount()\n  } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount()\n  }\n\n  return instance\n}\n\nconst makeFrame = (\n  type: any,\n  instance: any,\n  thenable: Promise<any> | null\n) => ({\n  contextMap: getCurrentContextMap(),\n  contextStore: getCurrentContextStore(),\n  errorFrame: getCurrentErrorFrame(),\n  thenable,\n  kind: 'frame.class',\n  error: null,\n  instance,\n  type\n})\n\nconst render = (type: any, instance: any, queue: Frame[]) => {\n  // Flush all queued up state changes\n  flushEnqueuedState(instance)\n  let child: Node = null\n\n  try {\n    child = instance.render()\n  } catch (error) {\n    if (typeof error.then !== 'function') {\n      console.warn(\n        `PLASMIC: Encountered error when pre-rendering component ${getComponentName(\n          type\n        )}. This is fine as long as you are not fetching data with @plasmicapp/query inside this component.  Error: ${error}`\n      )\n      return null\n    }\n\n    queue.push(makeFrame(type, instance, error))\n    return null\n  }\n\n  if (\n    type.childContextTypes !== undefined &&\n    typeof instance.getChildContext === 'function'\n  ) {\n    const childContext = instance.getChildContext()\n    if (childContext !== null && typeof childContext === 'object') {\n      assignContextMap(childContext)\n    }\n  }\n\n  if (\n    typeof instance.getDerivedStateFromProps !== 'function' &&\n    (typeof instance.componentWillMount === 'function' ||\n      typeof instance.UNSAFE_componentWillMount === 'function') &&\n    typeof instance.componentWillUnmount === 'function'\n  ) {\n    try {\n      instance.componentWillUnmount()\n    } catch (_err) {}\n  }\n\n  instance._isMounted = false\n  return child\n}\n\n/** Mount a class component */\nexport const mount = (\n  type: ComponentType<DefaultProps> & ComponentStatics,\n  props: DefaultProps,\n  queue: Frame[],\n  visitor: Visitor,\n  element: UserElement\n) => {\n  setCurrentIdentity(null)\n\n  const instance = createInstance(type, props)\n  const promise = visitor(element, instance)\n  if (promise) {\n    queue.push(makeFrame(type, instance, promise))\n    return null\n  }\n\n  return render(type, instance, queue)\n}\n\n/** Update a previously suspended class component */\nexport const update = (queue: Frame[], frame: ClassFrame) => {\n  setCurrentIdentity(null)\n  setCurrentContextMap(frame.contextMap)\n  setCurrentContextStore(frame.contextStore)\n  setCurrentErrorFrame(frame.errorFrame)\n\n  if (frame.error) {\n    // We simply have to bail when a loop occurs\n    if (++frame.instance.updater._thrown >= RE_RENDER_LIMIT) return null\n\n    frame.instance._isMounted = true\n\n    if (typeof frame.instance.componentDidCatch === 'function') {\n      frame.instance.componentDidCatch(frame.error)\n    }\n\n    if (typeof frame.type.getDerivedStateFromError === 'function') {\n      frame.instance.updater.enqueueSetState(\n        frame.instance,\n        frame.type.getDerivedStateFromError(frame.error)\n      )\n    }\n  }\n\n  return render(frame.type, frame.instance, queue)\n}\n","// @flow\n\nimport React, { type Node, type ComponentType, createElement } from 'react'\nimport { computeProps, getChildrenArray, typeOf } from '../element'\n\nimport type {\n  Visitor,\n  Hook,\n  Frame,\n  DefaultProps,\n  ComponentStatics,\n  UserElement,\n  ClientReference,\n  ClientReferenceElement,\n  ClientReferenceVisitor,\n  ClientRefFrame\n} from '../types'\n\nimport {\n  type Identity,\n  maskContext,\n  makeIdentity,\n  setCurrentIdentity,\n  getCurrentIdentity,\n  setCurrentContextStore,\n  getCurrentContextStore,\n  setCurrentContextMap,\n  getCurrentContextMap,\n  setCurrentErrorFrame,\n  getCurrentErrorFrame,\n  renderWithHooks,\n  setFirstHook,\n  getFirstHook\n} from '../internals'\nimport { getComponentName } from '../utils'\n\n// When rendering RSC, we cannot access client components directly and only\n// see a client reference. We support using a visitor instead to behave as the\n// client component would, possibly throwing promises, using hooks or contexts\n// (whose read/write functions are exposed via `globalThis.__ssrPrepassEnv`),\n// and returning a new node element.\nconst render = (\n  type: ClientReference,\n  props: DefaultProps,\n  queue: Frame[],\n  clientRefVisitor: ClientReferenceVisitor,\n  element: ClientReferenceElement\n): Node => {\n  try {\n    const node = clientRefVisitor((element: any))\n    // We cannot access client component references in RSC phase, so we just\n    // render the props (or whatever node has been returned by the visitor)\n    return createElement(React.Fragment, ({}: any), [\n      ...(node\n        ? getChildrenArray((node: any))\n        : (Object.values(props)\n            .flat(Infinity)\n            .filter(\n              (elt) => elt && typeof elt === 'object' && typeOf((elt: any))\n            ): any))\n    ])\n  } catch (error) {\n    if (typeof error.then !== 'function') {\n      console.warn(\n        `PLASMIC: Encountered error when pre-rendering client reference: ${error}`\n      )\n      return null\n    }\n\n    queue.push({\n      contextMap: getCurrentContextMap(),\n      contextStore: getCurrentContextStore(),\n      errorFrame: getCurrentErrorFrame(),\n      id: getCurrentIdentity(),\n      hook: getFirstHook(),\n      thenable: error,\n      kind: 'client-ref',\n      type,\n      props,\n      element,\n      clientRefVisitor\n    })\n    return null\n  }\n}\n\nexport const mount = (\n  type: ClientReference,\n  props: DefaultProps,\n  queue: Frame[],\n  clientRefVisitor: ClientReferenceVisitor,\n  element: ClientReferenceElement\n): Node => {\n  setFirstHook(null)\n  setCurrentIdentity(makeIdentity())\n\n  return render(type, props, queue, clientRefVisitor, element)\n}\n\nexport const update = (queue: Frame[], frame: ClientRefFrame): Node => {\n  setFirstHook(frame.hook)\n  setCurrentIdentity(frame.id)\n  setCurrentContextMap(frame.contextMap)\n  setCurrentContextStore(frame.contextStore)\n  setCurrentErrorFrame(frame.errorFrame)\n  return render(\n    frame.type,\n    frame.props,\n    queue,\n    frame.clientRefVisitor,\n    frame.element\n  )\n}\n","// @flow\n\nimport React, { type Node, type ComponentType, createElement } from 'react'\n\nimport {\n  typeOf,\n  shouldConstruct,\n  getChildrenArray,\n  computeProps\n} from './element'\n\nimport {\n  mountFunctionComponent,\n  updateFunctionComponent,\n  mountClassComponent,\n  updateClassComponent,\n  mountLazyComponent,\n  updateLazyComponent,\n  mountClientReference,\n  updateClientReference\n} from './render'\n\nimport type {\n  Visitor,\n  ClientReferenceVisitor,\n  YieldFrame,\n  ClassFrame,\n  Frame,\n  ContextMap,\n  ContextEntry,\n  DefaultProps,\n  ComponentStatics,\n  LazyElement,\n  AbstractElement,\n  ConsumerElement,\n  ProviderElement,\n  FragmentElement,\n  SuspenseElement,\n  ForwardRefElement,\n  MemoElement,\n  UserElement,\n  DOMElement,\n  ClientReferenceElement,\n  ClientReference\n} from './types'\n\nimport {\n  getCurrentContextMap,\n  getCurrentContextStore,\n  setCurrentContextMap,\n  setCurrentContextStore,\n  flushPrevContextMap,\n  flushPrevContextStore,\n  restoreContextMap,\n  restoreContextStore,\n  readContextValue,\n  setContextValue,\n  setCurrentIdentity,\n  setCurrentErrorFrame,\n  getCurrentErrorFrame,\n  Dispatcher,\n  setFirstHook,\n  getCurrentIdentity,\n  getFirstHook\n} from './internals'\n\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_TRANSITIONAL_ELEMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_PROVIDER_TYPE,\n  REACT_CONTEXT_TYPE,\n  REACT_CONCURRENT_MODE_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_LAZY_TYPE,\n  REACT_CONSUMER_TYPE\n} from './symbols'\n\nimport { isClientReference, isReact19 } from './utils'\n\nconst REACT_INTERNALS =\n  (React: any).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED ||\n  (React: any)\n    .__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE ||\n  (React: any).__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE\n\nconst ReactCurrentDispatcher =\n  REACT_INTERNALS.ReactCurrentDispatcher || REACT_INTERNALS\n\nconst getReactCurrentDispatcher = () => {\n  return ReactCurrentDispatcher.current || ReactCurrentDispatcher.H\n}\n\nconst injectReactCurrentDispatcher = (newDispatcher) => {\n  if (!isReact19()) {\n    ReactCurrentDispatcher.current = newDispatcher\n  } else {\n    ReactCurrentDispatcher.H = newDispatcher\n  }\n}\n\n// In the presence of setImmediate, i.e. on Node, we'll enable the\n// yielding behavior that gives the event loop a chance to continue\n// running when the prepasses would otherwise take too long\nexport const SHOULD_YIELD = typeof setImmediate === 'function'\n// Time in ms after which the otherwise synchronous visitor yields so that\n// the event loop is not interrupted for too long\nconst YIELD_AFTER_MS = 5\n\nconst render = (\n  type: (ComponentType<DefaultProps> & ComponentStatics) | ClientReference,\n  props: DefaultProps,\n  queue: Frame[],\n  visitor: Visitor,\n  clientRefVisitor: ClientReferenceVisitor,\n  element: UserElement | ClientReferenceElement\n) => {\n  if (isClientReference(type)) {\n    return mountClientReference(\n      (type: any),\n      props,\n      queue,\n      clientRefVisitor,\n      (element: any)\n    )\n  }\n  return shouldConstruct((type: any))\n    ? mountClassComponent((type: any), props, queue, visitor, (element: any))\n    : mountFunctionComponent((type: any), props, queue, visitor, (element: any))\n}\n\nexport const visitElement = (\n  element: AbstractElement,\n  queue: Frame[],\n  visitor: Visitor,\n  clientRefVisitor: ClientReferenceVisitor\n): AbstractElement[] => {\n  switch (typeOf(element)) {\n    case REACT_SUSPENSE_TYPE:\n    case REACT_STRICT_MODE_TYPE:\n    case REACT_CONCURRENT_MODE_TYPE:\n    case REACT_PROFILER_TYPE:\n    case REACT_FRAGMENT_TYPE: {\n      // These element types are simply traversed over but otherwise ignored\n      const fragmentElement = ((element: any):\n        | FragmentElement\n        | SuspenseElement)\n      return getChildrenArray(fragmentElement.props.children)\n    }\n\n    case REACT_PROVIDER_TYPE: {\n      const providerElement = ((element: any): ProviderElement)\n      // Add provider's value prop to context\n      const { value, children } = providerElement.props\n      const type = (providerElement.type: any)\n      const context = typeof type._context === 'object' ? type._context : type\n      setContextValue(context, value)\n\n      return getChildrenArray(children)\n    }\n\n    case REACT_CONSUMER_TYPE: {\n      const consumerElement = ((element: any): ConsumerElement)\n      const { children } = consumerElement.props\n\n      // Read from context and call children, if it's been passed\n      if (typeof children === 'function') {\n        const type = (consumerElement.type: any)\n        const context = typeof type._context === 'object' ? type._context : type\n        const value = readContextValue(context)\n        return getChildrenArray(children(value))\n      } else {\n        return []\n      }\n    }\n\n    case REACT_LAZY_TYPE: {\n      const lazyElement = ((element: any): LazyElement)\n      const type = lazyElement.type\n      const child = mountLazyComponent(type, lazyElement.props, queue)\n      return getChildrenArray(child)\n    }\n\n    case REACT_MEMO_TYPE: {\n      const memoElement = ((element: any): MemoElement)\n      const { type } = memoElement.type\n      const child = createElement((type: any), memoElement.props)\n      return getChildrenArray(child)\n    }\n\n    case REACT_FORWARD_REF_TYPE: {\n      const refElement = ((element: any): ForwardRefElement)\n      const { render: type, defaultProps } = refElement.type\n      const props = computeProps(refElement.props, defaultProps)\n      const child = createElement((type: any), props)\n      return getChildrenArray(child)\n    }\n\n    case REACT_ELEMENT_TYPE: {\n      const el = ((element: any): UserElement | DOMElement)\n      if (typeof el.type === 'string') {\n        // String elements can be skipped, so we just return children\n        return getChildrenArray(el.props.children)\n      } else {\n        const userElement = ((element: any):\n          | UserElement\n          | ClientReferenceElement)\n        const { type, props } = userElement\n        const child = render(\n          type,\n          props,\n          queue,\n          visitor,\n          clientRefVisitor,\n          userElement\n        )\n        return getChildrenArray(child)\n      }\n    }\n\n    case REACT_PORTAL_TYPE:\n    // Portals are unsupported during SSR since they're DOM-only\n    default:\n      return []\n  }\n}\n\nconst visitLoop = (\n  traversalChildren: AbstractElement[][],\n  traversalMap: Array<void | ContextMap>,\n  traversalStore: Array<void | ContextEntry>,\n  traversalErrorFrame: Array<null | ClassFrame>,\n  queue: Frame[],\n  visitor: Visitor,\n  clientRefVisitor: ClientReferenceVisitor\n): boolean => {\n  const prevDispatcher = getReactCurrentDispatcher()\n  const start = Date.now()\n\n  try {\n    injectReactCurrentDispatcher(Dispatcher)\n    while (traversalChildren.length > 0) {\n      const element = traversalChildren[traversalChildren.length - 1].shift()\n      if (element !== undefined) {\n        const children = visitElement(element, queue, visitor, clientRefVisitor)\n        traversalChildren.push(children)\n        traversalMap.push(flushPrevContextMap())\n        traversalStore.push(flushPrevContextStore())\n        traversalErrorFrame.push(getCurrentErrorFrame())\n      } else {\n        traversalChildren.pop()\n        restoreContextMap(traversalMap.pop())\n        restoreContextStore(traversalStore.pop())\n        setCurrentErrorFrame(traversalErrorFrame.pop())\n      }\n\n      if (SHOULD_YIELD && Date.now() - start > YIELD_AFTER_MS) {\n        return true\n      }\n    }\n\n    return false\n  } catch (error) {\n    const errorFrame = getCurrentErrorFrame()\n    if (!errorFrame) throw error\n    errorFrame.error = error\n    queue.unshift(errorFrame)\n    return false\n  } finally {\n    injectReactCurrentDispatcher(prevDispatcher)\n  }\n}\n\nconst makeYieldFrame = (\n  traversalChildren: AbstractElement[][],\n  traversalMap: Array<void | ContextMap>,\n  traversalStore: Array<void | ContextEntry>,\n  traversalErrorFrame: Array<null | ClassFrame>\n): Frame => ({\n  contextMap: getCurrentContextMap(),\n  contextStore: getCurrentContextStore(),\n  errorFrame: getCurrentErrorFrame(),\n  thenable: null,\n  kind: 'frame.yield',\n  traversalChildren,\n  traversalMap,\n  traversalStore,\n  traversalErrorFrame\n})\n\nexport const visit = (\n  init: AbstractElement[],\n  queue: Frame[],\n  visitor: Visitor,\n  clientRefVisitor: ClientReferenceVisitor\n) => {\n  const traversalChildren: AbstractElement[][] = [init]\n  const traversalMap: Array<void | ContextMap> = [flushPrevContextMap()]\n  const traversalStore: Array<void | ContextEntry> = [flushPrevContextStore()]\n  const traversalErrorFrame: Array<null | ClassFrame> = [getCurrentErrorFrame()]\n\n  const hasYielded = visitLoop(\n    traversalChildren,\n    traversalMap,\n    traversalStore,\n    traversalErrorFrame,\n    queue,\n    visitor,\n    clientRefVisitor\n  )\n\n  if (hasYielded) {\n    queue.unshift(\n      makeYieldFrame(\n        traversalChildren,\n        traversalMap,\n        traversalStore,\n        traversalErrorFrame\n      )\n    )\n  }\n}\n\nexport const update = (\n  frame: Frame,\n  queue: Frame[],\n  visitor: Visitor,\n  clientRefVisitor: ClientReferenceVisitor\n) => {\n  if (frame.kind === 'frame.yield') {\n    setCurrentIdentity(null)\n    setCurrentContextMap(frame.contextMap)\n    setCurrentContextStore(frame.contextStore)\n    setCurrentErrorFrame(frame.errorFrame)\n\n    const hasYielded = visitLoop(\n      frame.traversalChildren,\n      frame.traversalMap,\n      frame.traversalStore,\n      frame.traversalErrorFrame,\n      queue,\n      visitor,\n      clientRefVisitor\n    )\n\n    if (hasYielded) {\n      queue.unshift(\n        makeYieldFrame(\n          frame.traversalChildren,\n          frame.traversalMap,\n          frame.traversalStore,\n          frame.traversalErrorFrame\n        )\n      )\n    }\n  } else {\n    const prevDispatcher = getReactCurrentDispatcher()\n    let children = null\n\n    injectReactCurrentDispatcher(Dispatcher)\n\n    try {\n      if (frame.kind === 'frame.class') {\n        children = updateClassComponent(queue, frame)\n      } else if (frame.kind === 'frame.hooks') {\n        children = updateFunctionComponent(queue, frame)\n      } else if (frame.kind === 'frame.lazy') {\n        children = updateLazyComponent(queue, frame)\n      } else if (frame.kind === 'client-ref') {\n        children = updateClientReference(queue, frame)\n      }\n    } catch (error) {\n      const errorFrame = getCurrentErrorFrame()\n      if (!errorFrame) throw error\n      errorFrame.error = error\n      queue.unshift(errorFrame)\n      children = null\n    } finally {\n      injectReactCurrentDispatcher(prevDispatcher)\n    }\n\n    visit(getChildrenArray(children), queue, visitor, clientRefVisitor)\n  }\n}\n","// @flow\n\nimport { type Node, type Element } from 'react'\nimport type {\n  Visitor,\n  ClientReferenceVisitor,\n  YieldFrame,\n  Frame,\n  AbstractElement,\n  RendererState\n} from './types'\nimport { visit, update, SHOULD_YIELD } from './visitor'\nimport { getChildrenArray } from './element'\n\nimport {\n  setCurrentContextStore,\n  setCurrentContextMap,\n  setCurrentErrorFrame,\n  getCurrentErrorFrame,\n  setCurrentRendererState,\n  initRendererState,\n  Dispatcher,\n  readContextValue,\n  setContextValue\n} from './internals'\n\n/** visit() walks all elements (depth-first) and while it walks the\n    element tree some components will suspend and put a `Frame` onto\n    the queue. Hence we recursively look at suspended components in\n    this queue, wait for their promises to resolve, and continue\n    calling visit() on their children. */\nconst flushFrames = (\n  queue: Frame[],\n  visitor: Visitor,\n  clientRefVisitor: ClientReferenceVisitor,\n  state: RendererState\n): Promise<void> => {\n  const frame = queue.shift()\n  if (!frame) {\n    return Promise.resolve()\n  }\n\n  if (SHOULD_YIELD && frame.kind === 'frame.yield') {\n    frame.thenable = new Promise((resolve, reject) => {\n      setImmediate(resolve)\n    })\n  }\n\n  return Promise.resolve(frame.thenable).then(\n    () => {\n      setCurrentRendererState(state)\n      update(frame, queue, visitor, clientRefVisitor)\n      return flushFrames(queue, visitor, clientRefVisitor, state)\n    },\n    (error: Error) => {\n      if (!frame.errorFrame) throw error\n      frame.errorFrame.error = error\n      update(frame.errorFrame, queue, visitor, clientRefVisitor)\n    }\n  )\n}\n\nconst defaultVisitor = () => undefined\n\ndeclare var globalThis: any\n\nlet runningPrepassCount = 0\n\nconst renderPrepass = (\n  element: Node,\n  visitor?: Visitor,\n  clientRefVisitor?: ClientReferenceVisitor\n): Promise<void> => {\n  if (!visitor) visitor = defaultVisitor\n  if (!clientRefVisitor) clientRefVisitor = defaultVisitor\n\n  const queue: Frame[] = []\n  // Renderer state is kept globally but restored and\n  // passed around manually since it isn't dependent on the\n  // render tree\n  const state = initRendererState()\n  // Context state is kept globally and is modified in-place.\n  // Before we start walking the element tree we need to reset\n  // its current state\n  setCurrentContextMap({})\n  setCurrentContextStore(new Map())\n  setCurrentErrorFrame(null)\n\n  try {\n    runningPrepassCount++\n    globalThis.__ssrPrepassEnv = { readContextValue, setContextValue }\n    visit(getChildrenArray(element), queue, visitor, clientRefVisitor)\n  } catch (error) {\n    runningPrepassCount--\n    if (!runningPrepassCount) {\n      delete globalThis.__ssrPrepassEnv\n    }\n    return Promise.reject(error)\n  }\n\n  return flushFrames(queue, visitor, clientRefVisitor, state).finally(() => {\n    runningPrepassCount--\n    if (!runningPrepassCount) {\n      delete globalThis.__ssrPrepassEnv\n    }\n  })\n}\n\nexport default renderPrepass\n"],"names":["let","Element","TransitionalElement","Portal","Fragment","StrictMode","Profiler","ContextProvider","ContextConsumer","undefined","Context","ConcurrentMode","ForwardRef","Suspense","Memo","Lazy","ClientReferenceTag","Symbol","for","const","symbolFor","REACT_ELEMENT_TYPE","REACT_TRANSITIONAL_ELEMENT_TYPE","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_PROVIDER_TYPE","REACT_CONSUMER_TYPE","REACT_CONTEXT_TYPE","REACT_CONCURRENT_MODE_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","CLIENT_REFERENCE_TAG","isClientReference","reference","$$typeof","getComponentName","type","displayName","shouldConstruct","constructor","name","isReact19","React","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","Comp","prototype","isReactComponent","typeOf","x","toArray","Children","isAbstractElement","node","getChildrenArray","filter","computeProps","props","defaultProps","Object","currentContextStore","Map","currentContextMap","prevContextMap","prevContextEntry","getCurrentContextMap","getCurrentContextStore","flushPrevContextMap","prev","flushPrevContextStore","restoreContextMap","restoreContextStore","set","setCurrentContextMap","map","setCurrentContextStore","store","assignContextMap","setContextValue","context","value","get","readContextValue","_currentValue","emptyContext","maskContext","contextType","contextTypes","maskedContext","currentErrorFrame","getCurrentErrorFrame","setCurrentErrorFrame","frame","rendererStateRef","current","uniqueID","initRendererState","setCurrentRendererState","state","is","y","objectIs","is$1","currentIdentity","makeIdentity","setCurrentIdentity","id","getCurrentIdentity","Error","firstWorkInProgressHook","workInProgressHook","didScheduleRenderPhaseUpdate","renderPhaseUpdates","numberOfReRenders","RE_RENDER_LIMIT","getFirstHook","setFirstHook","hook","areHookInputsEqual","nextDeps","prevDeps","i","length","createHook","memoizedState","queue","next","createWorkInProgressHook","renderWithHooks","Component","refOrContext","children","readContext","_","useContext","basicStateReducer","action","useState","initialState","useReducer","reducer","initialArg","init","last","dispatch","dispatchAction","bind","firstRenderPhaseUpdate","delete","newState","update","useMemo","nextCreate","deps","prevState","nextValue","useRef","initialValue","previousRef","ref","useOpaqueIdentifier","toString","componentIdentity","lastRenderPhaseUpdate","useCallback","callback","useMutableSource","source","getSnapshot","_subscribe","_source","noop","_ref","useTransition","startTransition","useDeferredValue","input","useSyncExternalStore","subscribe","getServerSnapshot","Dispatcher","useId","unstable_useId","unstable_useOpaqueIdentifier","useLayoutEffect","useImperativeHandle","useEffect","useDebugValue","useInsertionEffect","isPlasmicPrepass","resolve","payload","_payload","_status","_result","Promise","reject","_ctor","then","default","catch","error","makeFrame","thenable","kind","contextMap","contextStore","errorFrame","render","createElement","_init","err","push","mount","console","warn","visitor","element","promise","isMounted","enqueueForceUpdate","createUpdater","_thrown","_ref2","enqueueReplaceState","instance","completeState","_isMounted","enqueueSetState","currentPartialState","flushEnqueuedState","updater","nextState","l","partial","partialState","call","createInstance","computedProps","componentDidCatch","getDerivedStateFromError","getDerivedStateFromProps","componentWillMount","UNSAFE_componentWillMount","child","childContextTypes","getChildContext","childContext","componentWillUnmount","_err","elt","clientRefVisitor","concat","values","flat","Infinity","REACT_INTERNALS","__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","ReactCurrentDispatcher","getReactCurrentDispatcher","H","injectReactCurrentDispatcher","newDispatcher","SHOULD_YIELD","setImmediate","YIELD_AFTER_MS","mountClientReference","mountClassComponent","mountFunctionComponent","visitElement","fragmentElement","providerElement","_context","consumerElement","ref$1","children$1","lazyElement","mountLazyComponent","memoElement","ref$2","type$3","refElement","ref$3","el","userElement","props$1","visitLoop","traversalChildren","traversalMap","traversalStore","traversalErrorFrame","prevDispatcher","start","Date","now","shift","pop","unshift","makeYieldFrame","visit","hasYielded","updateClassComponent","updateFunctionComponent","updateLazyComponent","updateClientReference","flushFrames","defaultVisitor","runningPrepassCount","globalThis","__ssrPrepassEnv","renderPrepass","finally"],"mappings":"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"}