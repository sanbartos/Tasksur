{"version":3,"file":"index.esm.js","sources":["../../src/registerFunction.ts"],"sourcesContent":["import { Nullish } from \"./type-utils\";\n\nconst root = globalThis as any;\n\n/**\n * Context that we pass back to control functions.\n */\nexport type ControlContext<P> = [\n  /**\n   * props\n   */\n  Partial<P>,\n  /**\n   * context data\n   */\n  any\n];\n\n/**\n * Config option that takes the context (e.g., props) of the function call\n * to dynamically set its value.\n */\nexport type ContextDependentConfig<P, R> = (...args: ControlContext<P>) => R;\n\nexport interface BaseParam {\n  name: string;\n  description?: string;\n  isOptional?: boolean;\n  isRestParameter?: boolean;\n}\n\nexport interface ChoiceTypeBase<P, T> extends BaseParam {\n  type: \"choice\";\n  options:\n    | T[]\n    | {\n        label: string;\n        value: T;\n      }[]\n    | ContextDependentConfig<\n        P,\n        | T[]\n        | {\n            label: string;\n            value: T;\n          }[]\n      >;\n  allowSearch?: boolean;\n  filterOption?: boolean;\n  onSearch?: ContextDependentConfig<P, ((value: string) => void) | undefined>;\n}\n\nexport interface SingleChoiceType<P, T> extends ChoiceTypeBase<P, T> {\n  multiSelect?: false;\n}\n\nexport interface MultiChoiceType<P, T> extends ChoiceTypeBase<P, T[]> {\n  multiSelect: true;\n}\n\nexport interface CustomChoiceType<P, T> extends ChoiceTypeBase<P, T | T[]> {\n  multiSelect: ContextDependentConfig<P, boolean>;\n}\n\nexport type ChoiceType<P, T> =\n  | SingleChoiceType<P, T>\n  | MultiChoiceType<P, T>\n  | CustomChoiceType<P, T>;\n\nexport interface PlainStringType<T extends Nullish<string> = string>\n  extends BaseParam {\n  type: \"string\" | `'${T}'`;\n}\n\nexport type StringType<P, T extends Nullish<string> = string> =\n  | \"string\"\n  | PlainStringType<T>\n  | ChoiceType<P, T>\n  | AnyType;\n\nexport interface PlainNumberType<T extends Nullish<number> = number>\n  extends BaseParam {\n  type: \"number\" | `${number extends T ? number : T}`;\n}\n\nexport type NumberType<P, T extends Nullish<number> = number> =\n  | PlainNumberType<T>\n  | ChoiceType<P, T>\n  | AnyType;\n\nexport interface PlainBooleanType<T extends Nullish<boolean> = boolean>\n  extends BaseParam {\n  type: \"boolean\" | `${boolean extends T ? boolean : T}`;\n}\n\nexport type BooleanType<P, T extends Nullish<boolean> = boolean> =\n  | PlainBooleanType<T>\n  | ChoiceType<P, T>\n  | AnyType;\n\nexport type GraphQLValue = {\n  query: string;\n  variables?: Record<string, any>;\n};\n\nexport interface GraphQLType<P> extends BaseParam {\n  type: \"code\";\n  lang: \"graphql\";\n  endpoint: string | ContextDependentConfig<P, string>;\n  method?: string | ContextDependentConfig<P, string>;\n  headers?: object | ContextDependentConfig<P, object>;\n}\n\nexport interface PlainNullType extends BaseParam {\n  type: \"null\";\n}\nexport type NullType = PlainNullType | AnyType;\n\nexport interface PlainUndefinedType extends BaseParam {\n  type: \"undefined\";\n}\nexport type UndefinedType = PlainUndefinedType | AnyType;\n\nexport interface PlainArrayType extends BaseParam {\n  type: \"array\";\n}\nexport type ArrayType = PlainArrayType | AnyType;\n\nexport interface PlainObjectType extends BaseParam {\n  type: \"object\";\n}\nexport type ObjectType = PlainObjectType | AnyType;\n\nexport interface PlainAnyType extends BaseParam {\n  type: \"any\";\n}\nexport type AnyType = PlainAnyType;\n\nexport interface PlainVoidType extends BaseParam {\n  type: \"void\";\n}\nexport type VoidType = PlainVoidType | AnyType;\n\ntype IsAny<T> = 0 extends 1 & T ? true : false;\n\ntype CommonType<P, T> = T extends GraphQLValue\n  ? GraphQLType<P>\n  : T extends null\n  ? NullType\n  : T extends undefined\n  ? UndefinedType\n  : T extends Array<any>\n  ? ArrayType\n  : T extends object\n  ? ObjectType\n  : AnyType;\n\ntype AnyTyping<P, T> = T extends string\n  ? StringType<P, T>\n  : T extends number\n  ? NumberType<P, T>\n  : T extends boolean\n  ? BooleanType<P, T>\n  : CommonType<P, T>;\n\nexport type RestrictedType<P, T> = IsAny<T> extends true\n  ? AnyTyping<P, T>\n  : [T] extends [Nullish<string>]\n  ? StringType<P, T>\n  : [T] extends [Nullish<number>]\n  ? NumberType<P, T>\n  : [T] extends [Nullish<boolean>]\n  ? BooleanType<P, T>\n  : CommonType<P, T>;\n\nexport type ParamType<P, T> = RestrictedType<P, T>;\n\nexport type RequiredParam<P, T> = ParamType<P, T> & {\n  isOptional?: false;\n  isRestParameter?: false;\n};\n\nexport type OptionalParam<P, T> = ParamType<P, T> & {\n  isRestParameter?: false;\n};\n\nexport type RestParam<P, T> = ParamType<P, T> & {\n  isOptional?: false;\n  isRestParameter: true;\n};\n\n// https://stackoverflow.com/questions/70684030/remove-all-optional-items-from-a-tuple-type\ntype RequiredParams<\n  T extends any[],\n  U extends any[] = []\n> = Partial<T> extends T\n  ? U\n  : T extends [infer F, ...infer R]\n  ? RequiredParams<R, [...U, F]>\n  : U;\n\ntype OptionalParams<T extends any[]> = T extends [\n  ...RequiredParams<T>,\n  ...infer R\n]\n  ? [...R]\n  : [];\n\ntype HandleRequiredParams<P, R extends any[]> = R extends [infer H, ...infer T]\n  ? [string | RequiredParam<P, H>, ...HandleRequiredParams<P, T>]\n  : [];\n\ntype HandleOptionalParams<P, R extends any[]> = R extends [infer H, ...infer T]\n  ?\n      | []\n      | [\n          string | OptionalParam<P, H | undefined>,\n          ...HandleOptionalParams<P, T>\n        ]\n  : R extends []\n  ? []\n  : R extends Array<infer T>\n  ? [] | [RestParam<P, T[]>]\n  : [];\n\nexport type HandleParams<P extends any[]> = [\n  ...HandleRequiredParams<P, RequiredParams<P>>,\n  ...HandleOptionalParams<P, Required<OptionalParams<P>>>\n];\n\nexport type HandleReturnType<P, T> = VoidType | ParamType<P, T>;\n\nexport interface CustomFunctionMeta<F extends (...args: any[]) => any> {\n  /**\n   * The javascript name of the function. Notice it must be unique across all\n   * other functions and function namespaces. If two functions have the same\n   * name, they should be registered with different `meta.namespace`.\n   */\n  name: string;\n  /**\n   * A namespace for organizing groups of functions. It's also used to handle\n   * function name collisions. If a function has a namespace, it will be used\n   * whenever accessing the function.\n   */\n  namespace?: string;\n  /**\n   * A display name for the function. It will be shown only in studio.\n   */\n  displayName?: string;\n  /**\n   * Documentation for the registered function.\n   */\n  description?: string;\n  /**\n   * An array containing the list of parameters names the function takes.\n   * Optionally they can also be registered with the expected param types.\n   */\n  params?: HandleParams<Parameters<F>>;\n  /**\n   * Return value information.\n   */\n  returnValue?: {\n    /**\n     * The function return type.\n     */\n    type?: HandleReturnType<Parameters<F>, ReturnType<F>>;\n    /**\n     * The function return value description.\n     */\n    description?: string;\n  };\n  /**\n   * Typescript function declaration. If specified, it ignores the types\n   * provided by `params` and `returnValue`.\n   */\n  typescriptDeclaration?: string;\n\n  /**\n   * Whether this function can be used as a query in the editor.\n   */\n  isQuery?: boolean;\n  /**\n   * The path to be used when importing the function in the generated code.\n   * It can be the name of the package that contains the function, or the path\n   * to the file in the project (relative to the root directory).\n   */\n  importPath: string;\n  /**\n   * Whether the function is the default export from that path. Optional: if\n   * not specified, it's considered `false`.\n   */\n  isDefaultExport?: boolean;\n\n  /**\n   * A function that takes the function arguments and returns a data key\n   * and a fetcher function.\n   * The data key is used to cache the result of the fetcher, and should only\n   * include the arguments that are used to fetch the data.\n   * The result of the fetcher will be used as the context of the function\n   * in studio and should return a promise.\n   */\n  fnContext?: (...args: Partial<Parameters<F>>) => {\n    dataKey: string;\n    fetcher: () => Promise<any>;\n  };\n}\n\nexport interface CustomFunctionRegistration {\n  function: (...args: any[]) => any;\n  meta: CustomFunctionMeta<any>;\n}\n\ndeclare global {\n  interface Window {\n    __PlasmicFunctionsRegistry: CustomFunctionRegistration[];\n  }\n}\n\nif (root.__PlasmicFunctionsRegistry == null) {\n  root.__PlasmicFunctionsRegistry = [];\n}\n\nexport default function registerFunction<F extends (...args: any[]) => any>(\n  fn: F,\n  meta: CustomFunctionMeta<F>\n) {\n  // Check for duplicates\n  if (\n    root.__PlasmicFunctionsRegistry.some(\n      (r: CustomFunctionRegistration) =>\n        r.function === fn &&\n        r.meta.name === meta.name &&\n        r.meta.namespace == meta.namespace\n    )\n  ) {\n    return;\n  }\n  root.__PlasmicFunctionsRegistry.push({ function: fn, meta });\n}\n"],"names":[],"mappings":";AAEA,IAAM,IAAI,GAAG,UAAiB,CAAC;AA4T/B,IAAI,IAAI,CAAC,0BAA0B,IAAI,IAAI,EAAE;AAC3C,IAAA,IAAI,CAAC,0BAA0B,GAAG,EAAE,CAAC;AACtC,CAAA;AAEa,SAAU,gBAAgB,CACtC,EAAK,EACL,IAA2B,EAAA;;AAG3B,IAAA,IACE,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAClC,UAAC,CAA6B,EAAA;AAC5B,QAAA,OAAA,CAAC,CAAC,QAAQ,KAAK,EAAE;AACjB,YAAA,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI;AACzB,YAAA,CAAC,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,SAAS,CAAA;AAFlC,KAEkC,CACrC,EACD;QACA,OAAO;AACR,KAAA;AACD,IAAA,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE,IAAI,EAAA,IAAA,EAAE,CAAC,CAAC;AAC/D;;;;"}