var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/api.ts
import unfetch from "@plasmicapp/isomorphic-unfetch";
var VERSION = "10";
var isBrowser = typeof window !== "undefined" && window != null && typeof window.document !== "undefined";
function transformApiLoaderBundleOutput(bundle) {
  return __spreadProps(__spreadValues({}, bundle), {
    filteredIds: Object.fromEntries(bundle.projects.map((p) => [p.id, []]))
  });
}
var Api = class {
  constructor(opts) {
    this.opts = opts;
    this.lastResponse = void 0;
    var _a;
    this.host = (_a = opts.host) != null ? _a : "https://codegen.plasmic.app";
    this.fetch = (opts.nativeFetch && globalThis.fetch ? globalThis.fetch : unfetch).bind(globalThis);
  }
  fetchLoaderData(projectIds, opts) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      const { platform, preview } = opts;
      const query = new URLSearchParams([
        ["platform", platform != null ? platform : "react"],
        ...((_b = (_a = opts.platformOptions) == null ? void 0 : _a.nextjs) == null ? void 0 : _b.appDir) ? [["nextjsAppDir", "true"]] : [],
        ...projectIds.map((projectId) => ["projectId", projectId]),
        ...opts.browserOnly ? [["browserOnly", "true"]] : [],
        ...opts.i18nKeyScheme ? [["i18nKeyScheme", opts.i18nKeyScheme]] : [],
        ...opts.i18nTagPrefix ? [["i18nTagPrefix", opts.i18nTagPrefix]] : [],
        ...opts.skipHead ? [["skipHead", "true"]] : []
      ]).toString();
      const url = `${this.host}/api/v1/loader/code/${preview ? "preview" : "published"}?${query}`;
      const useLastReponse = (
        // We consider that manualRedirect is true by default, only by setting it to false
        // we disable it.
        !(this.opts.manualRedirect === false) && !preview && !isBrowser
      );
      if (useLastReponse) {
        const redirectResp = yield this.fetch(url, {
          method: "GET",
          headers: this.makeGetHeaders(),
          redirect: "manual"
        });
        if (redirectResp.status !== 301 && redirectResp.status !== 302) {
          const error = yield this.parseJsonResponse(redirectResp);
          throw new Error(
            `Error fetching loader data, a redirect was expected: ${(_d = (_c = error == null ? void 0 : error.error) == null ? void 0 : _c.message) != null ? _d : redirectResp.statusText}`
          );
        }
        const nextLocation = redirectResp.headers.get("location");
        if (!nextLocation) {
          throw new Error(
            `Error fetching loader data, a redirect was expected but no location header was found`
          );
        }
        if (((_e = this.lastResponse) == null ? void 0 : _e.key) === nextLocation) {
          return this.lastResponse.bundle;
        }
        const resp2 = yield this.fetch(`${this.host}${nextLocation}`, {
          method: "GET",
          headers: this.makeGetHeaders()
        });
        if (resp2.status >= 400) {
          const error = yield this.parseJsonResponse(resp2);
          throw new Error(
            `Error fetching loader data: ${(_g = (_f = error == null ? void 0 : error.error) == null ? void 0 : _f.message) != null ? _g : resp2.statusText}`
          );
        }
        const json2 = transformApiLoaderBundleOutput(
          yield this.parseJsonResponse(resp2)
        );
        this.lastResponse = {
          bundle: json2,
          key: nextLocation
        };
        return json2;
      }
      const resp = yield this.fetch(url, {
        method: "GET",
        headers: this.makeGetHeaders()
      });
      if (resp.status >= 400) {
        const error = yield this.parseJsonResponse(resp);
        throw new Error(
          `Error fetching loader data: ${(_i = (_h = error == null ? void 0 : error.error) == null ? void 0 : _h.message) != null ? _i : resp.statusText}`
        );
      }
      const json = yield this.parseJsonResponse(resp);
      return transformApiLoaderBundleOutput(json);
    });
  }
  parseJsonResponse(resp) {
    return __async(this, null, function* () {
      const text = yield resp.text();
      try {
        return JSON.parse(text);
      } catch (err) {
        throw new Error(
          `Error parsing JSON response: ${err}; status: ${resp.status}; response: ${text}`
        );
      }
    });
  }
  fetchHtmlData(opts) {
    return __async(this, null, function* () {
      const { projectId, component, embedHydrate, hydrate } = opts;
      const query = new URLSearchParams([
        ["projectId", projectId],
        ["component", component],
        ["embedHydrate", embedHydrate ? "1" : "0"],
        ["hydrate", hydrate ? "1" : "0"]
      ]).toString();
      const resp = yield this.fetch(`${this.host}/api/v1/loader/html?${query}`, {
        method: "GET",
        headers: this.makeGetHeaders()
      });
      const json = yield resp.json();
      return json;
    });
  }
  makeGetHeaders() {
    return __spreadValues({
      "x-plasmic-loader-version": VERSION
    }, this.makeAuthHeaders());
  }
  makeAuthHeaders() {
    const tokens = this.opts.projects.map((p) => `${p.id}:${p.token}`).join(",");
    return {
      "x-plasmic-api-project-tokens": tokens
    };
  }
  getChunksUrl(bundle, modules) {
    var _a;
    return `${this.host}/api/v1/loader/chunks?bundleKey=${encodeURIComponent(
      (_a = bundle.bundleKey) != null ? _a : "null"
    )}&fileName=${encodeURIComponent(
      modules.map((m) => m.fileName).sort().join(",")
    )}`;
  }
};

// src/fetcher.ts
var PlasmicModulesFetcher = class {
  constructor(opts) {
    this.opts = opts;
    this.curFetch = void 0;
    this.api = new Api({
      projects: opts.projects,
      host: opts.host,
      nativeFetch: opts.nativeFetch,
      manualRedirect: opts.manualRedirect
    });
  }
  getChunksUrl(bundle, modules) {
    return this.api.getChunksUrl(bundle, modules);
  }
  fetchAllData() {
    return __async(this, null, function* () {
      const bundle = yield this.getCachedOrFetch();
      this.cacheBundleInNodeServer(bundle);
      return bundle;
    });
  }
  getCachedOrFetch() {
    return __async(this, null, function* () {
      var _a;
      if (this.opts.cache) {
        const cachedData = yield this.opts.cache.get();
        if (cachedData) {
          return cachedData;
        }
      }
      if (this.curFetch) {
        return yield this.curFetch;
      }
      if (typeof process === "undefined" || !((_a = process.env) == null ? void 0 : _a.PLASMIC_QUIET)) {
        console.debug("Plasmic: doing a fresh fetch...");
      }
      const fetchPromise = this.doFetch();
      this.curFetch = fetchPromise;
      try {
        const data = yield fetchPromise;
        return data;
      } finally {
        if (this.curFetch === fetchPromise) {
          this.curFetch = void 0;
        }
      }
    });
  }
  doFetch() {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      const data = yield this.api.fetchLoaderData(
        this.opts.projects.map(
          (p) => p.version ? `${p.id}@${p.version}` : p.id
        ),
        {
          platform: this.opts.platform,
          platformOptions: this.opts.platformOptions,
          preview: this.opts.preview,
          i18nKeyScheme: (_b = (_a = this.opts.i18n) == null ? void 0 : _a.keyScheme) != null ? _b : this.opts.i18nKeyScheme,
          i18nTagPrefix: (_c = this.opts.i18n) == null ? void 0 : _c.tagPrefix,
          browserOnly: isBrowser,
          skipHead: this.opts.skipHead
        }
      );
      if (this.opts.cache) {
        yield this.opts.cache.set(data);
      }
      if (typeof process === "undefined" || !((_d = process.env) == null ? void 0 : _d.PLASMIC_QUIET)) {
        console.debug(
          `Plasmic: fetched designs for ${data.projects.map((p) => `"${p.name}" (${p.id}@${p.version})`).join(", ")}`
        );
      }
      return data;
    });
  }
  cacheBundleInNodeServer(bundle) {
    if (isBrowser) {
      return;
    }
    const global = globalThis;
    if (global.__PLASMIC_BUNDLES === void 0) {
      global.__PLASMIC_BUNDLES = {};
    }
    global.__PLASMIC_BUNDLES[getBundleKey(this.opts)] = bundle;
  }
};
function internal_getCachedBundleInNodeServer(opts) {
  var _a;
  if (isBrowser) {
    throw new Error(`Should not be consulting Node server cache in browser`);
  }
  const global = globalThis;
  return (_a = global.__PLASMIC_BUNDLES) == null ? void 0 : _a[getBundleKey(opts)];
}
function getBundleKey({
  host,
  platform,
  i18nKeyScheme,
  preview,
  projects,
  skipHead
}) {
  return JSON.stringify({
    host,
    platform,
    i18nKeyScheme,
    preview,
    projects,
    skipHead
  });
}
export {
  Api,
  PlasmicModulesFetcher,
  internal_getCachedBundleInNodeServer
};
//# sourceMappingURL=index.esm.js.map
