{
  "version": 3,
  "sources": ["../src/index.ts", "../src/api.ts", "../src/fetcher.ts"],
  "sourcesContent": ["export type {\n  AssetModule,\n  CodeModule,\n  ComponentMeta,\n  ExperimentSlice,\n  FontMeta,\n  GlobalGroupMeta,\n  LoaderBundleOutput,\n  LoaderHtmlOutput,\n  PageMeta,\n  PageMetadata,\n  ProjectMeta,\n  SegmentSlice,\n  Split,\n} from \"./api\";\nexport { Api } from \"./api\";\nexport type { FetcherOptions, LoaderBundleCache } from \"./fetcher\";\nexport {\n  internal_getCachedBundleInNodeServer,\n  PlasmicModulesFetcher,\n} from \"./fetcher\";\n", "import unfetch from \"@plasmicapp/isomorphic-unfetch\";\n\nexport interface ComponentMeta {\n  id: string;\n  usedComponents: string[];\n  projectId: string;\n  name: string;\n  displayName: string;\n  cssFile: string;\n  path: string | undefined;\n  isPage: boolean;\n  plumeType?: string;\n  entry: string;\n  isCode: boolean;\n  isGlobalContextProvider: boolean;\n  pageMetadata?: PageMetadata;\n  metadata?: Record<string, string>;\n  serverQueriesExecFuncFileName?: string;\n}\n\nexport interface PageMeta extends ComponentMeta {\n  isPage: true;\n  path: string;\n  plumeType: never;\n  pageMetadata: PageMetadata;\n}\n\nexport interface PageMetadata {\n  path: string;\n  title?: string | null;\n  description?: string | null;\n  openGraphImageUrl?: string | null;\n  canonical?: string | null;\n}\n\nexport interface GlobalGroupMeta {\n  id: string;\n  projectId: string;\n  name: string;\n  type: string;\n  contextFile: string;\n  useName: string;\n}\n\nexport interface ProjectMeta {\n  id: string;\n  teamId?: string;\n  indirect?: boolean;\n  name: string;\n  version: string;\n  remoteFonts: FontMeta[];\n  globalContextsProviderFileName: string;\n}\n\nexport interface FontMeta {\n  url: string;\n}\n\ninterface GlobalVariantSplitContent {\n  type: \"global-variant\";\n  projectId: string;\n  group: string;\n  variant: string;\n}\n\ninterface Slice {\n  id: string;\n  contents: GlobalVariantSplitContent[];\n  externalId?: string;\n}\n\nexport interface ExperimentSlice extends Slice {\n  prob: number;\n}\n\nexport interface SegmentSlice extends Slice {\n  cond: any;\n}\n\ninterface BareSplit {\n  id: string;\n  projectId: string;\n  name: string;\n  externalId?: string;\n  description?: string;\n  pagesPaths: string[];\n}\n\nexport interface ExperimentSplit extends BareSplit {\n  type: \"experiment\";\n  slices: ExperimentSlice[];\n}\n\nexport interface SegmentSplit extends BareSplit {\n  type: \"segment\";\n  slices: SegmentSlice[];\n}\n\nexport type Split = ExperimentSplit | SegmentSplit;\n\ninterface ApiLoaderBundleOutput {\n  modules: {\n    browser: (CodeModule | AssetModule)[];\n    server: (CodeModule | AssetModule)[];\n  };\n  components: ComponentMeta[];\n  globalGroups: GlobalGroupMeta[];\n  projects: ProjectMeta[];\n  activeSplits: Split[];\n  bundleKey: string | null;\n  deferChunksByDefault: boolean;\n  disableRootLoadingBoundaryByDefault: boolean;\n}\n\nexport interface LoaderBundleOutput extends ApiLoaderBundleOutput {\n  // A map from project ID to the list of component IDs that are not included in the bundle\n  // this is used to know which components exist in the project, which allow us to properly\n  // handle bundle merging being aware of the deleted components.\n  filteredIds: Record<string, string[]>;\n}\n\nexport interface LoaderHtmlOutput {\n  html: string;\n}\n\nexport interface CodeModule {\n  fileName: string;\n  code: string;\n  imports: string[];\n  type: \"code\";\n}\n\nexport interface AssetModule {\n  fileName: string;\n  source: string;\n  type: \"asset\";\n}\n\nconst VERSION = \"10\";\n\nexport const isBrowser =\n  typeof window !== \"undefined\" &&\n  window != null &&\n  typeof window.document !== \"undefined\";\n\nexport function transformApiLoaderBundleOutput(\n  bundle: ApiLoaderBundleOutput\n): LoaderBundleOutput {\n  return {\n    ...bundle,\n    filteredIds: Object.fromEntries(bundle.projects.map((p) => [p.id, []])),\n  };\n}\n\nexport class Api {\n  private host: string;\n  private fetch: typeof globalThis.fetch;\n\n  private lastResponse:\n    | {\n        bundle: LoaderBundleOutput;\n        key: string;\n      }\n    | undefined = undefined;\n\n  constructor(\n    private opts: {\n      projects: { id: string; token: string }[];\n      host?: string;\n      nativeFetch?: boolean;\n      manualRedirect?: boolean;\n    }\n  ) {\n    this.host = opts.host ?? \"https://codegen.plasmic.app\";\n    this.fetch = (\n      opts.nativeFetch && globalThis.fetch ? globalThis.fetch : unfetch\n    ).bind(globalThis);\n  }\n\n  async fetchLoaderData(\n    projectIds: string[],\n    opts: {\n      platform?: \"react\" | \"nextjs\" | \"gatsby\";\n      platformOptions?: {\n        nextjs?: {\n          appDir: boolean;\n        };\n      };\n      preview?: boolean;\n      browserOnly?: boolean;\n      i18nKeyScheme?: \"content\" | \"hash\" | \"path\";\n      i18nTagPrefix?: string;\n      skipHead?: boolean;\n    }\n  ): Promise<LoaderBundleOutput> {\n    const { platform, preview } = opts;\n    const query = new URLSearchParams([\n      [\"platform\", platform ?? \"react\"],\n      ...(opts.platformOptions?.nextjs?.appDir\n        ? [[\"nextjsAppDir\", \"true\"]]\n        : []),\n      ...projectIds.map((projectId) => [\"projectId\", projectId]),\n      ...(opts.browserOnly ? [[\"browserOnly\", \"true\"]] : []),\n      ...(opts.i18nKeyScheme ? [[\"i18nKeyScheme\", opts.i18nKeyScheme]] : []),\n      ...(opts.i18nTagPrefix ? [[\"i18nTagPrefix\", opts.i18nTagPrefix]] : []),\n      ...(opts.skipHead ? [[\"skipHead\", \"true\"]] : []),\n    ]).toString();\n\n    const url = `${this.host}/api/v1/loader/code/${\n      preview ? \"preview\" : \"published\"\n    }?${query}`;\n\n    // We only expect a redirect when we're dealing with published mode, as there should be\n    // a stable set of versions to be used. As in browser, we could receive a opaque response\n    // with a redirect, we don't try to use last response in browser.\n    const useLastReponse =\n      // We consider that manualRedirect is true by default, only by setting it to false\n      // we disable it.\n      !(this.opts.manualRedirect === false) && !preview && !isBrowser;\n\n    if (useLastReponse) {\n      const redirectResp = await this.fetch(url, {\n        method: \"GET\",\n        headers: this.makeGetHeaders(),\n        redirect: \"manual\",\n      });\n\n      if (redirectResp.status !== 301 && redirectResp.status !== 302) {\n        const error = await this.parseJsonResponse(redirectResp);\n        throw new Error(\n          `Error fetching loader data, a redirect was expected: ${\n            error?.error?.message ?? redirectResp.statusText\n          }`\n        );\n      }\n\n      const nextLocation = redirectResp.headers.get(\"location\");\n      if (!nextLocation) {\n        throw new Error(\n          `Error fetching loader data, a redirect was expected but no location header was found`\n        );\n      }\n\n      if (this.lastResponse?.key === nextLocation) {\n        return this.lastResponse.bundle;\n      }\n\n      const resp = await this.fetch(`${this.host}${nextLocation}`, {\n        method: \"GET\",\n        headers: this.makeGetHeaders(),\n      });\n\n      if (resp.status >= 400) {\n        const error = await this.parseJsonResponse(resp);\n        throw new Error(\n          `Error fetching loader data: ${\n            error?.error?.message ?? resp.statusText\n          }`\n        );\n      }\n\n      const json = transformApiLoaderBundleOutput(\n        (await this.parseJsonResponse(resp)) as ApiLoaderBundleOutput\n      );\n      this.lastResponse = {\n        bundle: json,\n        key: nextLocation,\n      };\n\n      return json;\n    }\n\n    const resp = await this.fetch(url, {\n      method: \"GET\",\n      headers: this.makeGetHeaders(),\n    });\n    if (resp.status >= 400) {\n      const error = await this.parseJsonResponse(resp);\n      throw new Error(\n        `Error fetching loader data: ${\n          error?.error?.message ?? resp.statusText\n        }`\n      );\n    }\n    const json = await this.parseJsonResponse(resp);\n    return transformApiLoaderBundleOutput(json as ApiLoaderBundleOutput);\n  }\n\n  private async parseJsonResponse(resp: Response) {\n    const text = await resp.text();\n    try {\n      return JSON.parse(text);\n    } catch (err) {\n      throw new Error(\n        `Error parsing JSON response: ${err}; status: ${resp.status}; response: ${text}`\n      );\n    }\n  }\n\n  async fetchHtmlData(opts: {\n    projectId: string;\n    component: string;\n    hydrate?: boolean;\n    embedHydrate?: boolean;\n  }) {\n    const { projectId, component, embedHydrate, hydrate } = opts;\n    const query = new URLSearchParams([\n      [\"projectId\", projectId],\n      [\"component\", component],\n      [\"embedHydrate\", embedHydrate ? \"1\" : \"0\"],\n      [\"hydrate\", hydrate ? \"1\" : \"0\"],\n    ]).toString();\n    const resp = await this.fetch(`${this.host}/api/v1/loader/html?${query}`, {\n      method: \"GET\",\n      headers: this.makeGetHeaders(),\n    });\n    const json = await resp.json();\n    return json as LoaderHtmlOutput;\n  }\n\n  private makeGetHeaders() {\n    return {\n      \"x-plasmic-loader-version\": VERSION,\n      ...this.makeAuthHeaders(),\n    };\n  }\n\n  private makeAuthHeaders() {\n    const tokens = this.opts.projects\n      .map((p) => `${p.id}:${p.token}`)\n      .join(\",\");\n    return {\n      \"x-plasmic-api-project-tokens\": tokens,\n    };\n  }\n\n  getChunksUrl(bundle: LoaderBundleOutput, modules: CodeModule[]) {\n    return `${this.host}/api/v1/loader/chunks?bundleKey=${encodeURIComponent(\n      bundle.bundleKey ?? \"null\"\n    )}&fileName=${encodeURIComponent(\n      modules\n        .map((m) => m.fileName)\n        .sort()\n        .join(\",\")\n    )}`;\n  }\n}\n", "import { Api, CodeModule, isBrowser, LoaderBundleOutput } from \"./api\";\n\nexport interface FetcherOptions {\n  projects: {\n    id: string;\n    version?: string;\n    token: string;\n  }[];\n  cache?: LoaderBundleCache;\n  platform?: \"react\" | \"nextjs\" | \"gatsby\";\n  platformOptions?: {\n    nextjs?: {\n      appDir: boolean;\n    };\n  };\n  preview?: boolean;\n  host?: string;\n  /**\n   * @deprecated use i18n.keyScheme instead\n   */\n  i18nKeyScheme?: \"content\" | \"hash\" | \"path\";\n  i18n?: {\n    keyScheme: \"content\" | \"hash\" | \"path\";\n    tagPrefix?: string;\n  };\n  skipHead?: boolean;\n  nativeFetch?: boolean;\n  manualRedirect?: boolean;\n}\n\nexport interface LoaderBundleCache {\n  set: (data: LoaderBundleOutput) => Promise<void>;\n  get: () => Promise<LoaderBundleOutput>;\n}\n\nexport class PlasmicModulesFetcher {\n  private api: Api;\n  private curFetch: Promise<LoaderBundleOutput> | undefined = undefined;\n  constructor(private opts: FetcherOptions) {\n    this.api = new Api({\n      projects: opts.projects,\n      host: opts.host,\n      nativeFetch: opts.nativeFetch,\n      manualRedirect: opts.manualRedirect,\n    });\n  }\n\n  getChunksUrl(bundle: LoaderBundleOutput, modules: CodeModule[]) {\n    return this.api.getChunksUrl(bundle, modules);\n  }\n\n  async fetchAllData() {\n    // getCachedOrFetched uses a cache defined by the user.\n    const bundle = await this.getCachedOrFetch();\n\n    // For React Server Components (Next.js 13+),\n    // we need to pass server modules in LoaderBundleOutput from Server Components to Client Components.\n    // We don't want to pass them via normal page props because that will be serialized to the browser.\n    // Instead, we pass the bundle (including the server modules) via the Node `global` variable.\n    //\n    // cacheBundleInNodeServer caches a bundle in the Node server process.\n    this.cacheBundleInNodeServer(bundle);\n\n    return bundle;\n  }\n\n  private async getCachedOrFetch() {\n    if (this.opts.cache) {\n      const cachedData = await this.opts.cache.get();\n      if (cachedData) {\n        return cachedData;\n      }\n    }\n    if (this.curFetch) {\n      return await this.curFetch;\n    }\n    if (typeof process === \"undefined\" || !process.env?.PLASMIC_QUIET) {\n      console.debug(\"Plasmic: doing a fresh fetch...\");\n    }\n    const fetchPromise = this.doFetch();\n    this.curFetch = fetchPromise;\n    try {\n      const data = await fetchPromise;\n      return data;\n    } finally {\n      // Reset this.curFetch only if it still holds the original fetch promise\n      if (this.curFetch === fetchPromise) {\n        this.curFetch = undefined;\n      }\n    }\n  }\n\n  private async doFetch() {\n    const data = await this.api.fetchLoaderData(\n      this.opts.projects.map((p) =>\n        p.version ? `${p.id}@${p.version}` : p.id\n      ),\n      {\n        platform: this.opts.platform,\n        platformOptions: this.opts.platformOptions,\n        preview: this.opts.preview,\n        i18nKeyScheme: this.opts.i18n?.keyScheme ?? this.opts.i18nKeyScheme,\n        i18nTagPrefix: this.opts.i18n?.tagPrefix,\n        browserOnly: isBrowser,\n        skipHead: this.opts.skipHead,\n      }\n    );\n    if (this.opts.cache) {\n      await this.opts.cache.set(data);\n    }\n    if (typeof process === \"undefined\" || !process.env?.PLASMIC_QUIET) {\n      console.debug(\n        `Plasmic: fetched designs for ${data.projects\n          .map((p) => `\"${p.name}\" (${p.id}@${p.version})`)\n          .join(\", \")}`\n      );\n    }\n    return data;\n  }\n\n  private cacheBundleInNodeServer(bundle: LoaderBundleOutput) {\n    if (isBrowser) {\n      return;\n    }\n\n    const global = globalThis as GlobalWithBundles;\n    if (global.__PLASMIC_BUNDLES === undefined) {\n      global.__PLASMIC_BUNDLES = {};\n    }\n    global.__PLASMIC_BUNDLES[getBundleKey(this.opts)] = bundle;\n  }\n}\n\nexport function internal_getCachedBundleInNodeServer(\n  opts: FetcherOptions\n): LoaderBundleOutput | undefined {\n  if (isBrowser) {\n    throw new Error(`Should not be consulting Node server cache in browser`);\n  }\n\n  const global = globalThis as GlobalWithBundles;\n  return global.__PLASMIC_BUNDLES?.[getBundleKey(opts)];\n}\n\nfunction getBundleKey({\n  host,\n  platform,\n  i18nKeyScheme,\n  preview,\n  projects,\n  skipHead,\n}: FetcherOptions) {\n  return JSON.stringify({\n    host,\n    platform,\n    i18nKeyScheme,\n    preview,\n    projects,\n    skipHead,\n  });\n}\n\ninterface GlobalWithBundles {\n  __PLASMIC_BUNDLES?: { [bundleKey: string]: LoaderBundleOutput };\n}\n"],
  "mappings": "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",
  "names": ["unfetch", "resp", "json"]
}
