var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
import { Api, PlasmicModulesFetcher } from "@plasmicapp/loader-fetcher";

// src/deps-graph.ts
var DepsGraph = class {
  constructor(bundle, browserBuild) {
    this.bundle = bundle;
    this.browserBuild = browserBuild;
    this.dependsOn = {};
    this.dependedBy = {};
    this.rebuildGraph();
  }
  getTransitiveDependers(name2) {
    return this.transitiveCrawl(name2, this.dependedBy);
  }
  getTransitiveDeps(name2) {
    if (!(name2 in this.dependsOn)) {
      return [];
    }
    return this.transitiveCrawl(name2, this.dependsOn);
  }
  transitiveCrawl(name2, edges) {
    const deps = /* @__PURE__ */ new Set();
    const crawl = (dep2) => {
      var _a;
      if (deps.has(dep2)) {
        return;
      }
      deps.add(dep2);
      for (const subdep of (_a = edges[dep2]) != null ? _a : []) {
        crawl(subdep);
      }
    };
    for (const dep2 of edges[name2]) {
      crawl(dep2);
    }
    return Array.from(deps);
  }
  rebuildGraph() {
    this.dependedBy = {};
    this.dependsOn = {};
    for (const mod of this.browserBuild ? this.bundle.modules.browser : this.bundle.modules.server) {
      if (mod.type === "code") {
        for (const imported of mod.imports) {
          if (!(mod.fileName in this.dependsOn)) {
            this.dependsOn[mod.fileName] = [imported];
          } else {
            this.dependsOn[mod.fileName].push(imported);
          }
          if (!(imported in this.dependedBy)) {
            this.dependedBy[imported] = [mod.fileName];
          } else {
            this.dependedBy[imported].push(mod.fileName);
          }
        }
      }
    }
  }
};

// src/bundles.ts
function getBundleSubset(bundle, names, opts2) {
  var _a, _b;
  const namesSet = new Set(names);
  const target = (_a = opts2 == null ? void 0 : opts2.target) != null ? _a : "browser";
  const forBrowser = target === "browser";
  const graph = new DepsGraph(bundle, forBrowser);
  const deps = new Set(names.flatMap((name2) => graph.getTransitiveDeps(name2)));
  const isSubModule = (fileName) => deps.has(fileName) || namesSet.has(fileName);
  const modules = bundle.modules[target];
  const filteredModules = modules.filter((mod) => isSubModule(mod.fileName));
  const filteredComponents = bundle.components.filter(
    (c) => isSubModule(c.entry)
  );
  const filteredComponentsIds = new Set(filteredComponents.map((c) => c.id));
  const filteredIds = Object.fromEntries(
    Object.entries(bundle.filteredIds).map(([k, v]) => [k, [...v]])
  );
  bundle.components.filter((c) => !filteredComponentsIds.has(c.id)).forEach((component) => {
    var _a2;
    filteredIds[component.projectId] = (_a2 = filteredIds[component.projectId]) != null ? _a2 : [];
    if (!filteredIds[component.projectId].includes(component.id)) {
      filteredIds[component.projectId].push(component.id);
    }
  });
  return {
    modules: {
      browser: forBrowser ? filteredModules : [],
      server: forBrowser ? [] : filteredModules
    },
    components: filteredComponents,
    globalGroups: bundle.globalGroups,
    projects: bundle.projects,
    activeSplits: bundle.activeSplits,
    bundleKey: (_b = bundle.bundleKey) != null ? _b : null,
    deferChunksByDefault: bundle.deferChunksByDefault,
    disableRootLoadingBoundaryByDefault: bundle.disableRootLoadingBoundaryByDefault,
    filteredIds
  };
}

// src/registry.ts
var isBrowser = typeof window !== "undefined" && window != null && typeof window.document !== "undefined";
function isModuleBundlePromiseSet(name2) {
  return globalThis.__PlasmicBundlePromises && !!globalThis.__PlasmicBundlePromises[name2] && !!globalThis.__PlasmicBundlePromises[name2].then;
}
var Registry = class {
  constructor() {
    this.loadedModules = {};
    this.registeredModules = {};
    this.modules = {};
  }
  register(name2, module) {
    this.registeredModules[name2] = module;
  }
  isEmpty() {
    return Object.keys(this.loadedModules).length === 0;
  }
  clear() {
    this.loadedModules = {};
  }
  getRegisteredModule(name2) {
    return this.registeredModules[name2];
  }
  hasModule(name2, opts2 = {}) {
    if (name2 in this.registeredModules && !opts2.forceOriginal) {
      return true;
    }
    if (name2 in this.modules) {
      return true;
    }
    if (globalThis.__PLASMIC_CHUNKS && !!globalThis.__PLASMIC_CHUNKS[name2]) {
      return true;
    }
    if (isModuleBundlePromiseSet(name2)) {
      return true;
    }
    return false;
  }
  load(name, opts = {}) {
    if (name in this.registeredModules && !opts.forceOriginal) {
      return this.registeredModules[name];
    }
    if (name in this.loadedModules) {
      return this.loadedModules[name];
    }
    if (!this.modules[name] && globalThis.__PLASMIC_CHUNKS && !!globalThis.__PLASMIC_CHUNKS[name]) {
      this.modules[name] = globalThis.__PLASMIC_CHUNKS[name];
    }
    if (!this.modules[name] && isModuleBundlePromiseSet(name)) {
      throw globalThis.__PlasmicBundlePromises[name];
    }
    if (!(name in this.modules)) {
      throw new Error(`Unknown module ${name}`);
    }
    const code = this.modules[name];
    const requireFn = isBrowser ? (dep2) => {
      const normalizedDep = resolvePath(dep2, name);
      return this.load(normalizedDep);
    } : (dep) => {
      try {
        const normalizedDep = resolvePath(dep, name);
        return this.load(normalizedDep);
      } catch (err) {
        try {
          return eval("require")(dep);
        } catch (e) {
          throw err;
        }
      }
    };
    let func;
    try {
      func = new Function("require", "exports", code);
    } catch (err2) {
      throw new Error(`PLASMIC: Failed to create function for ${name}: ${err2}`);
    }
    const exports = {};
    this.loadedModules[name] = exports;
    try {
      func(requireFn, exports);
    } catch (err2) {
      delete this.loadedModules[name];
      if (!(err2 instanceof Error) && !!err2 && !!err2.then) {
        throw err2;
      }
      throw new Error(`PLASMIC: Failed to load ${name}: ${err2}`);
    }
    return exports;
  }
  updateModules(bundle) {
    let updated = false;
    for (const mod of isBrowser ? bundle.modules.browser : bundle.modules.server) {
      if (mod.type === "code" && !!mod.code && mod.code !== this.modules[mod.fileName]) {
        this.modules[mod.fileName] = mod.code;
        if (!globalThis.__PLASMIC_CHUNKS) {
          globalThis.__PLASMIC_CHUNKS = {};
        }
        globalThis.__PLASMIC_CHUNKS[mod.fileName] = mod.code;
        updated = true;
      }
    }
    if (updated) {
      this.clear();
    }
  }
};
function resolvePath(path, from) {
  const fromParts = from.split("/");
  const pathParts = path.split("/");
  if (pathParts.length === 0) {
    return path;
  }
  if (pathParts[0] === ".") {
    return [
      ...fromParts.slice(0, fromParts.length - 1),
      ...pathParts.slice(1)
    ].join("/");
  } else if (pathParts[0] === "..") {
    let count = 0;
    for (const part of pathParts) {
      if (part === "..") {
        count += 1;
      } else {
        break;
      }
    }
    return [
      ...fromParts.slice(0, fromParts.length - count - 1),
      ...pathParts.slice(count)
    ].join("/");
  } else {
    return path;
  }
}

// src/tracker/index.ts
import unfetch from "@plasmicapp/isomorphic-unfetch";

// src/tracker/utils.ts
var isBrowser2 = typeof window !== "undefined" && window != null && typeof window.document !== "undefined";
function getPlasmicCookieValues() {
  if (!isBrowser2) {
    return {};
  }
  return Object.fromEntries(
    document.cookie.split("; ").filter((cookie) => cookie.includes("plasmic:")).map((cookie) => cookie.split("=")).map(([key, value]) => [key.split(":")[1], value])
  );
}
function getVariationCookieValues() {
  const cookies = getPlasmicCookieValues();
  return Object.fromEntries(
    Object.keys(cookies).map((key) => [key.split(".")[1], cookies[key]]).filter((val) => !!val[0])
  );
}
function getDistinctId() {
  if (!isBrowser2) {
    return "LOADER-SERVER";
  }
  return "LOADER-CLIENT";
}
function getCampaignParams() {
  const { location } = window;
  const params = {};
  try {
    const url = new URL(location.href);
    const CAMPAIGN_KEYWORDS = [
      "utm_source",
      "utm_medium",
      "utm_campaign",
      "utm_content",
      "utm_term",
      "gclid"
    ];
    CAMPAIGN_KEYWORDS.forEach((keyword) => {
      const value = url.searchParams.get(keyword);
      if (value) {
        params[keyword] = value;
      }
    });
  } catch (err2) {
  }
  return params;
}
function getLocationMeta() {
  const { location } = window;
  const { referrer } = document;
  return __spreadValues({
    url: location.href,
    host: location.host,
    pathname: location.pathname,
    referrer
  }, getCampaignParams());
}
function getScreenMeta() {
  const { screen } = window;
  return {
    screen_height: screen.height,
    screen_width: screen.width,
    viewport_height: window.innerHeight,
    viewport_width: window.innerWidth
  };
}
function getOS(userAgent) {
  if (/Windows/i.test(userAgent)) {
    if (/Phone/.test(userAgent) || /WPDesktop/.test(userAgent)) {
      return "Windows Phone";
    }
    return "Windows";
  } else if (/(iPhone|iPad|iPod)/.test(userAgent)) {
    return "iOS";
  } else if (/Android/.test(userAgent)) {
    return "Android";
  } else if (/(BlackBerry|PlayBook|BB10)/i.test(userAgent)) {
    return "BlackBerry";
  } else if (/Mac/i.test(userAgent)) {
    return "Mac OS X";
  } else if (/Linux/.test(userAgent)) {
    return "Linux";
  } else if (/CrOS/.test(userAgent)) {
    return "Chrome OS";
  } else {
    return "";
  }
}
function getDeviceInfo(userAgent) {
  const PATTERNS = [
    {
      device: "iPhone",
      patterns: [/iPhone/]
    },
    {
      device: "iPad",
      patterns: [/iPad/]
    },
    {
      device: "iPod Touch",
      patterns: [/iPod/]
    },
    {
      device: "Windows Phone",
      patterns: [/Windows Phone/i, /WPDesktop/]
    },
    {
      device: "Android",
      patterns: [/Android/]
    }
  ];
  const match = PATTERNS.find(
    (pattern) => pattern.patterns.some((expr) => expr.test(userAgent))
  );
  const device = match == null ? void 0 : match.device;
  return {
    device: device != null ? device : "",
    deviceType: device ? "Mobile" : "Desktop",
    os: getOS(userAgent)
  };
}
function getUserAgentMeta() {
  const { navigator } = window;
  const { userAgent } = navigator;
  return __spreadValues({}, getDeviceInfo(userAgent));
}
function getWindowMeta() {
  if (!isBrowser2) {
    return {};
  }
  return __spreadValues(__spreadValues(__spreadValues({}, getLocationMeta()), getScreenMeta()), getUserAgentMeta());
}
var isProduction = process.env.NODE_ENV === "production";
function getEnvMeta() {
  return {
    isBrowser: isBrowser2,
    isProduction
  };
}
function rawSplitVariation(variation) {
  const rawVariations = {};
  Object.keys(variation).forEach((variationKey) => {
    const [, splitId] = variationKey.split(".");
    if (splitId) {
      rawVariations[splitId] = variation[variationKey];
    }
  });
  return rawVariations;
}
var POLL_TIME = 5e3;
function throttled(func2) {
  let timerId = void 0;
  return (param) => {
    if (timerId) {
      return;
    }
    if (isBrowser2) {
      timerId = window.requestAnimationFrame(() => {
        timerId = void 0;
        func2(param);
      });
    } else {
      timerId = setTimeout(() => {
        timerId = void 0;
        func2(param);
      }, POLL_TIME);
    }
  };
}

// src/tracker/index.ts
var API_ENDPOINT = "https://analytics.plasmic.app/capture";
var API_PUBLIC_KEY = "phc_BRvYTAoMoam9fDHfrIneF67KdtMJagLVVCM6ELNYd4n";
var TRACKER_VERSION = 4;
var PlasmicTracker = class {
  constructor(opts2) {
    this.opts = opts2;
    this.eventQueue = [];
    this.sendEvents = throttled((transport) => __async(this, null, function* () {
      if (this.eventQueue.length === 0) {
        return;
      }
      const events = [...this.eventQueue];
      this.eventQueue.length = 0;
      const body = {
        api_key: API_PUBLIC_KEY,
        batch: events
      };
      try {
        const stringBody = JSON.stringify(body);
        if (transport === "beacon") {
          window.navigator.sendBeacon(API_ENDPOINT, stringBody);
        } else {
          this.fetch(API_ENDPOINT, {
            method: "POST",
            headers: {
              Accept: "application/json"
            },
            body: stringBody
          }).then(() => {
          }).catch(() => {
          });
        }
      } catch (err2) {
      }
    }));
    this.fetch = (opts2.nativeFetch && globalThis.fetch ? globalThis.fetch : unfetch).bind(globalThis);
  }
  trackRender(opts2) {
    var _a, _b;
    this.enqueue({
      event: "$render",
      properties: __spreadValues(__spreadValues(__spreadValues({}, this.getProperties()), (_a = opts2 == null ? void 0 : opts2.renderCtx) != null ? _a : {}), rawSplitVariation((_b = opts2 == null ? void 0 : opts2.variation) != null ? _b : {}))
    });
  }
  trackFetch() {
    this.enqueue({
      event: "$fetch",
      properties: this.getProperties()
    });
  }
  trackConversion(value = 0) {
    this.enqueue({
      event: "$conversion",
      properties: __spreadProps(__spreadValues({}, this.getProperties()), {
        value
      })
    });
  }
  getProperties() {
    var _a;
    return __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
      distinct_id: getDistinctId()
    }, getWindowMeta()), getEnvMeta()), this.getContextMeta()), getVariationCookieValues()), {
      timestamp: (_a = Date.now()) != null ? _a : +/* @__PURE__ */ new Date(),
      trackerVersion: TRACKER_VERSION
    });
  }
  enqueue(event) {
    if (this.opts.__plasmicTrackerDisabled) {
      return;
    }
    this.eventQueue.push(event);
    this.sendEvents("fetch");
  }
  getContextMeta() {
    return {
      platform: this.opts.platform,
      preview: this.opts.preview,
      projectIds: this.opts.projectIds
    };
  }
};
export {
  Api,
  PlasmicModulesFetcher,
  PlasmicTracker,
  Registry,
  getBundleSubset
};
//# sourceMappingURL=index.esm.js.map
