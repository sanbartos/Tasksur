import { Api } from '@plasmicapp/loader-fetcher';
import { AssetModule } from '@plasmicapp/loader-fetcher';
import { CodeModule } from '@plasmicapp/loader-fetcher';
import { ComponentMeta } from '@plasmicapp/loader-fetcher';
import { ExperimentSlice } from '@plasmicapp/loader-fetcher';
import { FontMeta } from '@plasmicapp/loader-fetcher';
import { GlobalGroupMeta } from '@plasmicapp/loader-fetcher';
import { LoaderBundleCache } from '@plasmicapp/loader-fetcher';
import { LoaderBundleOutput } from '@plasmicapp/loader-fetcher';
import { LoaderHtmlOutput } from '@plasmicapp/loader-fetcher';
import { PageMeta } from '@plasmicapp/loader-fetcher';
import { PageMetadata } from '@plasmicapp/loader-fetcher';
import { PlasmicModulesFetcher } from '@plasmicapp/loader-fetcher';
import { ProjectMeta } from '@plasmicapp/loader-fetcher';
import { SegmentSlice } from '@plasmicapp/loader-fetcher';
import { Split } from '@plasmicapp/loader-fetcher';

export { Api }

export { AssetModule }

export { CodeModule }

export { ComponentMeta }

export { ExperimentSlice }

export { FontMeta }

/**
 * Get sub-bundle including only modules that are reachable from `names`.
 * @param opts.target by default, will target the browser modules. Can request
 *   the server modules instead.
 */
export declare function getBundleSubset(bundle: LoaderBundleOutput, names: string[], opts?: {
    target?: "browser" | "server";
}): LoaderBundleOutput;

export { GlobalGroupMeta }

export { LoaderBundleCache }

export { LoaderBundleOutput }

export { LoaderHtmlOutput }

export { PageMeta }

export { PageMetadata }

export { PlasmicModulesFetcher }

export declare class PlasmicTracker {
    private opts;
    private eventQueue;
    private fetch;
    constructor(opts: TrackerOptions);
    trackRender(opts?: TrackRenderOptions): void;
    trackFetch(): void;
    trackConversion(value?: number): void;
    private getProperties;
    private enqueue;
    private getContextMeta;
    private sendEvents;
}

export { ProjectMeta }

export declare class Registry {
    private loadedModules;
    private registeredModules;
    private modules;
    constructor();
    register(name: string, module: any): void;
    isEmpty(): boolean;
    clear(): void;
    getRegisteredModule(name: string): any;
    hasModule(name: string, opts?: {
        forceOriginal?: boolean;
    }): boolean;
    load(name: string, opts?: {
        forceOriginal?: boolean;
    }): any;
    updateModules(bundle: LoaderBundleOutput): void;
}

export { SegmentSlice }

export { Split }

declare interface TrackerOptions {
    projectIds: string[];
    host?: string;
    platform?: string;
    preview?: boolean;
    nativeFetch?: boolean;
}

declare interface TrackerRenderProperties {
    rootProjectId?: string;
    rootComponentId?: string;
    rootComponentName?: string;
    teamIds: string[];
    projectIds: string[];
}

export declare interface TrackRenderOptions {
    renderCtx?: TrackerRenderProperties;
    variation?: Record<string, string>;
}

export { }





