"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/react-server.ts
var react_server_exports = {};
__export(react_server_exports, {
  InternalPlasmicComponentLoader: () => InternalPrepassPlasmicLoader,
  PlasmicComponentLoader: () => PlasmicComponentLoader,
  __EXPERMIENTAL__extractPlasmicQueryData: () => extractPlasmicQueryData,
  convertBundlesToComponentRenderData: () => convertBundlesToComponentRenderData,
  initPlasmicLoader: () => initPlasmicLoader,
  matchesPagePath: () => matchesPagePath
});
module.exports = __toCommonJS(react_server_exports);
var import_server_only = require("server-only");

// src/loader-server.tsx
var import_loader_core3 = require("@plasmicapp/loader-core");
var import_react = __toESM(require("react"));
var import_react_dom = __toESM(require("react-dom"));
var jsxDevRuntime = __toESM(require("react/jsx-dev-runtime"));
var jsxRuntime = __toESM(require("react/jsx-runtime"));

// src/loader-shared.ts
var import_loader_core2 = require("@plasmicapp/loader-core");
var import_loader_fetcher = require("@plasmicapp/loader-fetcher");
var import_loader_splits = require("@plasmicapp/loader-splits");

// src/bundles.ts
var import_loader_core = require("@plasmicapp/loader-core");

// src/utils.tsx
var import_pascalcase = __toESM(require("pascalcase"));
var React = __toESM(require("react"));
var isBrowser = typeof window !== "undefined";
function isNameSpec(lookup) {
  return "name" in lookup;
}
function toFullLookup(lookup) {
  const namePart = typeof lookup === "string" ? lookup : lookup.name;
  const projectId = typeof lookup === "string" ? void 0 : lookup.projectId;
  const codeComponent = typeof lookup === "string" ? void 0 : lookup.isCode;
  if (codeComponent !== true && namePart.startsWith("/")) {
    return { path: normalizePath(namePart), projectId };
  } else {
    return {
      name: codeComponent ? namePart : normalizeName(namePart),
      rawName: namePart.trim(),
      projectId,
      isCode: codeComponent
    };
  }
}
function normalizePath(path) {
  return path.trim();
}
function normalizeName(name) {
  return (0, import_pascalcase.default)(name).trim();
}
function matchesPagePath(pattern, path) {
  const normalizedPattern = "/" + pattern.replace(/^\/|\/$/g, "");
  const normalizedPath = "/" + path.replace(/^\/|\/$/g, "");
  const regexString = normalizedPattern.replace(/\/\[\[\.\.\.([^\]^]+)]]/g, "(?:/([^]*))?").replace(/\/\[\.\.\.([^\]^]+)]/g, "/([^]*)").replace(/\[([^\]^]+)]/g, "([^/]+)").replace(/\//g, "\\/");
  const regex = new RegExp(`^/?${regexString}$`);
  const match = normalizedPath.match(regex);
  if (!match)
    return false;
  const slugNames = [...pattern.matchAll(/\[\.?\.?\.?([^[\]]+)]/g)].map(
    (m) => m[1]
  );
  const params = {};
  for (let i = 0; i < slugNames.length; i++) {
    const slugName = slugNames[i];
    const value = match[i + 1];
    if (pattern.includes(`[[...${slugName}]]`)) {
      params[slugName] = value ? value.split("/").filter(Boolean) : [];
    } else if (pattern.includes(`[...${slugName}]`)) {
      params[slugName] = value.split("/").filter(Boolean);
    } else if (value !== void 0) {
      params[slugName] = value;
    }
  }
  return { params };
}
function isDynamicPagePath(path) {
  return !!path.match(/\[[^/]*\]/);
}
function matchesCompMeta(lookup, meta) {
  if (lookup.projectId && meta.projectId !== lookup.projectId) {
    return false;
  }
  return isNameSpec(lookup) ? (lookup.name === meta.name || lookup.rawName === meta.name || lookup.rawName === meta.displayName) && (lookup.isCode == null || lookup.isCode === meta.isCode) : !!(meta.path && matchesPagePath(meta.path, lookup.path));
}
function getCompMetas(metas, lookup) {
  const full = toFullLookup(lookup);
  return metas.filter((meta) => matchesCompMeta(full, meta)).map(
    (meta) => {
      if (isNameSpec(full) || !meta.path) {
        return meta;
      }
      const match = matchesPagePath(meta.path, full.path);
      if (!match) {
        return meta;
      }
      return __spreadProps(__spreadValues({}, meta), { params: match.params });
    }
  ).sort(
    (meta1, meta2) => (
      // We sort the matched component metas by the number of path params, so
      // if there are two pages `/products/foo` and `/products/[slug]`,
      // the first one will have higher precedence.
      Array.from(Object.keys(meta1.params || {})).length - Array.from(Object.keys(meta2.params || {})).length
    )
  );
}
function getLookupSpecName(lookup) {
  if (typeof lookup === "string") {
    return lookup;
  } else if (lookup.projectId) {
    return `${lookup.name} (project ${lookup.projectId})`;
  } else {
    return lookup.name;
  }
}
function uniq(elements) {
  return Array.from(new Set(elements));
}
function intersect(a, b) {
  const setB = new Set(b);
  return a.filter((elt) => setB.has(elt));
}

// src/bundles.ts
function getUsedComps(allComponents, entryCompIds) {
  const q = [...entryCompIds];
  const seenIds = new Set(entryCompIds);
  const componentMetaById = new Map(
    allComponents.map((meta) => [meta.id, meta])
  );
  const usedComps = [];
  while (q.length > 0) {
    const [id] = q.splice(0, 1);
    const meta = componentMetaById.get(id);
    if (!meta) {
      continue;
    }
    usedComps.push(meta);
    meta.usedComponents.forEach((usedCompId) => {
      if (!seenIds.has(usedCompId)) {
        seenIds.add(usedCompId);
        q.push(usedCompId);
      }
    });
  }
  return usedComps;
}
function prepComponentData(bundle, compMetas, opts) {
  if (compMetas.length === 0) {
    return {
      entryCompMetas: bundle.components,
      bundle,
      remoteFontUrls: []
    };
  }
  const usedComps = getUsedComps(
    bundle.components,
    compMetas.map((compMeta) => compMeta.id)
  );
  const compPaths = usedComps.map((compMeta) => compMeta.entry);
  const subBundle = (0, import_loader_core.getBundleSubset)(
    bundle,
    [
      "entrypoint.css",
      ...compPaths,
      "root-provider.js",
      ...bundle.projects.map((x) => x.globalContextsProviderFileName).filter((x) => !!x),
      // We need to explicitly include global context provider components
      // to make sure they are kept in bundle.components. That's because
      // for esbuild, just the globalContextsProviderFileName is not enough,
      // because it will import a chunk that includes the global context
      // component, instead of importing that global context component's
      // entry file. And because nothing depends on the global context component's
      // entry file, we end up excluding the global context component from
      // bundle.components, which then makes its substitution not work.
      // Instead, we forcibly include it here (we'll definitely need it anyway!).
      ...bundle.components.filter((c) => c.isGlobalContextProvider).map((c) => c.entry),
      ...bundle.globalGroups.map((g) => g.contextFile)
    ],
    opts
  );
  const remoteFontUrls = [];
  subBundle.projects.forEach(
    (p) => remoteFontUrls.push(...p.remoteFonts.map((f) => f.url))
  );
  return {
    entryCompMetas: compMetas,
    bundle: subBundle,
    remoteFontUrls
  };
}
function mergeBundles(target, from) {
  var _a2, _b, _c, _d, _e, _f, _g;
  const existingProjects = new Set(target.projects.map((p) => p.id));
  const newProjects = from.projects.filter((p) => !existingProjects.has(p.id));
  if (newProjects.length > 0) {
    target = __spreadProps(__spreadValues({}, target), {
      projects: [...target.projects, ...newProjects]
    });
  }
  const existingCompIds = new Set(target.components.map((c) => c.id));
  function shouldIncludeComponentInBundle(c) {
    var _a3;
    if (existingCompIds.has(c.id)) {
      return false;
    }
    if (!existingProjects.has(c.projectId)) {
      return true;
    }
    const targetBundleFilteredIds = (_a3 = target.filteredIds[c.projectId]) != null ? _a3 : [];
    return targetBundleFilteredIds.includes(c.id);
  }
  const newCompMetas = from.components.filter(
    (m) => shouldIncludeComponentInBundle(m)
  );
  if (newCompMetas.length > 0) {
    target = __spreadProps(__spreadValues({}, target), {
      components: [...target.components, ...newCompMetas]
    });
    target.filteredIds = Object.fromEntries(
      Object.entries(target.filteredIds).map(([k, v]) => [k, [...v]])
    );
    from.projects.forEach((fromProject) => {
      var _a3, _b2;
      const projectId = fromProject.id;
      const fromBundleFilteredIds = (_a3 = from.filteredIds[projectId]) != null ? _a3 : [];
      if (!existingProjects.has(projectId)) {
        target.filteredIds[projectId] = [...fromBundleFilteredIds];
      } else {
        target.filteredIds[projectId] = intersect(
          (_b2 = target.filteredIds[projectId]) != null ? _b2 : [],
          fromBundleFilteredIds
        );
      }
    });
  }
  const existingModules = {
    browser: new Set(target.modules.browser.map((m) => m.fileName)),
    server: new Set(target.modules.server.map((m) => m.fileName))
  };
  const newModules = {
    browser: from.modules.browser.filter(
      (m) => !existingModules.browser.has(m.fileName)
    ),
    server: from.modules.server.filter(
      (m) => !existingModules.server.has(m.fileName)
    )
  };
  if (newModules.browser.length > 0 || newModules.server.length > 0) {
    target = __spreadProps(__spreadValues({}, target), {
      modules: {
        browser: [...target.modules.browser, ...newModules.browser],
        server: [...target.modules.server, ...newModules.server]
      }
    });
  }
  const existingGlobalIds = new Set(target.globalGroups.map((g) => g.id));
  const newGlobals = from.globalGroups.filter(
    (g) => !existingGlobalIds.has(g.id)
  );
  if (newGlobals.length > 0) {
    target = __spreadProps(__spreadValues({}, target), {
      globalGroups: [...target.globalGroups, ...newGlobals]
    });
  }
  const existingSplitIds = new Set(target.activeSplits.map((s) => s.id));
  const newSplits = (_a2 = from.activeSplits.filter(
    // Don't include splits belonging to projects already present
    // in the target bundle
    (s) => !existingSplitIds.has(s.id) && !existingProjects.has(s.projectId)
  )) != null ? _a2 : [];
  if (newSplits.length > 0) {
    target = __spreadProps(__spreadValues({}, target), {
      activeSplits: [...target.activeSplits, ...newSplits]
    });
  }
  target.bundleKey = (_c = (_b = target.bundleKey) != null ? _b : from.bundleKey) != null ? _c : null;
  target.deferChunksByDefault = (_e = (_d = target.deferChunksByDefault) != null ? _d : from.deferChunksByDefault) != null ? _e : false;
  target.disableRootLoadingBoundaryByDefault = (_g = (_f = target.disableRootLoadingBoundaryByDefault) != null ? _f : from.disableRootLoadingBoundaryByDefault) != null ? _g : false;
  return target;
}
var convertBundlesToComponentRenderData = (bundles, compMetas) => {
  if (bundles.length === 0) {
    return null;
  }
  const mergedBundles = bundles.reduce((prev, cur) => mergeBundles(prev, cur));
  return prepComponentData(mergedBundles, compMetas);
};

// src/component-lookup.ts
function getFirstCompMeta(metas, lookup) {
  const filtered = getCompMetas(metas, lookup);
  return filtered.length === 0 ? void 0 : filtered[0];
}
var ComponentLookup = class {
  constructor(bundle, registry) {
    this.bundle = bundle;
    this.registry = registry;
  }
  getComponentMeta(spec) {
    const compMeta = getFirstCompMeta(this.bundle.components, spec);
    return compMeta;
  }
  getComponent(spec, opts = {}) {
    const compMeta = getFirstCompMeta(this.bundle.components, spec);
    if (!compMeta) {
      throw new Error(`Component not found: ${spec}`);
    }
    const moduleName = compMeta.entry;
    if (!this.registry.hasModule(moduleName, opts)) {
      throw new Error(`Component not yet fetched: ${compMeta.name}`);
    }
    const entry = this.registry.load(moduleName, {
      forceOriginal: opts.forceOriginal
    });
    return !opts.forceOriginal && typeof (entry == null ? void 0 : entry.getPlasmicComponent) === "function" ? entry.getPlasmicComponent() : entry.default;
  }
  hasComponent(spec) {
    const compMeta = getFirstCompMeta(this.bundle.components, spec);
    if (compMeta) {
      return this.registry.hasModule(compMeta.entry);
    }
    return false;
  }
  getGlobalContexts() {
    const customGlobalMetas = this.bundle.globalGroups.filter(
      (m) => m.type === "global-user-defined"
    );
    return customGlobalMetas.map((meta) => ({
      meta,
      context: this.registry.load(meta.contextFile).default
    }));
  }
  getGlobalContextsProvider(spec) {
    const compMeta = getFirstCompMeta(this.bundle.components, spec);
    const projectMeta = compMeta ? this.bundle.projects.find((x) => x.id === compMeta.projectId) : void 0;
    if (!projectMeta || !projectMeta.globalContextsProviderFileName || !this.registry.hasModule(projectMeta.globalContextsProviderFileName)) {
      return void 0;
    }
    const entry = this.registry.load(
      projectMeta.globalContextsProviderFileName
    );
    return typeof (entry == null ? void 0 : entry.getPlasmicComponent) === "function" ? entry.getPlasmicComponent() : entry.default;
  }
  getRootProvider() {
    const entry = this.registry.load("root-provider.js");
    return entry.default;
  }
  getCss() {
    return this.bundle.modules.browser.filter(
      (mod) => mod.type === "asset" && mod.fileName.endsWith("css")
    );
  }
  getRemoteFonts() {
    return this.bundle.projects.flatMap((p) => p.remoteFonts);
  }
};

// src/variation.ts
function getPlasmicCookieValues() {
  return Object.fromEntries(
    document.cookie.split("; ").filter((cookie) => cookie.includes("plasmic:")).map((cookie) => cookie.split("=")).map(([key, value]) => [key.split(":")[1], value])
  );
}
function updatePlasmicCookieValue(key, value) {
  document.cookie = `plasmic:${key}=${value}`;
}
var getGlobalVariantsFromSplits = (splits, variation) => {
  const globalVariants = [];
  Object.keys(variation).map((variationKey) => {
    const [_type, splitId] = variationKey.split(".");
    const sliceId = variation[variationKey];
    const split = splits.find(
      (s) => s.id === splitId || s.externalId === splitId
    );
    if (split) {
      const slice = split.slices.find((s) => s.id === sliceId || s.externalId === sliceId);
      if (slice) {
        slice.contents.map((x) => {
          globalVariants.push({
            name: x.group,
            value: x.variant,
            projectId: x.projectId
          });
        });
      }
    }
  });
  return globalVariants;
};
var mergeGlobalVariantsSpec = (target, from) => {
  let result = [...target];
  const existingGlobalVariants = new Set(
    target.map((t) => {
      var _a2;
      return `${t.name}-${(_a2 = t.projectId) != null ? _a2 : ""}`;
    })
  );
  const newGlobals = from.filter(
    (t) => {
      var _a2;
      return !existingGlobalVariants.has(`${t.name}-${(_a2 = t.projectId) != null ? _a2 : ""}`);
    }
  );
  if (newGlobals.length > 0) {
    result = [...result, ...newGlobals];
  }
  return result;
};

// src/loader-shared.ts
var SUBSTITUTED_COMPONENTS = {};
var REGISTERED_CODE_COMPONENT_HELPERS = {};
var SUBSTITUTED_GLOBAL_VARIANT_HOOKS = {};
var REGISTERED_CUSTOM_FUNCTIONS = {};
function customFunctionImportAlias(meta) {
  const customFunctionPrefix = `__fn_`;
  return meta.namespace ? `${customFunctionPrefix}${meta.namespace}__${meta.name}` : `${customFunctionPrefix}${meta.name}`;
}
function internalSetRegisteredFunction(fn, meta) {
  REGISTERED_CUSTOM_FUNCTIONS[customFunctionImportAlias(meta)] = fn;
}
function parseFetchComponentDataArgs(...args) {
  let specs;
  let opts;
  if (Array.isArray(args[0])) {
    specs = args[0];
    opts = args[1];
  } else {
    specs = args;
    opts = void 0;
  }
  return { specs, opts };
}
var BaseInternalPlasmicComponentLoader = class {
  constructor(args) {
    this.registry = new import_loader_core2.Registry();
    this.globalVariants = [];
    this.subs = [];
    this.bundle = {
      modules: {
        browser: [],
        server: []
      },
      components: [],
      globalGroups: [],
      projects: [],
      activeSplits: [],
      bundleKey: null,
      deferChunksByDefault: false,
      disableRootLoadingBoundaryByDefault: false,
      filteredIds: {}
    };
    this.opts = args.opts;
    this.fetcher = args.fetcher;
    this.tracker = args.tracker;
    this.onBundleMerged = args.onBundleMerged;
    this.onBundleFetched = args.onBundleFetched;
    this.registerModules(args.builtinModules);
  }
  maybeGetCompMetas(...specs) {
    const found = /* @__PURE__ */ new Set();
    const missing = [];
    for (const spec of specs) {
      const filteredMetas = getCompMetas(this.bundle.components, spec);
      if (filteredMetas.length > 0) {
        filteredMetas.forEach((meta) => found.add(meta));
      } else {
        missing.push(spec);
      }
    }
    return { found: Array.from(found.keys()), missing };
  }
  maybeFetchComponentData(...args) {
    return __async(this, null, function* () {
      const { specs, opts } = parseFetchComponentDataArgs(...args);
      const returnWithSpecsToFetch = (specsToFetch) => __async(this, null, function* () {
        yield this.fetchMissingData({ missingSpecs: specsToFetch });
        const { found: existingMetas2, missing: missingSpecs2 } = this.maybeGetCompMetas(...specs);
        if (missingSpecs2.length > 0) {
          return null;
        }
        return prepComponentData(this.bundle, existingMetas2, opts);
      });
      if (this.opts.alwaysFresh) {
        return yield returnWithSpecsToFetch(specs);
      }
      const { found: existingMetas, missing: missingSpecs } = this.maybeGetCompMetas(...specs);
      if (missingSpecs.length === 0) {
        return prepComponentData(this.bundle, existingMetas, opts);
      }
      return yield returnWithSpecsToFetch(missingSpecs);
    });
  }
  fetchComponentData(...args) {
    return __async(this, null, function* () {
      const { specs, opts } = parseFetchComponentDataArgs(...args);
      const data = yield this.maybeFetchComponentData(specs, opts);
      if (!data) {
        const { missing: missingSpecs } = this.maybeGetCompMetas(...specs);
        throw new Error(
          `Unable to find components ${missingSpecs.map(getLookupSpecName).join(", ")}`
        );
      }
      return data;
    });
  }
  fetchPages(opts) {
    return __async(this, null, function* () {
      this.maybeReportClientSideFetch(
        () => `Plasmic: fetching all page metadata in the browser`
      );
      const data = yield this.fetchAllData();
      return data.components.filter(
        (comp) => comp.isPage && comp.path && ((opts == null ? void 0 : opts.includeDynamicPages) || !isDynamicPagePath(comp.path))
      );
    });
  }
  fetchComponents() {
    return __async(this, null, function* () {
      this.maybeReportClientSideFetch(
        () => `Plasmic: fetching all component metadata in the browser`
      );
      const data = yield this.fetchAllData();
      return data.components;
    });
  }
  getActiveSplits() {
    return this.bundle.activeSplits;
  }
  getChunksUrl(bundle, modules) {
    return this.fetcher.getChunksUrl(bundle, modules);
  }
  fetchMissingData(opts) {
    return __async(this, null, function* () {
      this.maybeReportClientSideFetch(
        () => `Plasmic: fetching missing components in the browser: ${opts.missingSpecs.map((spec) => getLookupSpecName(spec)).join(", ")}`
      );
      return this.fetchAllData();
    });
  }
  maybeReportClientSideFetch(mkMsg) {
    if (isBrowser && this.opts.onClientSideFetch) {
      const msg = mkMsg();
      if (this.opts.onClientSideFetch === "warn") {
        console.warn(msg);
      } else {
        throw new Error(msg);
      }
    }
  }
  fetchAllData() {
    return __async(this, null, function* () {
      var _a2;
      const bundle = yield this.fetcher.fetchAllData();
      this.tracker.trackFetch();
      this.mergeBundle(bundle);
      (_a2 = this.onBundleFetched) == null ? void 0 : _a2.call(this);
      return bundle;
    });
  }
  mergeBundle(newBundle) {
    var _a2, _b;
    newBundle.bundleKey = (_a2 = newBundle.bundleKey) != null ? _a2 : null;
    if (newBundle.bundleKey && this.bundle.bundleKey && newBundle.bundleKey !== this.bundle.bundleKey) {
      console.warn(
        `Plasmic Error: Different code export hashes. This can happen if your app is using different loaders with different project IDs or project versions.
Conflicting values:
${newBundle.bundleKey}
${this.bundle.bundleKey}`
      );
    }
    this.bundle = mergeBundles(newBundle, this.bundle);
    (_b = this.onBundleMerged) == null ? void 0 : _b.call(this);
  }
  getBundle() {
    return this.bundle;
  }
  clearCache() {
    this.bundle = {
      modules: {
        browser: [],
        server: []
      },
      components: [],
      globalGroups: [],
      projects: [],
      activeSplits: [],
      bundleKey: null,
      deferChunksByDefault: false,
      disableRootLoadingBoundaryByDefault: false,
      filteredIds: {}
    };
    this.registry.clear();
  }
  registerModules(modules) {
    if (Object.keys(modules).some(
      (name) => this.registry.getRegisteredModule(name) !== modules[name]
    )) {
      if (!this.registry.isEmpty()) {
        console.warn(
          "Calling PlasmicComponentLoader.registerModules() after Plasmic component has rendered; starting over."
        );
        this.registry.clear();
      }
      for (const key of Object.keys(modules)) {
        this.registry.register(key, modules[key]);
      }
    }
  }
  substituteComponent(component, name) {
    this.internalSubstituteComponent(component, name, void 0);
  }
  internalSubstituteComponent(component, name, codeComponentHelpers) {
    if (!this.isRegistryEmpty()) {
      console.warn(
        "Calling PlasmicComponentLoader.registerSubstitution() after Plasmic component has rendered; starting over."
      );
      this.clearRegistry();
    }
    this.subs.push({ lookup: name, component, codeComponentHelpers });
  }
  refreshRegistry() {
    for (const sub of this.subs) {
      const metas = getCompMetas(this.getBundle().components, sub.lookup);
      metas.forEach((meta) => {
        SUBSTITUTED_COMPONENTS[meta.id] = sub.component;
        if (sub.codeComponentHelpers) {
          REGISTERED_CODE_COMPONENT_HELPERS[meta.id] = sub.codeComponentHelpers;
        }
      });
    }
    this.registry.updateModules(this.getBundle());
  }
  isRegistryEmpty() {
    return this.registry.isEmpty();
  }
  clearRegistry() {
    this.registry.clear();
  }
  setGlobalVariants(globalVariants) {
    this.globalVariants = globalVariants;
  }
  getGlobalVariants() {
    return this.globalVariants;
  }
  registerPrefetchedBundle(bundle) {
    if (!isBrowser) {
      const cachedBundle = (0, import_loader_fetcher.internal_getCachedBundleInNodeServer)(this.opts);
      if (cachedBundle) {
        this.mergeBundle(cachedBundle);
      }
    }
    this.mergeBundle(bundle);
  }
  getLookup() {
    return new ComponentLookup(this.getBundle(), this.registry);
  }
  trackConversion(value = 0) {
    this.tracker.trackConversion(value);
  }
  getActiveVariation(opts) {
    return __async(this, null, function* () {
      yield this.fetchComponents();
      return (0, import_loader_splits.getActiveVariation)(__spreadProps(__spreadValues({}, opts), {
        splits: this.getBundle().activeSplits
      }));
    });
  }
  getTeamIds() {
    return uniq(
      this.getBundle().projects.map(
        (p) => p.teamId ? `${p.teamId}${p.indirect ? "@indirect" : ""}` : null
      ).filter((x) => !!x)
    );
  }
  getProjectIds() {
    return uniq(
      this.getBundle().projects.map(
        (p) => `${p.id}${p.indirect ? "@indirect" : ""}`
      )
    );
  }
  trackRender(opts) {
    this.tracker.trackRender(opts);
  }
  loadServerQueriesModule(fileName) {
    return this.registry.load(fileName);
  }
};
var PlasmicComponentLoader = class {
  constructor(internal) {
    this.warnedRegisterComponent = false;
    this.__internal = internal;
  }
  /**
   * Sets global variants to be used for all components.  Note that
   * this is not reactive, and will not re-render all components
   * already mounted; instead, it should be used to activate global
   * variants that should always be activated for the lifetime of this
   * app.  If you'd like to reactively change the global variants,
   * you should specify them via <PlasmicRootProvider />
   */
  setGlobalVariants(globalVariants) {
    this.__internal.setGlobalVariants(globalVariants);
  }
  registerModules(modules) {
    this.__internal.registerModules(modules);
  }
  /**
   * Register custom components that should be swapped in for
   * components defined in your project.  You can use this to
   * swap in / substitute a Plasmic component with a "real" component.
   */
  substituteComponent(component, name) {
    this.__internal.substituteComponent(component, name);
  }
  registerComponent(component, metaOrName) {
    if (metaOrName && typeof metaOrName === "object" && "props" in metaOrName) {
      this.__internal.registerComponent(component, metaOrName);
    } else {
      if (process.env.NODE_ENV === "development" && !this.warnedRegisterComponent) {
        console.warn(
          `PlasmicLoader: Using deprecated method \`registerComponent\` for component substitution. Please consider using \`substituteComponent\` instead.`
        );
        this.warnedRegisterComponent = true;
      }
      this.substituteComponent(component, metaOrName);
    }
  }
  registerFunction(fn, meta) {
    this.__internal.registerFunction(fn, meta);
  }
  registerGlobalContext(context, meta) {
    this.__internal.registerGlobalContext(context, meta);
  }
  registerTrait(trait, meta) {
    this.__internal.registerTrait(trait, meta);
  }
  registerToken(token) {
    this.__internal.registerToken(token);
  }
  fetchComponentData(...args) {
    return this.__internal.fetchComponentData(...args);
  }
  maybeFetchComponentData(...args) {
    return __async(this, null, function* () {
      return this.__internal.maybeFetchComponentData(...args);
    });
  }
  /**
   * Returns all the page component metadata for these projects.
   */
  fetchPages(opts) {
    return __async(this, null, function* () {
      return this.__internal.fetchPages(opts);
    });
  }
  /**
   * Returns all components metadata for these projects.
   */
  fetchComponents() {
    return __async(this, null, function* () {
      return this.__internal.fetchComponents();
    });
  }
  _getActiveVariation(opts) {
    return __async(this, null, function* () {
      return this.__internal.getActiveVariation(opts);
    });
  }
  getActiveVariation(opts) {
    return __async(this, null, function* () {
      return this._getActiveVariation({
        traits: opts.traits,
        getKnownValue: (key) => {
          if (opts.known) {
            return opts.known[key];
          } else {
            const cookies = getPlasmicCookieValues();
            return cookies[key];
          }
        },
        updateKnownValue: (key, value) => {
          if (!opts.known) {
            updatePlasmicCookieValue(key, value);
          }
        }
      });
    });
  }
  getChunksUrl(bundle, modules) {
    return this.__internal.getChunksUrl(bundle, modules);
  }
  getExternalVariation(variation, filters) {
    return (0, import_loader_splits.getExternalIds)(this.getActiveSplits(), variation, filters);
  }
  getActiveSplits() {
    return this.__internal.getActiveSplits();
  }
  trackConversion(value = 0) {
    this.__internal.trackConversion(value);
  }
  clearCache() {
    return this.__internal.clearCache();
  }
  unstable__getServerQueriesData(renderData, $ctx) {
    return __async(this, null, function* () {
      if (renderData.entryCompMetas.length === 0) {
        return {};
      }
      const fileName = renderData.entryCompMetas[0].serverQueriesExecFuncFileName;
      if (!fileName) {
        return {};
      }
      const module2 = this.__internal.loadServerQueriesModule(fileName);
      const { executeServerQueries } = module2;
      try {
        const $serverQueries = yield executeServerQueries($ctx);
        return $serverQueries;
      } catch (err) {
        console.error("Error executing server queries function", err);
        return {};
      }
    });
  }
};

// src/swr-util.ts
function swrSerialize(key) {
  if (typeof key === "function") {
    try {
      key = key();
    } catch (err) {
      key = "";
    }
  }
  const args = [].concat(key);
  key = typeof key == "string" ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : "";
  return [key, args];
}
var table = /* @__PURE__ */ new WeakMap();
var counter = 0;
function stableHash(arg) {
  const type = typeof arg;
  const constructor = arg && arg.constructor;
  const isDate = constructor == Date;
  let result;
  let index;
  if (Object(arg) === arg && !isDate && constructor != RegExp) {
    result = table.get(arg);
    if (result)
      return result;
    result = ++counter + "~";
    table.set(arg, result);
    if (constructor == Array) {
      result = "@";
      for (index = 0; index < arg.length; index++) {
        result += stableHash(arg[index]) + ",";
      }
      table.set(arg, result);
    }
    if (constructor == Object) {
      result = "#";
      const keys = Object.keys(arg).sort();
      while ((index = keys.pop()) !== void 0) {
        if (arg[index] !== void 0) {
          result += index + ":" + stableHash(arg[index]) + ",";
        }
      }
      table.set(arg, result);
    }
  } else {
    result = isDate ? arg.toJSON() : type == "symbol" ? arg.toString() : type == "string" ? JSON.stringify(arg) : "" + arg;
  }
  return result;
}

// src/loader-server.tsx
var noop = () => {
};
var identity = (x) => x;
var unreachable = () => {
  debugger;
  throw new Error("Unreachable code");
};
var REACT_PROVIDER_TYPE = typeof Symbol === "function" && Symbol.for ? Symbol.for("react.provider") : 60109;
var FakeRootProviderContext = {
  _currentValue: void 0
  // default value
};
var FakeDataContext = {
  _currentValue: void 0
  // default value
};
var FakePlasmicComponentContext = {
  _currentValue: false
  // default value
};
var FakePlasmicPrepassContext = {
  _currentValue: void 0
};
var mkMetaName = (name) => `__plasmic_meta_${name}`;
function FakeDataCtxReader({ children }) {
  const $ctx = getPrepassContextEnv().readContextValue(FakeDataContext);
  return children($ctx);
}
function FakeDataProvider({
  name,
  data,
  hidden,
  advanced,
  label,
  children
}) {
  var _a2;
  const { readContextValue, setContextValue } = getPrepassContextEnv();
  const existingEnv = (_a2 = readContextValue(FakeDataContext)) != null ? _a2 : {};
  if (!name) {
    return /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null, children);
  } else {
    setContextValue(FakeDataContext, __spreadProps(__spreadValues({}, existingEnv), {
      [name]: data,
      [mkMetaName(name)]: { hidden, advanced, label }
    }));
    return /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null, children);
  }
}
var fakeApplySelector = (rawData, selector) => {
  if (!selector) {
    return void 0;
  }
  let curData = rawData;
  for (const key of selector.split(".")) {
    curData = curData == null ? void 0 : curData[key];
  }
  return curData;
};
function fakeUseSelector(selector) {
  const rawData = getPrepassContextEnv().readContextValue(FakeDataContext);
  return fakeApplySelector(rawData, selector);
}
function fakeUseSelectors(selectors = {}) {
  const rawData = getPrepassContextEnv().readContextValue(FakeDataContext);
  return Object.fromEntries(
    Object.entries(selectors).filter(([key, selector]) => !!key && !!selector).map(([key, selector]) => [
      key,
      fakeApplySelector(rawData, selector)
    ])
  );
}
function fakeUsePlasmicDataConfig() {
  const cache = getPrepassContextEnv().readContextValue(
    FakePlasmicPrepassContext
  );
  return { cache };
}
var fakeUseMutablePlasmicQueryData = (unserializedKey, fetcher) => {
  const [key, args] = swrSerialize(unserializedKey);
  if (!key) {
    return {
      isValidating: false,
      mutate: () => __async(void 0, null, function* () {
      }),
      data: void 0
    };
  }
  const cache = fakeUsePlasmicDataConfig().cache;
  if (cache.has(key)) {
    return {
      isValidating: false,
      mutate: () => __async(void 0, null, function* () {
      }),
      data: cache.get(key)
    };
  }
  const response = fetcher(...args);
  if (response && typeof response.then == "function") {
    throw response.then((data) => cache.set(key, data));
  } else {
    cache.set(key, response);
    return {
      isValidating: false,
      mutate: () => __async(void 0, null, function* () {
      }),
      data: cache.get(key)
    };
  }
};
var _a;
var FakeReactComponent = (_a = class {
  constructor() {
    this.context = void 0;
    this.props = {};
    this.setState = (v) => void (this.state = v);
    this.forceUpdate = noop;
    this.render = () => null;
    this.state = {};
    this.refs = {};
  }
  initRender(props) {
    this.props = props;
    const dispatcher = import_react.default.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher.current;
    const [state, setState] = dispatcher.useState({});
    this.state = state;
    this.setState = setState;
    if (this.constructor.contextType) {
      this.context = dispatcher.useContext(
        this.constructor.contextType
      );
    }
  }
}, _a.contextType = void 0, _a);
var fakeCreateElement = (originalCreateElement) => (type, ...args) => {
  if (Object.prototype.isPrototypeOf.call(FakeReactComponent, type)) {
    return originalCreateElement((props) => {
      const instance = new type();
      instance.initRender(props);
      return instance.render();
    }, ...args);
  }
  return originalCreateElement(type, ...args);
};
var InternalPrepassPlasmicLoader = class extends BaseInternalPlasmicComponentLoader {
  constructor(opts) {
    super({
      opts,
      tracker: new import_loader_core3.PlasmicTracker({
        projectIds: opts.projects.map((p) => p.id),
        platform: opts.platform,
        preview: opts.preview,
        nativeFetch: opts.nativeFetch
      }),
      onBundleMerged: () => {
        this.refreshRegistry();
      },
      fetcher: new import_loader_core3.PlasmicModulesFetcher(opts),
      builtinModules: {
        react: __spreadProps(__spreadValues(__spreadProps(__spreadValues(__spreadValues({}, import_react.default), { isRSC: true }), {
          createContext: (defaultValue) => {
            const context = {
              _currentValue: defaultValue,
              displayName: "FakeContext",
              Provider: ({ value, children }) => {
                getPrepassContextEnv().setContextValue(context, value);
                return /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null, children);
              },
              Consumer: ({ children }) => children(getPrepassContextEnv().readContextValue(context))
            };
            return context;
          }
        }), Object.fromEntries(
          [
            "useCallback",
            "useContext",
            "useEffect",
            "useImperativeHandle",
            "useDebugValue",
            "useInsertionEffect",
            "useLayoutEffect",
            "useMemo",
            "useSyncExternalStore",
            "useReducer",
            "useRef",
            "useState"
          ].map((hook) => [
            hook,
            (...args) => {
              const dispatcher = import_react.default.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher.current;
              return dispatcher[hook](...args);
            }
          ])
        )), {
          useDeferredValue: (v) => v,
          useTransition: () => [
            false,
            (f) => {
              f();
            }
          ],
          createFactory: (type) => import_react.default.createElement.bind(null, type),
          Component: FakeReactComponent,
          PureComponent: FakeReactComponent,
          createElement: fakeCreateElement(import_react.default.createElement)
        }),
        "react-dom": import_react_dom.default,
        "react/jsx-runtime": __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, jsxRuntime), jsxRuntime.jsx ? { jsx: fakeCreateElement(jsxRuntime.jsx) } : {}), jsxRuntime.jsxs ? { jsxs: fakeCreateElement(jsxRuntime.jsxs) } : {}), jsxRuntime.jsxDEV ? { jsxDEV: fakeCreateElement(jsxRuntime.jsxDEV) } : {}),
        "react/jsx-dev-runtime": __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, jsxDevRuntime), jsxDevRuntime.jsx ? { jsx: fakeCreateElement(jsxDevRuntime.jsx) } : {}), jsxDevRuntime.jsxs ? { jsxs: fakeCreateElement(jsxDevRuntime.jsxs) } : {}), jsxDevRuntime.jsxDEV ? { jsxDEV: fakeCreateElement(jsxDevRuntime.jsxDEV) } : {}),
        "@plasmicapp/query": {
          addLoadingStateListener: () => noop,
          isPlasmicPrepass: () => true,
          PlasmicPrepassContext: {},
          PlasmicQueryDataProvider: ({ children }) => /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null, children),
          useMutablePlasmicQueryData: fakeUseMutablePlasmicQueryData,
          usePlasmicDataConfig: fakeUsePlasmicDataConfig,
          usePlasmicQueryData: fakeUseMutablePlasmicQueryData,
          useSWRConfig: unreachable,
          wrapLoadingFetcher: identity,
          HeadMetadataContext: {
            _currentValue: {},
            displayName: "FakeHeadMetadataContext",
            Provider: ({ children }) => /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null, children),
            Consumer: ({ children }) => children({})
          }
        },
        "@plasmicapp/data-sources-context": (() => {
          const FakePlasmicDataSourceContext = {
            _currentValue: void 0
            // default value
          };
          return {
            PlasmicDataSourceContextProvider: Object.assign(
              ({ children, value }) => {
                const { setContextValue } = getPrepassContextEnv();
                setContextValue(FakePlasmicDataSourceContext, value);
                return /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null, children);
              },
              {
                $$typeof: REACT_PROVIDER_TYPE,
                _context: FakePlasmicDataSourceContext
              }
            ),
            useCurrentUser: () => {
              var _a2;
              const { readContextValue } = getPrepassContextEnv();
              const ctx = readContextValue(FakePlasmicDataSourceContext);
              return (_a2 = ctx == null ? void 0 : ctx.user) != null ? _a2 : {
                isLoggedIn: false
              };
            },
            usePlasmicDataSourceContext: () => {
              const { readContextValue } = getPrepassContextEnv();
              return readContextValue(FakePlasmicDataSourceContext);
            }
          };
        })(),
        "@plasmicapp/host": (() => {
          return {
            applySelector: fakeApplySelector,
            DataContext: FakeDataContext,
            DataCtxReader: FakeDataCtxReader,
            DataProvider: FakeDataProvider,
            GlobalActionsContext: {
              _currentValue: void 0
              // default value
            },
            GlobalActionsProvider: ({ children }) => /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null, children),
            mkMetaName,
            mkMetaValue: identity,
            PageParamsProvider: ({ children }) => /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null, children),
            PlasmicCanvasContext: { _currentValue: false },
            PlasmicCanvasHost: () => null,
            PlasmicLinkProvider: ({ children }) => /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null, children),
            registerComponent: noop,
            registerFunction: noop,
            registerGlobalContext: noop,
            registerToken: noop,
            registerTrait: noop,
            repeatedElement: unreachable,
            stateHelpersKeys: ["initFunc", "onChangeArgsToValue", "onMutate"],
            unstable_registerFetcher: noop,
            useDataEnv: () => getPrepassContextEnv().readContextValue(FakeDataContext),
            useGlobalActions: () => new Proxy(
              {},
              {
                get: () => noop
              }
            ),
            usePlasmicTranslator: () => void 0,
            PlasmicTranslatorContext: { _currentValue: void 0 },
            usePlasmicCanvasContext: () => false,
            usePlasmicLink: () => (props) => /* @__PURE__ */ import_react.default.createElement("a", __spreadValues({}, props)),
            usePlasmicLinkMaybe: () => void 0,
            useSelector: fakeUseSelector,
            useSelectors: fakeUseSelectors,
            usePlasmicCanvasComponentInfo: () => null
          };
        })(),
        "@plasmicapp/loader-runtime-registry": {
          components: SUBSTITUTED_COMPONENTS,
          globalVariantHooks: SUBSTITUTED_GLOBAL_VARIANT_HOOKS,
          codeComponentHelpers: REGISTERED_CODE_COMPONENT_HELPERS,
          functions: REGISTERED_CUSTOM_FUNCTIONS
        }
      }
    });
    this.registerTrait = noop;
    this.registerToken = noop;
  }
  registerComponent(component, meta) {
    var _a2;
    const stateHelpers = Object.fromEntries(
      Object.entries((_a2 = meta.states) != null ? _a2 : {}).filter(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        ([_, stateSpec]) => (
          // `initFunc` is the only helper function used in RSC phase
          "initFunc" in stateSpec
        )
      ).map(([stateName, stateSpec]) => [
        stateName,
        { initFunc: stateSpec.initFunc }
      ])
    );
    const helpers = { states: stateHelpers };
    this.internalSubstituteComponent(
      meta.getServerInfo ? (props) => {
        var _a3;
        const { readContextValue } = getPrepassContextEnv();
        const serverInfo = (_a3 = meta.getServerInfo) == null ? void 0 : _a3.call(meta, props, {
          readContext: readContextValue,
          readDataEnv: () => readContextValue(FakeDataContext),
          readDataSelector: fakeUseSelector,
          readDataSelectors: fakeUseSelectors,
          fetchData: fakeUseMutablePlasmicQueryData
        });
        if (serverInfo && serverInfo.children) {
          const contents = [];
          const children = Array.isArray(serverInfo.children) ? serverInfo.children : [serverInfo.children];
          children.forEach((childData) => {
            contents.push(
              /* @__PURE__ */ import_react.default.createElement(ContextAndDataProviderWrapper, { contextAndData: childData }, childData.node)
            );
          });
          return /* @__PURE__ */ import_react.default.createElement(ContextAndDataProviderWrapper, { contextAndData: serverInfo }, contents);
        } else {
          return /* @__PURE__ */ import_react.default.createElement(
            ContextAndDataProviderWrapper,
            {
              contextAndData: serverInfo != null ? serverInfo : {}
            },
            Object.values(props).flat(Infinity).filter(
              (v) => v && typeof v == "object" && v.$$typeof && import_react.default.isValidElement(v)
            )
          );
        }
      } : component,
      { name: meta.name, isCode: true },
      Object.keys(stateHelpers).length > 0 ? helpers : void 0
    );
  }
  registerFunction(fn, meta) {
    internalSetRegisteredFunction(fn, meta);
  }
  registerGlobalContext(context, meta) {
    this.substituteComponent(context, { name: meta.name, isCode: true });
  }
  refreshRegistry() {
    for (const globalGroup of this.getBundle().globalGroups) {
      if (globalGroup.type !== "global-screen") {
        SUBSTITUTED_GLOBAL_VARIANT_HOOKS[globalGroup.id] = () => {
          var _a2;
          const rootContext = getPrepassContextEnv().readContextValue(
            FakeRootProviderContext
          );
          const loader = this;
          const { name, projectId } = globalGroup;
          const spec = [
            ...loader.getGlobalVariants(),
            ...(_a2 = rootContext.globalVariants) != null ? _a2 : []
          ].find(
            (s) => s.name === name && (!s.projectId || s.projectId === projectId)
          );
          return spec ? spec.value : void 0;
        };
      }
    }
    super.refreshRegistry();
  }
};
function handlePrepassPlasmicRootComponent(props) {
  var _a2;
  const {
    globalVariants,
    globalContextsProps,
    variation,
    translator,
    Head,
    Link,
    pageRoute,
    pageParams,
    pageQuery,
    suspenseFallback,
    disableLoadingBoundary,
    user,
    userAuthToken,
    isUserLoading,
    authRedirectUri
  } = props;
  const loader = props.loader.__internal;
  const splits = loader.getActiveSplits();
  const value = {
    globalVariants: mergeGlobalVariantsSpec(
      globalVariants != null ? globalVariants : [],
      getGlobalVariantsFromSplits(splits, variation != null ? variation : {})
    ),
    globalContextsProps,
    loader,
    variation,
    translator,
    Head,
    Link,
    user,
    userAuthToken,
    isUserLoading,
    authRedirectUri,
    suspenseFallback,
    disableLoadingBoundary
  };
  const { setContextValue, readContextValue } = getPrepassContextEnv();
  setContextValue(FakeRootProviderContext, value);
  const existingEnv = (_a2 = readContextValue(FakeDataContext)) != null ? _a2 : {};
  const fixCatchallParams = (params) => {
    const newParams = {};
    for (const [key, val] of Object.entries(params)) {
      if (!val) {
        continue;
      }
      if (key.startsWith("...")) {
        newParams[key.slice(3)] = typeof val === "string" ? val.replace(/^\/|\/$/g, "").split("/") : val;
      } else {
        newParams[key] = val;
      }
    }
    return newParams;
  };
  const mkPathFromRouteAndParams = (route, params) => {
    if (!params) {
      return route;
    }
    let path = route;
    for (const [key, val] of Object.entries(params)) {
      if (typeof val === "string") {
        path = path.replace(`[${key}]`, val);
      } else if (Array.isArray(val)) {
        if (path.includes(`[[...${key}]]`)) {
          path = path.replace(`[[...${key}]]`, val.join("/"));
        } else if (path.includes(`[...${key}]`)) {
          path = path.replace(`[...${key}]`, val.join("/"));
        }
      }
    }
    return path;
  };
  const fixedParams = fixCatchallParams(pageParams != null ? pageParams : {});
  setContextValue(FakeDataContext, __spreadProps(__spreadValues({}, existingEnv), {
    ["pageRoute"]: pageRoute,
    [mkMetaName("pageRoute")]: { advanced: true, label: "Page route" },
    ["pagePath"]: pageRoute ? mkPathFromRouteAndParams(pageRoute, fixedParams) : void 0,
    [mkMetaName("pagePath")]: { label: "Page path" },
    ["params"]: __spreadValues(__spreadValues({}, existingEnv.params), fixedParams),
    [mkMetaName("params")]: { label: "Page URL path params" },
    ["query"]: __spreadValues(__spreadValues({}, existingEnv.query), pageQuery),
    [mkMetaName("query")]: { label: "Page URL query params" }
  }));
}
function handlePrepassPlasmicComponent(props) {
  var _b;
  const { component, projectId, componentProps, forceOriginal } = props;
  const { setContextValue, readContextValue } = getPrepassContextEnv();
  const rootContext = readContextValue(
    FakeRootProviderContext
  );
  const isRootLoader = !readContextValue(FakePlasmicComponentContext);
  if (!rootContext) {
    throw new Error(
      `You must use <PlasmicRootProvider/> at the root of your app`
    );
  }
  const _a2 = rootContext, {
    loader,
    globalContextsProps,
    userAuthToken,
    isUserLoading,
    authRedirectUri,
    translator
  } = _a2, rest = __objRest(_a2, [
    "loader",
    "globalContextsProps",
    "userAuthToken",
    "isUserLoading",
    "authRedirectUri",
    "translator"
  ]);
  const spec = { name: component, projectId, isCode: false };
  const opts = { forceOriginal };
  const lookup = loader.getLookup();
  if (!lookup.hasComponent(spec)) {
    return null;
  }
  const Component = lookup.getComponent(spec, opts);
  let element = /* @__PURE__ */ import_react.default.createElement(Component, __spreadValues({}, componentProps));
  if (isRootLoader) {
    const ReactWebRootProvider = lookup.getRootProvider();
    const GlobalContextsProvider = lookup.getGlobalContextsProvider({
      name: component,
      projectId
    });
    setContextValue(FakePlasmicComponentContext, true);
    element = /* @__PURE__ */ import_react.default.createElement(
      ReactWebRootProvider,
      __spreadProps(__spreadValues({}, rest), {
        userAuthToken,
        isUserLoading,
        authRedirectUri,
        i18n: {
          translator,
          tagPrefix: (_b = loader.opts.i18n) == null ? void 0 : _b.tagPrefix
        }
      }),
      element
    );
    if (GlobalContextsProvider) {
      element = /* @__PURE__ */ import_react.default.createElement(GlobalContextsProvider, __spreadValues({}, globalContextsProps), element);
    }
  }
  return element;
}
function handlePlasmicPrepassContext({
  cache
}) {
  getPrepassContextEnv().setContextValue(FakePlasmicPrepassContext, cache);
}
function getPrepassContextEnv() {
  return globalThis.__ssrPrepassEnv;
}
function ContextAndDataProviderWrapper({
  children,
  contextAndData
}) {
  var _a2;
  const { setContextValue, readContextValue } = getPrepassContextEnv();
  const contexts = contextAndData.providedContexts ? Array.isArray(contextAndData.providedContexts) ? contextAndData.providedContexts : [contextAndData.providedContexts] : [];
  const providedData = contextAndData.providedData ? Array.isArray(contextAndData.providedData) ? contextAndData.providedData : [contextAndData.providedData] : [];
  contexts.forEach((context) => {
    setContextValue(context.contextKey, context.value);
  });
  let $ctx = (_a2 = readContextValue(FakeDataContext)) != null ? _a2 : {};
  providedData.forEach(({ name, data }) => {
    $ctx = __spreadProps(__spreadValues({}, $ctx), {
      [name]: data
    });
  });
  setContextValue(FakeDataContext, $ctx);
  return /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null, children);
}

// src/prepass-server.ts
var import_prepass = require("@plasmicapp/prepass");
function extractPlasmicQueryData(element, loader) {
  return __async(this, null, function* () {
    return yield (0, import_prepass.extractPlasmicQueryData)(
      element,
      (elt) => handleClientComponentRef(elt, loader, element)
    );
  });
}
function handleClientComponentRef(elt, loader, rootElement) {
  var _a2, _b;
  try {
    const refId = elt.type.$$id;
    if (refId.includes("PlasmicRootProvider") || elt === rootElement) {
      const props = elt.props;
      if (props.prefetchedData) {
        handlePrepassPlasmicRootComponent(__spreadProps(__spreadValues({}, props), { loader }));
      }
      return;
    } else if (refId.includes("PlasmicComponent") && ((_a2 = elt.props) == null ? void 0 : _a2.component) != null) {
      return handlePrepassPlasmicComponent(elt.props);
    } else if (refId.includes("PlasmicPrepassContext") && ((_b = elt.props) == null ? void 0 : _b.cache) != null) {
      return handlePlasmicPrepassContext(elt.props);
    }
  } catch (err) {
    console.warn("Error processing client reference: ", err);
  }
  return;
}

// src/react-server.ts
function initPlasmicLoader(opts) {
  const internal = new InternalPrepassPlasmicLoader(opts);
  return new PlasmicComponentLoader(internal);
}
//# sourceMappingURL=react-server.js.map
