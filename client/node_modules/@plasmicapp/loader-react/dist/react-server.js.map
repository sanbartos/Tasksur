{
  "version": 3,
  "sources": ["../src/react-server.ts", "../src/loader-server.tsx", "../src/loader-shared.ts", "../src/bundles.ts", "../src/utils.tsx", "../src/component-lookup.ts", "../src/variation.ts", "../src/swr-util.ts", "../src/prepass-server.ts"],
  "sourcesContent": ["import \"server-only\";\n\nimport { InternalPrepassPlasmicLoader } from \"./loader-server\";\nimport { InitOptions, PlasmicComponentLoader } from \"./loader-shared\";\n\nexport { extractPlasmicQueryData as __EXPERMIENTAL__extractPlasmicQueryData } from \"./prepass-server\";\nexport * from \"./shared-exports\";\nexport {\n  InternalPrepassPlasmicLoader as InternalPlasmicComponentLoader,\n  PlasmicComponentLoader,\n};\n\nexport function initPlasmicLoader(opts: InitOptions): PlasmicComponentLoader {\n  const internal = new InternalPrepassPlasmicLoader(opts);\n  return new PlasmicComponentLoader(internal);\n}\n", "import type { TokenRegistration, TraitMeta } from \"@plasmicapp/host\";\nimport { PlasmicModulesFetcher, PlasmicTracker } from \"@plasmicapp/loader-core\";\nimport type {\n  PlasmicPrepassContext,\n  useMutablePlasmicQueryData,\n} from \"@plasmicapp/query\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as jsxDevRuntime from \"react/jsx-dev-runtime\";\nimport * as jsxRuntime from \"react/jsx-runtime\";\nimport type { PlasmicComponent } from \"./PlasmicComponent\";\nimport type {\n  PlasmicRootContextValue,\n  PlasmicRootProvider,\n} from \"./PlasmicRootProvider\";\nimport {\n  BaseInternalPlasmicComponentLoader,\n  CodeComponentMeta,\n  CustomFunctionMeta,\n  GlobalContextMeta,\n  InitOptions,\n  REGISTERED_CODE_COMPONENT_HELPERS,\n  REGISTERED_CUSTOM_FUNCTIONS,\n  SUBSTITUTED_COMPONENTS,\n  SUBSTITUTED_GLOBAL_VARIANT_HOOKS,\n  ServerProvidedContext,\n  ServerProvidedData,\n  internalSetRegisteredFunction,\n} from \"./loader-shared\";\nimport { swrSerialize } from \"./swr-util\";\nimport {\n  getGlobalVariantsFromSplits,\n  mergeGlobalVariantsSpec,\n} from \"./variation\";\n\nconst noop: (...args: any) => void = () => {};\nconst identity = <T,>(x: T): T => x;\nconst unreachable: (...args: any) => never = () => {\n  debugger;\n  throw new Error(\"Unreachable code\");\n};\n\nconst REACT_PROVIDER_TYPE =\n  typeof Symbol === \"function\" && Symbol.for\n    ? Symbol.for(\"react.provider\")\n    : (0xeacd as any as symbol);\n\nexport const FakeRootProviderContext: React.Context<any> = {\n  _currentValue: undefined, // default value\n} as any;\n\nconst FakeDataContext: React.Context<any> = {\n  _currentValue: undefined, // default value\n} as any;\n\nconst FakePlasmicComponentContext: React.Context<boolean> = {\n  _currentValue: false, // default value\n} as any;\n\nconst FakePlasmicPrepassContext: React.Context<any> = {\n  _currentValue: undefined,\n} as any;\n\nconst mkMetaName = (name: string) => `__plasmic_meta_${name}`;\n\nfunction FakeDataCtxReader({ children }: { children: ($ctx: any) => any }) {\n  const $ctx = getPrepassContextEnv().readContextValue(FakeDataContext);\n  return children($ctx);\n}\n\nfunction FakeDataProvider({\n  name,\n  data,\n  hidden,\n  advanced,\n  label,\n  children,\n}: any) {\n  const { readContextValue, setContextValue } = getPrepassContextEnv();\n  const existingEnv = readContextValue(FakeDataContext) ?? {};\n  if (!name) {\n    return <>{children}</>;\n  } else {\n    setContextValue(FakeDataContext, {\n      ...existingEnv,\n      [name]: data,\n      [mkMetaName(name)]: { hidden, advanced, label },\n    });\n    return <>{children}</>;\n  }\n}\n\nconst fakeApplySelector = (rawData: any, selector: string | undefined) => {\n  if (!selector) {\n    return undefined;\n  }\n  let curData = rawData;\n  for (const key of selector.split(\".\")) {\n    curData = curData?.[key];\n  }\n  return curData;\n};\n\nfunction fakeUseSelector(selector: string | undefined): any {\n  const rawData = getPrepassContextEnv().readContextValue(FakeDataContext);\n  return fakeApplySelector(rawData, selector);\n}\n\nfunction fakeUseSelectors(selectors = {}): any {\n  const rawData = getPrepassContextEnv().readContextValue(FakeDataContext);\n  return Object.fromEntries(\n    Object.entries(selectors)\n      .filter(([key, selector]) => !!key && !!selector)\n      .map(([key, selector]) => [\n        key,\n        fakeApplySelector(rawData, selector as string),\n      ])\n  );\n}\n\nfunction fakeUsePlasmicDataConfig() {\n  const cache = getPrepassContextEnv().readContextValue(\n    FakePlasmicPrepassContext\n  );\n  return { cache } as any;\n}\n\nconst fakeUseMutablePlasmicQueryData: typeof useMutablePlasmicQueryData = (\n  unserializedKey,\n  fetcher\n) => {\n  const [key, args] = swrSerialize(unserializedKey);\n  if (!key) {\n    return {\n      isValidating: false,\n      mutate: (async () => {}) as any,\n      data: undefined,\n    };\n  }\n  const cache = fakeUsePlasmicDataConfig().cache as Map<string, any>;\n  if (cache.has(key)) {\n    return {\n      isValidating: false,\n      mutate: (async () => {}) as any,\n      data: cache.get(key),\n    };\n  }\n  const response = fetcher(...(args as any));\n  if (response && typeof (response as Promise<any>).then == \"function\") {\n    throw (response as Promise<any>).then((data) => cache.set(key, data));\n  } else {\n    cache.set(key, response);\n    return {\n      isValidating: false,\n      mutate: (async () => {}) as any,\n      data: cache.get(key),\n    };\n  }\n};\n\n/**\n * Class components cannot be server components, and for that reason React\n * doesn't even allow calling `createElement` on them if they are not client\n * references.\n *\n * For prepass, we replace the actual Component class with this fake one, and\n * use it as an adaptor to creating a function component instead, before calling\n * `createElement`.\n */\nconst FakeReactComponent = class FakeReactComponent {\n  context = undefined;\n  static contextType: any = undefined;\n  props: any = {};\n  setState: (v: any) => void = (v) => void (this.state = v);\n  forceUpdate = noop;\n  initRender(props: any) {\n    // Called before render to set the appropriate values for props, state,\n    // context... Use hooks to simulate the class component behavior.\n    this.props = props;\n    const dispatcher = (React as any)\n      .__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher\n      .current;\n    const [state, setState] = dispatcher.useState({});\n    this.state = state;\n    this.setState = setState;\n    if ((this.constructor as any).contextType) {\n      this.context = dispatcher.useContext(\n        (this.constructor as any).contextType\n      );\n    }\n  }\n  render = () => null;\n  state: any = {};\n  refs = {};\n} satisfies typeof React.Component;\n\nconst fakeCreateElement: <F extends (type: any, ...args: any[]) => any>(\n  originalFn: F\n) => F = ((originalCreateElement: Function) =>\n  (type: any, ...args: any[]) => {\n    if (Object.prototype.isPrototypeOf.call(FakeReactComponent, type)) {\n      return originalCreateElement((props: any) => {\n        const instance: InstanceType<typeof FakeReactComponent> = new type();\n        instance.initRender(props);\n        return instance.render();\n      }, ...args);\n    }\n    return originalCreateElement(type, ...args);\n  }) as any;\n\nexport class InternalPrepassPlasmicLoader extends BaseInternalPlasmicComponentLoader {\n  constructor(opts: InitOptions) {\n    super({\n      opts,\n      tracker: new PlasmicTracker({\n        projectIds: opts.projects.map((p) => p.id),\n        platform: opts.platform,\n        preview: opts.preview,\n        nativeFetch: opts.nativeFetch,\n      }),\n      onBundleMerged: () => {\n        this.refreshRegistry();\n      },\n      fetcher: new PlasmicModulesFetcher(opts),\n      builtinModules: {\n        react: {\n          ...React,\n          // We use this flag to indicate our packages fecthed from loader that\n          // we are running in RSC environment\n          ...({ isRSC: true } as any),\n          createContext: <T,>(defaultValue?: T) => {\n            const context: React.Context<T> = {\n              _currentValue: defaultValue,\n              displayName: \"FakeContext\",\n              Provider: ({ value, children }: any) => {\n                getPrepassContextEnv().setContextValue(context, value);\n                return <>{children}</>;\n              },\n              Consumer: ({ children }: any) =>\n                children(getPrepassContextEnv().readContextValue(context)),\n            } as any;\n            return context;\n          },\n          ...Object.fromEntries(\n            [\n              \"useCallback\",\n              \"useContext\",\n              \"useEffect\",\n              \"useImperativeHandle\",\n              \"useDebugValue\",\n              \"useInsertionEffect\",\n              \"useLayoutEffect\",\n              \"useMemo\",\n              \"useSyncExternalStore\",\n              \"useReducer\",\n              \"useRef\",\n              \"useState\",\n            ].map((hook) => [\n              hook,\n              (...args: any) => {\n                const dispatcher = (React as any)\n                  .__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n                  .ReactCurrentDispatcher.current;\n                return dispatcher[hook](...args);\n              },\n            ])\n          ),\n          useDeferredValue: (v) => v,\n          useTransition: () => [\n            false,\n            (f) => {\n              f();\n            },\n          ],\n          createFactory: (type: any) =>\n            React.createElement.bind(null, type) as any,\n          Component: FakeReactComponent,\n          PureComponent: FakeReactComponent,\n          createElement: fakeCreateElement(React.createElement),\n        },\n        \"react-dom\": ReactDOM,\n        \"react/jsx-runtime\": {\n          ...jsxRuntime,\n          ...((jsxRuntime as any).jsx\n            ? { jsx: fakeCreateElement((jsxRuntime as any).jsx) }\n            : {}),\n          ...((jsxRuntime as any).jsxs\n            ? { jsxs: fakeCreateElement((jsxRuntime as any).jsxs) }\n            : {}),\n          ...((jsxRuntime as any).jsxDEV\n            ? { jsxDEV: fakeCreateElement((jsxRuntime as any).jsxDEV) }\n            : {}),\n        },\n        \"react/jsx-dev-runtime\": {\n          ...jsxDevRuntime,\n          ...((jsxDevRuntime as any).jsx\n            ? { jsx: fakeCreateElement((jsxDevRuntime as any).jsx) }\n            : {}),\n          ...((jsxDevRuntime as any).jsxs\n            ? { jsxs: fakeCreateElement((jsxDevRuntime as any).jsxs) }\n            : {}),\n          ...((jsxDevRuntime as any).jsxDEV\n            ? { jsxDEV: fakeCreateElement((jsxDevRuntime as any).jsxDEV) }\n            : {}),\n        },\n        \"@plasmicapp/query\": {\n          addLoadingStateListener: () => noop,\n          isPlasmicPrepass: () => true,\n          PlasmicPrepassContext: {} as any,\n          PlasmicQueryDataProvider: ({ children }: any) => <>{children}</>,\n          useMutablePlasmicQueryData: fakeUseMutablePlasmicQueryData,\n          usePlasmicDataConfig: fakeUsePlasmicDataConfig,\n          usePlasmicQueryData: fakeUseMutablePlasmicQueryData,\n          useSWRConfig: unreachable,\n          wrapLoadingFetcher: identity,\n          HeadMetadataContext: {\n            _currentValue: {},\n            displayName: \"FakeHeadMetadataContext\",\n            Provider: ({ children }: any) => <>{children}</>,\n            Consumer: ({ children }: any) => children({}),\n          } as any as React.Context<any>,\n        },\n        \"@plasmicapp/data-sources-context\": (() => {\n          const FakePlasmicDataSourceContext: React.Context<any> = {\n            _currentValue: undefined, // default value\n          } as any;\n          return {\n            PlasmicDataSourceContextProvider: Object.assign(\n              ({ children, value }: any) => {\n                const { setContextValue } = getPrepassContextEnv();\n                setContextValue(FakePlasmicDataSourceContext, value);\n                return <>{children}</>;\n              },\n              {\n                $$typeof: REACT_PROVIDER_TYPE,\n                _context: FakePlasmicDataSourceContext,\n              }\n            ),\n            useCurrentUser: () => {\n              const { readContextValue } = getPrepassContextEnv();\n              const ctx = readContextValue(FakePlasmicDataSourceContext);\n              return (\n                ctx?.user ?? {\n                  isLoggedIn: false,\n                }\n              );\n            },\n            usePlasmicDataSourceContext: () => {\n              const { readContextValue } = getPrepassContextEnv();\n              return readContextValue(FakePlasmicDataSourceContext);\n            },\n          };\n        })(),\n        \"@plasmicapp/host\": (() => {\n          return {\n            applySelector: fakeApplySelector,\n            DataContext: FakeDataContext,\n            DataCtxReader: FakeDataCtxReader,\n            DataProvider: FakeDataProvider,\n            GlobalActionsContext: {\n              _currentValue: undefined, // default value\n            } as any as React.Context<any>,\n            GlobalActionsProvider: ({ children }) => <>{children}</>,\n            mkMetaName,\n            mkMetaValue: identity,\n            PageParamsProvider: ({ children }) => <>{children}</>,\n            PlasmicCanvasContext: { _currentValue: false } as any,\n            PlasmicCanvasHost: () => null,\n            PlasmicLinkProvider: ({ children }) => <>{children}</>,\n            registerComponent: noop,\n            registerFunction: noop,\n            registerGlobalContext: noop,\n            registerToken: noop,\n            registerTrait: noop,\n            repeatedElement: unreachable,\n            stateHelpersKeys: [\"initFunc\", \"onChangeArgsToValue\", \"onMutate\"],\n            unstable_registerFetcher: noop,\n            useDataEnv: () =>\n              getPrepassContextEnv().readContextValue(FakeDataContext),\n            useGlobalActions: () =>\n              new Proxy(\n                {},\n                {\n                  get: () => noop,\n                }\n              ),\n            usePlasmicTranslator: () => undefined,\n            PlasmicTranslatorContext: { _currentValue: undefined } as any,\n            usePlasmicCanvasContext: () => false,\n            usePlasmicLink: () => (props) => <a {...props} />,\n            usePlasmicLinkMaybe: () => undefined,\n            useSelector: fakeUseSelector,\n            useSelectors: fakeUseSelectors,\n            usePlasmicCanvasComponentInfo: () => null,\n          };\n        })(),\n        \"@plasmicapp/loader-runtime-registry\": {\n          components: SUBSTITUTED_COMPONENTS,\n          globalVariantHooks: SUBSTITUTED_GLOBAL_VARIANT_HOOKS,\n          codeComponentHelpers: REGISTERED_CODE_COMPONENT_HELPERS,\n          functions: REGISTERED_CUSTOM_FUNCTIONS,\n        },\n      },\n    });\n  }\n\n  registerComponent<T extends React.ComponentType<any>>(\n    component: T,\n    meta: CodeComponentMeta<React.ComponentProps<T>>\n  ) {\n    // making the component meta consistent between codegen and loader\n    const stateHelpers = Object.fromEntries(\n      Object.entries(meta.states ?? {})\n        .filter(\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          ([_, stateSpec]) =>\n            // `initFunc` is the only helper function used in RSC phase\n            \"initFunc\" in stateSpec\n        )\n        .map(([stateName, stateSpec]) => [\n          stateName,\n          { initFunc: stateSpec.initFunc },\n        ])\n    );\n    const helpers = { states: stateHelpers };\n    this.internalSubstituteComponent(\n      meta.getServerInfo\n        ? (props) => {\n            const { readContextValue } = getPrepassContextEnv();\n\n            const serverInfo = meta.getServerInfo?.(props, {\n              readContext: readContextValue as any,\n              readDataEnv: () => readContextValue(FakeDataContext),\n              readDataSelector: fakeUseSelector,\n              readDataSelectors: fakeUseSelectors,\n              fetchData: fakeUseMutablePlasmicQueryData,\n            });\n\n            if (serverInfo && serverInfo.children) {\n              const contents: React.ReactNode[] = [] as React.ReactNode[];\n              const children = Array.isArray(serverInfo.children)\n                ? serverInfo.children\n                : [serverInfo.children];\n              children.forEach((childData) => {\n                contents.push(\n                  <ContextAndDataProviderWrapper contextAndData={childData}>\n                    {childData.node}\n                  </ContextAndDataProviderWrapper>\n                );\n              });\n              return (\n                <ContextAndDataProviderWrapper contextAndData={serverInfo}>\n                  {contents}\n                </ContextAndDataProviderWrapper>\n              );\n            } else {\n              return (\n                <ContextAndDataProviderWrapper\n                  contextAndData={serverInfo ?? {}}\n                >\n                  {Object.values(props)\n                    .flat(Infinity)\n                    .filter(\n                      (v: any): v is React.ReactNode =>\n                        v &&\n                        typeof v == \"object\" &&\n                        v.$$typeof &&\n                        React.isValidElement(v)\n                    )}\n                </ContextAndDataProviderWrapper>\n              );\n            }\n          }\n        : component,\n      { name: meta.name, isCode: true },\n      Object.keys(stateHelpers).length > 0 ? helpers : undefined\n    );\n  }\n\n  registerFunction<F extends (...args: any[]) => any>(\n    fn: F,\n    meta: CustomFunctionMeta<F>\n  ) {\n    internalSetRegisteredFunction(fn, meta);\n  }\n\n  registerGlobalContext<T extends React.ComponentType<any>>(\n    context: T,\n    meta: GlobalContextMeta<React.ComponentProps<T>>\n  ) {\n    this.substituteComponent(context, { name: meta.name, isCode: true });\n  }\n\n  registerTrait: (trait: string, meta: TraitMeta) => void = noop;\n\n  registerToken: (token: TokenRegistration) => void = noop;\n\n  refreshRegistry() {\n    // We swap global variants' useXXXGlobalVariant() hook with\n    // a fake one that just reads from the PlasmicRootContext. Because\n    // global variant values are not supplied by the generated global variant\n    // context providers, but instead by <PlasmicRootProvider/> and by\n    // PlasmicComponentLoader.setGlobalVariants(), we redirect these\n    // hooks to read from them instead.\n    for (const globalGroup of this.getBundle().globalGroups) {\n      if (globalGroup.type !== \"global-screen\") {\n        SUBSTITUTED_GLOBAL_VARIANT_HOOKS[globalGroup.id] = () => {\n          const rootContext = getPrepassContextEnv().readContextValue(\n            FakeRootProviderContext\n          );\n          const loader = this;\n          const { name, projectId } = globalGroup;\n          const spec = [\n            ...loader.getGlobalVariants(),\n            ...(rootContext.globalVariants ?? []),\n          ].find(\n            (s) =>\n              s.name === name && (!s.projectId || s.projectId === projectId)\n          );\n          return spec ? spec.value : undefined;\n        };\n      }\n    }\n    super.refreshRegistry();\n  }\n}\nexport function handlePrepassPlasmicRootComponent(\n  props: Parameters<typeof PlasmicRootProvider>[0]\n) {\n  const {\n    globalVariants,\n    globalContextsProps,\n    variation,\n    translator,\n    Head,\n    Link,\n    pageRoute,\n    pageParams,\n    pageQuery,\n    suspenseFallback,\n    disableLoadingBoundary,\n    user,\n    userAuthToken,\n    isUserLoading,\n    authRedirectUri,\n  } = props;\n  const loader = (props.loader as any)\n    .__internal as InternalPrepassPlasmicLoader;\n\n  const splits = loader.getActiveSplits();\n  const value = {\n    globalVariants: mergeGlobalVariantsSpec(\n      globalVariants ?? [],\n      getGlobalVariantsFromSplits(splits, variation ?? {})\n    ),\n    globalContextsProps,\n    loader,\n    variation,\n    translator,\n    Head,\n    Link,\n    user,\n    userAuthToken,\n    isUserLoading,\n    authRedirectUri,\n    suspenseFallback,\n    disableLoadingBoundary,\n  };\n\n  const { setContextValue, readContextValue } = getPrepassContextEnv();\n\n  setContextValue(FakeRootProviderContext, value);\n\n  const existingEnv = readContextValue(FakeDataContext) ?? {};\n\n  // We can't re-use these functions from @plasmiapp/host while it's a\n  // client component package :/\n  const fixCatchallParams = (\n    params: Record<string, string | string[] | undefined>\n  ) => {\n    const newParams: Record<string, string | string[]> = {};\n    for (const [key, val] of Object.entries(params)) {\n      if (!val) {\n        continue;\n      }\n      if (key.startsWith(\"...\")) {\n        newParams[key.slice(3)] =\n          typeof val === \"string\"\n            ? val.replace(/^\\/|\\/$/g, \"\").split(\"/\")\n            : val;\n      } else {\n        newParams[key] = val;\n      }\n    }\n    return newParams;\n  };\n\n  const mkPathFromRouteAndParams = (\n    route: string,\n    params: Record<string, string | string[] | undefined>\n  ) => {\n    if (!params) {\n      return route;\n    }\n    let path = route;\n    for (const [key, val] of Object.entries(params)) {\n      if (typeof val === \"string\") {\n        path = path.replace(`[${key}]`, val);\n      } else if (Array.isArray(val)) {\n        if (path.includes(`[[...${key}]]`)) {\n          path = path.replace(`[[...${key}]]`, val.join(\"/\"));\n        } else if (path.includes(`[...${key}]`)) {\n          path = path.replace(`[...${key}]`, val.join(\"/\"));\n        }\n      }\n    }\n    return path;\n  };\n\n  const fixedParams = fixCatchallParams(pageParams ?? {});\n\n  setContextValue(FakeDataContext, {\n    ...existingEnv,\n    [\"pageRoute\"]: pageRoute,\n    [mkMetaName(\"pageRoute\")]: { advanced: true, label: \"Page route\" },\n\n    [\"pagePath\"]: pageRoute\n      ? mkPathFromRouteAndParams(pageRoute, fixedParams)\n      : undefined,\n    [mkMetaName(\"pagePath\")]: { label: \"Page path\" },\n\n    [\"params\"]: { ...existingEnv.params, ...fixedParams },\n    [mkMetaName(\"params\")]: { label: \"Page URL path params\" },\n\n    [\"query\"]: { ...existingEnv.query, ...pageQuery },\n    [mkMetaName(\"query\")]: { label: \"Page URL query params\" },\n  });\n}\n\nexport function handlePrepassPlasmicComponent(\n  props: Parameters<typeof PlasmicComponent>[0]\n) {\n  const { component, projectId, componentProps, forceOriginal } = props;\n  const { setContextValue, readContextValue } = getPrepassContextEnv();\n  const rootContext: PlasmicRootContextValue = readContextValue(\n    FakeRootProviderContext\n  );\n  const isRootLoader = !readContextValue(FakePlasmicComponentContext);\n  if (!rootContext) {\n    // no existing PlasmicRootProvider\n    throw new Error(\n      `You must use <PlasmicRootProvider/> at the root of your app`\n    );\n  }\n  const {\n    loader,\n    globalContextsProps,\n    userAuthToken,\n    isUserLoading,\n    authRedirectUri,\n    translator,\n    ...rest\n  } = rootContext;\n\n  const spec = { name: component, projectId, isCode: false };\n  const opts = { forceOriginal };\n\n  const lookup = loader.getLookup();\n\n  if (!lookup.hasComponent(spec)) {\n    return null;\n  }\n\n  const Component = lookup.getComponent(spec, opts);\n\n  let element = <Component {...componentProps} />;\n  if (isRootLoader) {\n    const ReactWebRootProvider = lookup.getRootProvider();\n    const GlobalContextsProvider = lookup.getGlobalContextsProvider({\n      name: component,\n      projectId,\n    });\n    setContextValue(FakePlasmicComponentContext, true);\n    element = (\n      <ReactWebRootProvider\n        {...rest}\n        userAuthToken={userAuthToken}\n        isUserLoading={isUserLoading}\n        authRedirectUri={authRedirectUri}\n        i18n={{\n          translator,\n          tagPrefix: loader.opts.i18n?.tagPrefix,\n        }}\n      >\n        {element}\n      </ReactWebRootProvider>\n    );\n    if (GlobalContextsProvider) {\n      element = (\n        <GlobalContextsProvider {...globalContextsProps}>\n          {element}\n        </GlobalContextsProvider>\n      );\n    }\n  }\n  return element;\n}\n\nexport function handlePlasmicPrepassContext({\n  cache,\n}: Parameters<typeof PlasmicPrepassContext>[0]) {\n  getPrepassContextEnv().setContextValue(FakePlasmicPrepassContext, cache);\n}\n\nfunction getPrepassContextEnv(): {\n  setContextValue: (context: React.Context<any>, value: any) => void;\n  readContextValue: (context: React.Context<any>) => any;\n} {\n  return (globalThis as any).__ssrPrepassEnv;\n}\n\n// Provides context values to the children, described by\n// `ComponentMeta.getServerInfo`.\nfunction ContextAndDataProviderWrapper({\n  children,\n  contextAndData,\n}: {\n  children: React.ReactNode;\n  contextAndData: {\n    providedData?: ServerProvidedData | ServerProvidedData[];\n    providedContexts?: ServerProvidedContext | ServerProvidedContext[];\n  };\n}) {\n  const { setContextValue, readContextValue } = getPrepassContextEnv();\n  const contexts = contextAndData.providedContexts\n    ? Array.isArray(contextAndData.providedContexts)\n      ? contextAndData.providedContexts\n      : [contextAndData.providedContexts]\n    : [];\n  const providedData = contextAndData.providedData\n    ? Array.isArray(contextAndData.providedData)\n      ? contextAndData.providedData\n      : [contextAndData.providedData]\n    : [];\n  contexts.forEach((context) => {\n    setContextValue(context.contextKey as any, context.value);\n  });\n  let $ctx = readContextValue(FakeDataContext) ?? {};\n  providedData.forEach(({ name, data }) => {\n    $ctx = {\n      ...$ctx,\n      [name]: data,\n    };\n  });\n  setContextValue(FakeDataContext, $ctx);\n  return <>{children}</>;\n}\n", "import type {\n  ComponentHelpers,\n  ComponentHelpers as InternalCodeComponentHelpers,\n  CodeComponentMeta as InternalCodeComponentMeta,\n  CustomFunctionMeta as InternalCustomFunctionMeta,\n  GlobalContextMeta as InternalGlobalContextMeta,\n  StateHelpers,\n  StateSpec,\n  TokenRegistration,\n  TraitMeta,\n  useDataEnv,\n  useSelector,\n  useSelectors,\n} from \"@plasmicapp/host\";\nimport {\n  LoaderBundleCache,\n  PageMeta,\n  PlasmicModulesFetcher,\n  PlasmicTracker,\n  Registry,\n  TrackRenderOptions,\n} from \"@plasmicapp/loader-core\";\nimport {\n  CodeModule,\n  ComponentMeta,\n  LoaderBundleOutput,\n  internal_getCachedBundleInNodeServer,\n} from \"@plasmicapp/loader-fetcher\";\nimport { getActiveVariation, getExternalIds } from \"@plasmicapp/loader-splits\";\nimport type { useMutablePlasmicQueryData } from \"@plasmicapp/query\";\nimport type { GlobalVariantSpec } from \"./PlasmicRootProvider\";\nimport { mergeBundles, prepComponentData } from \"./bundles\";\nimport { ComponentLookup } from \"./component-lookup\";\nimport {\n  ComponentLookupSpec,\n  getCompMetas,\n  getLookupSpecName,\n  isBrowser,\n  isDynamicPagePath,\n  uniq,\n} from \"./utils\";\nimport { getPlasmicCookieValues, updatePlasmicCookieValue } from \"./variation\";\n\nexport interface InitOptions {\n  projects: {\n    id: string;\n    token: string;\n    version?: string;\n  }[];\n  cache?: LoaderBundleCache;\n  platform?: \"react\" | \"nextjs\" | \"gatsby\";\n  platformOptions?: {\n    nextjs?: {\n      appDir: boolean;\n    };\n  };\n  preview?: boolean;\n  host?: string;\n  onClientSideFetch?: \"warn\" | \"error\";\n  i18n?: {\n    keyScheme: \"content\" | \"hash\" | \"path\";\n    tagPrefix?: string;\n  };\n  /**\n   * @deprecated use i18n.keyScheme instead\n   */\n  i18nKeyScheme?: \"content\" | \"hash\";\n\n  /**\n   * By default, fetchComponentData() and fetchPages() calls cached in memory\n   * with the PlasmicComponentLoader instance.  If alwaysFresh is true, then\n   * data is always freshly fetched over the network.\n   */\n  alwaysFresh?: boolean;\n\n  /**\n   * If true, generated code from the server won't include page metadata tags\n   */\n  skipHead?: boolean;\n\n  /**\n   * If true, uses browser / node's native fetch\n   */\n  nativeFetch?: boolean;\n\n  /**\n   * If true, will not redirect to the codegen server automatically, and will\n   * try to reuse the existing bundle in the cache.\n   */\n  manualRedirect?: boolean;\n}\n\nexport interface ComponentRenderData {\n  entryCompMetas: (ComponentMeta & { params?: Record<string, string> })[];\n  bundle: LoaderBundleOutput;\n  remoteFontUrls: string[];\n}\n\nexport interface ComponentSubstitutionSpec {\n  lookup: ComponentLookupSpec;\n  component: React.ComponentType<any>;\n  codeComponentHelpers?: InternalCodeComponentHelpers<\n    React.ComponentProps<any>\n  >;\n}\n\nexport interface PlasmicRootWatcher {\n  onDataFetched?: () => void;\n}\n\n/**\n * Helper functions to describe code component behaviors, in order to allow\n * data extraction in RSC / Next.js App routing.\n */\nexport interface ReactServerOps {\n  readDataEnv: typeof useDataEnv;\n  readDataSelector: typeof useSelector;\n  readDataSelectors: typeof useSelectors;\n  /**\n   * The contexts are passed using a key instead of the context provider\n   * Notice it cannot access the default context value if none has been provided,\n   * since React server components cannot create contexts.\n   */\n  readContext: (contextKey: string) => any;\n  /**\n   * Allows data fetching from the code component and caching the result,\n   * which will be stored in the `queryCache` returned by\n   * `extractPlasmicQueryData`.\n   */\n  fetchData: typeof useMutablePlasmicQueryData;\n}\n\n/**\n * Represents data provided by a code component via `DataProvider`\n */\nexport interface ServerProvidedData {\n  name: string;\n  data: any;\n}\n\n/**\n * Provides a new value for a given context key, similar to Context.Provider.\n * The context itself is not available (RSC doesn't allow calling\n * `createContext`) so each context will need to be represented as a unique\n * \"context key\". Also it means the default context value is not available\n * in case no value is passed (and reading that context will return `undefined`)\n */\nexport interface ServerProvidedContext {\n  /**\n   * Identifier to the context, required to read it later via\n   * `ReactServerOps.readContext()`.\n   */\n  contextKey: string;\n  /**\n   * Context value being provided (similar to `Context.Provider`).\n   */\n  value: any;\n}\n\n/**\n *  Each child of a code component might receive separate `DataProvider` and\n *  Context values.\n */\nexport interface ServerChildData {\n  providedData?: ServerProvidedData | ServerProvidedData[];\n  providedContexts?: ServerProvidedContext | ServerProvidedContext[];\n  node: React.ReactNode;\n}\n\nexport interface ServerInfo {\n  /**\n   * Optional: Indicates the React Nodes created by the component and the\n   * respective contexts provided to them. If not specified, it will render the\n   * children passed to the component as props.\n   */\n  children?: ServerChildData | ServerChildData[];\n  providedData?: ServerProvidedData | ServerProvidedData[];\n  providedContexts?: ServerProvidedContext | ServerProvidedContext[];\n}\n\nexport type CodeComponentMeta<P> = Omit<\n  InternalCodeComponentMeta<P>,\n  \"importPath\" | \"componentHelpers\" | \"states\"\n> & {\n  /**\n   * The path to be used when importing the component in the generated code.\n   * It can be the name of the package that contains the component, or the path\n   * to the file in the project (relative to the root directory).\n   * Optional: not used by Plasmic headless API, only by codegen.\n   */\n  importPath?: string;\n  /**\n   * The states helpers are registered together with the states for the Plasmic headless API\n   */\n  states?: Record<string, StateSpec<P> & StateHelpers<P, any>>;\n\n  /**\n   * Helper function to enable data extraction when running Plasmic from\n   * Next.js App Router.\n   */\n  getServerInfo?: (props: P, ops: ReactServerOps) => ServerInfo;\n};\n\nexport type GlobalContextMeta<P> = Omit<\n  InternalGlobalContextMeta<P>,\n  \"importPath\"\n> & {\n  /**\n   * The path to be used when importing the component in the generated code.\n   * It can be the name of the package that contains the component, or the path\n   * to the file in the project (relative to the root directory).\n   * Optional: not used by Plasmic headless API, only by codegen.\n   */\n  importPath?: string;\n};\n\nexport type CustomFunctionMeta<F extends (...args: any[]) => any> = Omit<\n  InternalCustomFunctionMeta<F>,\n  \"importPath\"\n> & {\n  /**\n   * The path to be used when importing the function in the generated code.\n   * It can be the name of the package that contains the function, or the path\n   * to the file in the project (relative to the root directory).\n   * Optional: not used by Plasmic headless API, only by codegen.\n   */\n  importPath?: string;\n};\n\nexport type FetchPagesOpts = {\n  /**\n   * Whether to include dynamic pages in fetchPages() output. A page is\n   * considered dynamic if its path contains some param between brackets,\n   * e.g. \"[slug]\".\n   */\n  includeDynamicPages?: boolean;\n};\n\nexport const SUBSTITUTED_COMPONENTS: Record<\n  string,\n  React.ComponentType<any>\n> = {};\nexport const REGISTERED_CODE_COMPONENT_HELPERS: Record<\n  string,\n  InternalCodeComponentHelpers<React.ComponentProps<any>>\n> = {};\nexport const SUBSTITUTED_GLOBAL_VARIANT_HOOKS: Record<string, () => any> = {};\nexport const REGISTERED_CUSTOM_FUNCTIONS: Record<\n  string,\n  (...args: any[]) => any\n> = {};\n\nexport function customFunctionImportAlias<F extends (...args: any[]) => any>(\n  meta: CustomFunctionMeta<F>\n) {\n  const customFunctionPrefix = `__fn_`;\n  return meta.namespace\n    ? `${customFunctionPrefix}${meta.namespace}__${meta.name}`\n    : `${customFunctionPrefix}${meta.name}`;\n}\n\nexport function internalSetRegisteredFunction<\n  F extends (...args: any[]) => any\n>(fn: F, meta: CustomFunctionMeta<F>) {\n  REGISTERED_CUSTOM_FUNCTIONS[customFunctionImportAlias(meta)] = fn;\n}\n\ninterface BuiltinRegisteredModules {\n  react: typeof import(\"react\");\n  \"react-dom\": typeof import(\"react-dom\");\n  \"react/jsx-runtime\": typeof import(\"react/jsx-runtime\");\n  \"react/jsx-dev-runtime\": typeof import(\"react/jsx-dev-runtime\");\n  \"@plasmicapp/query\": typeof import(\"@plasmicapp/query\");\n  \"@plasmicapp/data-sources-context\": typeof import(\"@plasmicapp/data-sources-context\");\n  \"@plasmicapp/host\": typeof import(\"@plasmicapp/host\");\n  \"@plasmicapp/loader-runtime-registry\": {\n    components: Record<string, React.ComponentType<any>>;\n    globalVariantHooks: Record<string, () => any>;\n    codeComponentHelpers: Record<string, ComponentHelpers<any>>;\n    functions: Record<string, (...args: any[]) => any>;\n  };\n}\n\nexport interface FetchComponentDataOpts {\n  /**\n   * Will fetch either code targeting SSR or browser hydration in the\n   * returned bundle.\n   *\n   * By default, the target is browser. That's okay, because even when\n   * doing SSR, as long as you are using the same instance of PlasmicLoader\n   * that was used to fetch component data, it will still know how to get at\n   * the server code.\n   *\n   * But, if you are building your own SSR solution, where fetching and rendering\n   * are using different instances of PlasmicLoader, then you'll want to make\n   * sure that when you fetch, you are fetching the right one to be used in the\n   * right environment for either SSR or browser hydration.\n   */\n  target?: \"server\" | \"browser\";\n}\n\nfunction parseFetchComponentDataArgs(\n  specs: ComponentLookupSpec[],\n  opts?: FetchComponentDataOpts\n): { specs: ComponentLookupSpec[]; opts?: FetchComponentDataOpts };\nfunction parseFetchComponentDataArgs(...specs: ComponentLookupSpec[]): {\n  specs: ComponentLookupSpec[];\n  opts?: FetchComponentDataOpts;\n};\nfunction parseFetchComponentDataArgs(...args: any[]) {\n  let specs: ComponentLookupSpec[];\n  let opts: FetchComponentDataOpts | undefined;\n  if (Array.isArray(args[0])) {\n    specs = args[0];\n    opts = args[1];\n  } else {\n    specs = args;\n    opts = undefined;\n  }\n  return { specs, opts };\n}\n\n/** Subset of loader functionality that works on Client and React Server Components. */\nexport abstract class BaseInternalPlasmicComponentLoader {\n  public readonly opts: InitOptions;\n  private readonly registry = new Registry();\n  private readonly tracker: PlasmicTracker;\n  private readonly fetcher: PlasmicModulesFetcher;\n  private readonly onBundleMerged?: () => void;\n  private readonly onBundleFetched?: () => void;\n  private globalVariants: GlobalVariantSpec[] = [];\n  private subs: ComponentSubstitutionSpec[] = [];\n\n  private bundle: LoaderBundleOutput = {\n    modules: {\n      browser: [],\n      server: [],\n    },\n    components: [],\n    globalGroups: [],\n    projects: [],\n    activeSplits: [],\n    bundleKey: null,\n    deferChunksByDefault: false,\n    disableRootLoadingBoundaryByDefault: false,\n    filteredIds: {},\n  };\n\n  constructor(args: {\n    opts: InitOptions;\n    fetcher: PlasmicModulesFetcher;\n    tracker: PlasmicTracker;\n    /** Called after `mergeBundle` (including `fetch` calls). */\n    onBundleMerged?: () => void;\n    /** Called after any `fetch` calls. */\n    onBundleFetched?: () => void;\n    builtinModules: BuiltinRegisteredModules;\n  }) {\n    this.opts = args.opts;\n    this.fetcher = args.fetcher;\n    this.tracker = args.tracker;\n    this.onBundleMerged = args.onBundleMerged;\n    this.onBundleFetched = args.onBundleFetched;\n    this.registerModules(args.builtinModules);\n  }\n\n  private maybeGetCompMetas(...specs: ComponentLookupSpec[]) {\n    const found = new Set<ComponentMeta>();\n    const missing: ComponentLookupSpec[] = [];\n    for (const spec of specs) {\n      const filteredMetas = getCompMetas(this.bundle.components, spec);\n      if (filteredMetas.length > 0) {\n        filteredMetas.forEach((meta) => found.add(meta));\n      } else {\n        missing.push(spec);\n      }\n    }\n    return { found: Array.from(found.keys()), missing };\n  }\n\n  async maybeFetchComponentData(\n    specs: ComponentLookupSpec[],\n    opts?: FetchComponentDataOpts\n  ): Promise<ComponentRenderData | null>;\n  async maybeFetchComponentData(\n    ...specs: ComponentLookupSpec[]\n  ): Promise<ComponentRenderData | null>;\n  async maybeFetchComponentData(\n    ...args: any[]\n  ): Promise<ComponentRenderData | null> {\n    const { specs, opts } = parseFetchComponentDataArgs(...args);\n    const returnWithSpecsToFetch = async (\n      specsToFetch: ComponentLookupSpec[]\n    ) => {\n      await this.fetchMissingData({ missingSpecs: specsToFetch });\n      const { found: existingMetas2, missing: missingSpecs2 } =\n        this.maybeGetCompMetas(...specs);\n      if (missingSpecs2.length > 0) {\n        return null;\n      }\n\n      return prepComponentData(this.bundle, existingMetas2, opts);\n    };\n\n    if (this.opts.alwaysFresh) {\n      // If alwaysFresh, then we treat all specs as missing\n      return await returnWithSpecsToFetch(specs);\n    }\n\n    // Else we only fetch actually missing specs\n    const { found: existingMetas, missing: missingSpecs } =\n      this.maybeGetCompMetas(...specs);\n    if (missingSpecs.length === 0) {\n      return prepComponentData(this.bundle, existingMetas, opts);\n    }\n\n    return await returnWithSpecsToFetch(missingSpecs);\n  }\n\n  async fetchComponentData(\n    specs: ComponentLookupSpec[],\n    opts?: FetchComponentDataOpts\n  ): Promise<ComponentRenderData>;\n  async fetchComponentData(\n    ...specs: ComponentLookupSpec[]\n  ): Promise<ComponentRenderData>;\n  async fetchComponentData(...args: any[]): Promise<ComponentRenderData> {\n    const { specs, opts } = parseFetchComponentDataArgs(...args);\n    const data = await this.maybeFetchComponentData(specs, opts);\n\n    if (!data) {\n      const { missing: missingSpecs } = this.maybeGetCompMetas(...specs);\n      throw new Error(\n        `Unable to find components ${missingSpecs\n          .map(getLookupSpecName)\n          .join(\", \")}`\n      );\n    }\n\n    return data;\n  }\n\n  async fetchPages(opts?: FetchPagesOpts) {\n    this.maybeReportClientSideFetch(\n      () => `Plasmic: fetching all page metadata in the browser`\n    );\n    const data = await this.fetchAllData();\n    return data.components.filter(\n      (comp) =>\n        comp.isPage &&\n        comp.path &&\n        (opts?.includeDynamicPages || !isDynamicPagePath(comp.path))\n    ) as PageMeta[];\n  }\n\n  async fetchComponents() {\n    this.maybeReportClientSideFetch(\n      () => `Plasmic: fetching all component metadata in the browser`\n    );\n    const data = await this.fetchAllData();\n    return data.components;\n  }\n\n  getActiveSplits() {\n    return this.bundle.activeSplits;\n  }\n\n  getChunksUrl(bundle: LoaderBundleOutput, modules: CodeModule[]) {\n    return this.fetcher.getChunksUrl(bundle, modules);\n  }\n\n  private async fetchMissingData(opts: {\n    missingSpecs: ComponentLookupSpec[];\n  }) {\n    // TODO: do better than just fetching everything\n    this.maybeReportClientSideFetch(\n      () =>\n        `Plasmic: fetching missing components in the browser: ${opts.missingSpecs\n          .map((spec) => getLookupSpecName(spec))\n          .join(\", \")}`\n    );\n    return this.fetchAllData();\n  }\n\n  private maybeReportClientSideFetch(mkMsg: () => string) {\n    if (isBrowser && this.opts.onClientSideFetch) {\n      const msg = mkMsg();\n      if (this.opts.onClientSideFetch === \"warn\") {\n        console.warn(msg);\n      } else {\n        throw new Error(msg);\n      }\n    }\n  }\n\n  private async fetchAllData() {\n    const bundle = await this.fetcher.fetchAllData();\n    this.tracker.trackFetch();\n    this.mergeBundle(bundle);\n    this.onBundleFetched?.();\n    return bundle;\n  }\n\n  mergeBundle(newBundle: LoaderBundleOutput) {\n    newBundle.bundleKey = newBundle.bundleKey ?? null;\n    if (\n      newBundle.bundleKey &&\n      this.bundle.bundleKey &&\n      newBundle.bundleKey !== this.bundle.bundleKey\n    ) {\n      console.warn(\n        `Plasmic Error: Different code export hashes. This can happen if your app is using different loaders with different project IDs or project versions.\nConflicting values:\n${newBundle.bundleKey}\n${this.bundle.bundleKey}`\n      );\n    }\n    // Merge the old bundle into the new bundle, this way\n    // the new bundle will enforce the latest data from the server\n    // allowing elements to be deleted by newer bundles\n    this.bundle = mergeBundles(newBundle, this.bundle);\n\n    this.onBundleMerged?.();\n  }\n\n  getBundle(): LoaderBundleOutput {\n    return this.bundle;\n  }\n\n  clearCache() {\n    this.bundle = {\n      modules: {\n        browser: [],\n        server: [],\n      },\n      components: [],\n      globalGroups: [],\n      projects: [],\n      activeSplits: [],\n      bundleKey: null,\n      deferChunksByDefault: false,\n      disableRootLoadingBoundaryByDefault: false,\n      filteredIds: {},\n    };\n    this.registry.clear();\n  }\n\n  registerModules(modules: Record<string, any>) {\n    if (\n      Object.keys(modules).some(\n        (name) => this.registry.getRegisteredModule(name) !== modules[name]\n      )\n    ) {\n      if (!this.registry.isEmpty()) {\n        console.warn(\n          \"Calling PlasmicComponentLoader.registerModules() after Plasmic component has rendered; starting over.\"\n        );\n        this.registry.clear();\n      }\n      for (const key of Object.keys(modules)) {\n        this.registry.register(key, modules[key]);\n      }\n    }\n  }\n\n  substituteComponent<P>(\n    component: React.ComponentType<P>,\n    name: ComponentLookupSpec\n  ) {\n    this.internalSubstituteComponent(component, name, undefined);\n  }\n\n  protected internalSubstituteComponent<P>(\n    component: React.ComponentType<P>,\n    name: ComponentLookupSpec,\n    codeComponentHelpers:\n      | InternalCodeComponentHelpers<\n          React.ComponentProps<React.ComponentType<P>>\n        >\n      | undefined\n  ) {\n    if (!this.isRegistryEmpty()) {\n      console.warn(\n        \"Calling PlasmicComponentLoader.registerSubstitution() after Plasmic component has rendered; starting over.\"\n      );\n      this.clearRegistry();\n    }\n    this.subs.push({ lookup: name, component, codeComponentHelpers });\n  }\n\n  abstract registerComponent<T extends React.ComponentType<any>>(\n    component: T,\n    meta: CodeComponentMeta<React.ComponentProps<T>>\n  ): void;\n  abstract registerFunction<F extends (...args: any[]) => any>(\n    fn: F,\n    meta: CustomFunctionMeta<F>\n  ): void;\n  abstract registerGlobalContext<T extends React.ComponentType<any>>(\n    context: T,\n    meta: GlobalContextMeta<React.ComponentProps<T>>\n  ): void;\n  abstract registerTrait(trait: string, meta: TraitMeta): void;\n  abstract registerToken(token: TokenRegistration): void;\n\n  protected refreshRegistry() {\n    // Once we have received data, we register components to\n    // substitute.  We had to wait for data to do this so\n    // that we can look up the right module name to substitute\n    // in component meta.\n    for (const sub of this.subs) {\n      const metas = getCompMetas(this.getBundle().components, sub.lookup);\n      metas.forEach((meta) => {\n        SUBSTITUTED_COMPONENTS[meta.id] = sub.component;\n        if (sub.codeComponentHelpers) {\n          REGISTERED_CODE_COMPONENT_HELPERS[meta.id] = sub.codeComponentHelpers;\n        }\n      });\n    }\n\n    this.registry.updateModules(this.getBundle());\n  }\n\n  isRegistryEmpty() {\n    return this.registry.isEmpty();\n  }\n\n  clearRegistry() {\n    this.registry.clear();\n  }\n\n  setGlobalVariants(globalVariants: GlobalVariantSpec[]) {\n    this.globalVariants = globalVariants;\n  }\n\n  getGlobalVariants() {\n    return this.globalVariants;\n  }\n\n  registerPrefetchedBundle(bundle: LoaderBundleOutput) {\n    // For React Server Components (Next.js 13+),\n    // we need to pass server modules in LoaderBundleOutput from Server Components to Client Components.\n    // We don't want to pass them via normal page props because that will be serialized to the browser.\n    // Instead, we pass the bundle (including the server modules) via the Node `global` variable.\n    //\n    // This is the code that reads the stored bundle and merges it back into the loader.\n    if (!isBrowser) {\n      // Check if we have a cached bundle on this Node server.\n      const cachedBundle = internal_getCachedBundleInNodeServer(this.opts);\n      if (cachedBundle) {\n        // If it's there, merge the cached bundle first.\n        this.mergeBundle(cachedBundle);\n      }\n    }\n    this.mergeBundle(bundle);\n  }\n\n  getLookup() {\n    return new ComponentLookup(this.getBundle(), this.registry);\n  }\n\n  trackConversion(value = 0) {\n    this.tracker.trackConversion(value);\n  }\n\n  public async getActiveVariation(\n    opts: Omit<Parameters<typeof getActiveVariation>[0], \"splits\">\n  ) {\n    await this.fetchComponents();\n    return getActiveVariation({\n      ...opts,\n      splits: this.getBundle().activeSplits,\n    });\n  }\n\n  public getTeamIds(): string[] {\n    return uniq(\n      this.getBundle()\n        .projects.map((p) =>\n          p.teamId ? `${p.teamId}${p.indirect ? \"@indirect\" : \"\"}` : null\n        )\n        .filter((x): x is string => !!x)\n    );\n  }\n\n  public getProjectIds(): string[] {\n    return uniq(\n      this.getBundle().projects.map(\n        (p) => `${p.id}${p.indirect ? \"@indirect\" : \"\"}`\n      )\n    );\n  }\n\n  public trackRender(opts?: TrackRenderOptions) {\n    this.tracker.trackRender(opts);\n  }\n\n  public loadServerQueriesModule(fileName: string) {\n    return this.registry.load(fileName);\n  }\n}\n\n/**\n * Library for fetching component data, and registering\n * custom components.\n */\nexport class PlasmicComponentLoader {\n  private __internal: BaseInternalPlasmicComponentLoader;\n\n  constructor(internal: BaseInternalPlasmicComponentLoader) {\n    this.__internal = internal;\n  }\n\n  /**\n   * Sets global variants to be used for all components.  Note that\n   * this is not reactive, and will not re-render all components\n   * already mounted; instead, it should be used to activate global\n   * variants that should always be activated for the lifetime of this\n   * app.  If you'd like to reactively change the global variants,\n   * you should specify them via <PlasmicRootProvider />\n   */\n  setGlobalVariants(globalVariants: GlobalVariantSpec[]) {\n    this.__internal.setGlobalVariants(globalVariants);\n  }\n\n  registerModules(modules: Record<string, any>) {\n    this.__internal.registerModules(modules);\n  }\n\n  /**\n   * Register custom components that should be swapped in for\n   * components defined in your project.  You can use this to\n   * swap in / substitute a Plasmic component with a \"real\" component.\n   */\n  substituteComponent<P>(\n    component: React.ComponentType<P>,\n    name: ComponentLookupSpec\n  ) {\n    this.__internal.substituteComponent(component, name);\n  }\n\n  /**\n   * Register code components to be used on Plasmic Editor.\n   */\n  registerComponent<T extends React.ComponentType<any>>(\n    component: T,\n    meta: CodeComponentMeta<React.ComponentProps<T>>\n  ): void;\n\n  /**\n   * [[deprecated]] Please use `substituteComponent` instead for component\n   * substitution, or the other `registerComponent` overload to register\n   * code components to be used on Plasmic Editor.\n   *\n   * @see `substituteComponent`\n   */\n  registerComponent<T extends React.ComponentType<any>>(\n    component: T,\n    name: ComponentLookupSpec\n  ): void;\n\n  registerComponent<T extends React.ComponentType<any>>(\n    component: T,\n    metaOrName: ComponentLookupSpec | CodeComponentMeta<React.ComponentProps<T>>\n  ) {\n    // 'props' is a required field in CodeComponentMeta\n    if (metaOrName && typeof metaOrName === \"object\" && \"props\" in metaOrName) {\n      this.__internal.registerComponent(component, metaOrName);\n    } else {\n      // Deprecated call\n      if (\n        process.env.NODE_ENV === \"development\" &&\n        !this.warnedRegisterComponent\n      ) {\n        console.warn(\n          `PlasmicLoader: Using deprecated method \\`registerComponent\\` for component substitution. ` +\n            `Please consider using \\`substituteComponent\\` instead.`\n        );\n        this.warnedRegisterComponent = true;\n      }\n      this.substituteComponent(component, metaOrName);\n    }\n  }\n  private warnedRegisterComponent = false;\n\n  registerFunction<F extends (...args: any[]) => any>(\n    fn: F,\n    meta: CustomFunctionMeta<F>\n  ) {\n    this.__internal.registerFunction(fn, meta);\n  }\n\n  registerGlobalContext<T extends React.ComponentType<any>>(\n    context: T,\n    meta: GlobalContextMeta<React.ComponentProps<T>>\n  ) {\n    this.__internal.registerGlobalContext(context, meta);\n  }\n\n  registerTrait(trait: string, meta: TraitMeta) {\n    this.__internal.registerTrait(trait, meta);\n  }\n\n  registerToken(token: TokenRegistration) {\n    this.__internal.registerToken(token);\n  }\n\n  /**\n   * Pre-fetches component data needed to for PlasmicLoader to render\n   * these components.  Should be passed into PlasmicRootProvider as\n   * the prefetchedData prop.\n   *\n   * You can look up a component either by:\n   * - the name of the component\n   * - the path for a page component\n   * - an array of strings that make up parts of the path\n   * - object { name: \"name_or_path\", projectId: ...}, to specify which project\n   *   to use, if multiple projects have the same component name\n   *\n   * Throws an Error if a specified component to fetch does not exist in\n   * the Plasmic project.\n   */\n  fetchComponentData(\n    ...specs: ComponentLookupSpec[]\n  ): Promise<ComponentRenderData>;\n  fetchComponentData(\n    specs: ComponentLookupSpec[],\n    opts?: FetchComponentDataOpts\n  ): Promise<ComponentRenderData>;\n  fetchComponentData(...args: any[]): Promise<ComponentRenderData> {\n    return this.__internal.fetchComponentData(...args);\n  }\n\n  /**\n   * Like fetchComponentData(), but returns null instead of throwing an Error\n   * when a component is not found.  Useful when you are implementing a catch-all\n   * page and want to check if a specific path had been defined for Plasmic.\n   */\n  async maybeFetchComponentData(\n    ...specs: ComponentLookupSpec[]\n  ): Promise<ComponentRenderData | null>;\n  async maybeFetchComponentData(\n    specs: ComponentLookupSpec[],\n    opts?: FetchComponentDataOpts\n  ): Promise<ComponentRenderData | null>;\n  async maybeFetchComponentData(\n    ...args: any[]\n  ): Promise<ComponentRenderData | null> {\n    return this.__internal.maybeFetchComponentData(...args);\n  }\n\n  /**\n   * Returns all the page component metadata for these projects.\n   */\n  async fetchPages(opts?: FetchPagesOpts) {\n    return this.__internal.fetchPages(opts);\n  }\n\n  /**\n   * Returns all components metadata for these projects.\n   */\n  async fetchComponents() {\n    return this.__internal.fetchComponents();\n  }\n\n  protected async _getActiveVariation(\n    opts: Parameters<typeof this.__internal.getActiveVariation>[0]\n  ) {\n    return this.__internal.getActiveVariation(opts);\n  }\n\n  async getActiveVariation(opts: {\n    known?: Record<string, string>;\n    traits: Record<string, string | number | boolean>;\n  }) {\n    return this._getActiveVariation({\n      traits: opts.traits,\n      getKnownValue: (key: string) => {\n        if (opts.known) {\n          return opts.known[key];\n        } else {\n          const cookies = getPlasmicCookieValues();\n          return cookies[key];\n        }\n      },\n      updateKnownValue: (key: string, value: string) => {\n        if (!opts.known) {\n          updatePlasmicCookieValue(key, value);\n        }\n      },\n    });\n  }\n\n  getChunksUrl(bundle: LoaderBundleOutput, modules: CodeModule[]) {\n    return this.__internal.getChunksUrl(bundle, modules);\n  }\n\n  getExternalVariation(\n    variation: Record<string, string>,\n    filters?: Parameters<typeof getExternalIds>[2]\n  ) {\n    return getExternalIds(this.getActiveSplits(), variation, filters);\n  }\n\n  getActiveSplits() {\n    return this.__internal.getActiveSplits();\n  }\n\n  trackConversion(value = 0) {\n    this.__internal.trackConversion(value);\n  }\n\n  clearCache() {\n    return this.__internal.clearCache();\n  }\n\n  async unstable__getServerQueriesData(\n    renderData: ComponentRenderData,\n    $ctx: Record<string, any>\n  ) {\n    if (renderData.entryCompMetas.length === 0) {\n      return {};\n    }\n\n    const fileName = renderData.entryCompMetas[0].serverQueriesExecFuncFileName;\n\n    if (!fileName) {\n      return {};\n    }\n\n    const module = this.__internal.loadServerQueriesModule(fileName);\n    const { executeServerQueries } = module;\n\n    try {\n      const $serverQueries = await executeServerQueries($ctx);\n      return $serverQueries;\n    } catch (err) {\n      console.error(\"Error executing server queries function\", err);\n      return {};\n    }\n  }\n}\n", "import {\n  ComponentMeta,\n  getBundleSubset,\n  LoaderBundleOutput,\n} from \"@plasmicapp/loader-core\";\nimport type { ComponentRenderData } from \"./loader-shared\";\nimport { intersect } from \"./utils\";\n\nfunction getUsedComps(allComponents: ComponentMeta[], entryCompIds: string[]) {\n  const q: string[] = [...entryCompIds];\n  const seenIds = new Set<string>(entryCompIds);\n  const componentMetaById = new Map<string, ComponentMeta>(\n    allComponents.map((meta) => [meta.id, meta])\n  );\n  const usedComps: ComponentMeta[] = [];\n  while (q.length > 0) {\n    const [id] = q.splice(0, 1);\n    const meta = componentMetaById.get(id);\n    if (!meta) {\n      continue;\n    }\n    usedComps.push(meta);\n    meta.usedComponents.forEach((usedCompId) => {\n      if (!seenIds.has(usedCompId)) {\n        seenIds.add(usedCompId);\n        q.push(usedCompId);\n      }\n    });\n  }\n  return usedComps;\n}\n\nexport function prepComponentData(\n  bundle: LoaderBundleOutput,\n  compMetas: ComponentMeta[],\n  opts?: {\n    target?: \"browser\" | \"server\";\n  }\n): ComponentRenderData {\n  if (compMetas.length === 0) {\n    return {\n      entryCompMetas: bundle.components,\n      bundle: bundle,\n      remoteFontUrls: [],\n    };\n  }\n\n  const usedComps = getUsedComps(\n    bundle.components,\n    compMetas.map((compMeta) => compMeta.id)\n  );\n  const compPaths = usedComps.map((compMeta) => compMeta.entry);\n  const subBundle = getBundleSubset(\n    bundle,\n    [\n      \"entrypoint.css\",\n      ...compPaths,\n      \"root-provider.js\",\n      ...bundle.projects\n        .map((x) => x.globalContextsProviderFileName)\n        .filter((x) => !!x),\n      // We need to explicitly include global context provider components\n      // to make sure they are kept in bundle.components. That's because\n      // for esbuild, just the globalContextsProviderFileName is not enough,\n      // because it will import a chunk that includes the global context\n      // component, instead of importing that global context component's\n      // entry file. And because nothing depends on the global context component's\n      // entry file, we end up excluding the global context component from\n      // bundle.components, which then makes its substitution not work.\n      // Instead, we forcibly include it here (we'll definitely need it anyway!).\n      ...bundle.components\n        .filter((c) => c.isGlobalContextProvider)\n        .map((c) => c.entry),\n      ...bundle.globalGroups.map((g) => g.contextFile),\n    ],\n    opts\n  );\n\n  const remoteFontUrls: string[] = [];\n  subBundle.projects.forEach((p) =>\n    remoteFontUrls.push(...p.remoteFonts.map((f) => f.url))\n  );\n\n  return {\n    entryCompMetas: compMetas,\n    bundle: subBundle,\n    remoteFontUrls,\n  };\n}\n\n// It's important to deep clone any attributes that are going to be changed in the\n// target bundle, since the build of pages can be done in multiple stages/processes\n// we don't want to mutate the original bundle, which can impact other pages.\nexport function mergeBundles(\n  target: LoaderBundleOutput,\n  from: LoaderBundleOutput\n) {\n  const existingProjects = new Set(target.projects.map((p) => p.id));\n  const newProjects = from.projects.filter((p) => !existingProjects.has(p.id));\n  if (newProjects.length > 0) {\n    target = {\n      ...target,\n      projects: [...target.projects, ...newProjects],\n    };\n  }\n\n  const existingCompIds = new Set(target.components.map((c) => c.id));\n\n  function shouldIncludeComponentInBundle(c: ComponentMeta) {\n    // If the component is already present in the target bundle, don't include it\n    if (existingCompIds.has(c.id)) {\n      return false;\n    }\n    // If the component belongs to a project that is not present in the target bundle,\n    // include it\n    if (!existingProjects.has(c.projectId)) {\n      return true;\n    }\n    // If the component is present in the filteredIds of the project it belongs to,\n    // in the target bundle, we consider that the component was not deleted in the target\n    // bundle, so we can include it\n    const targetBundleFilteredIds = target.filteredIds[c.projectId] ?? [];\n    return targetBundleFilteredIds.includes(c.id);\n  }\n\n  const newCompMetas = from.components.filter((m) =>\n    shouldIncludeComponentInBundle(m)\n  );\n  if (newCompMetas.length > 0) {\n    target = {\n      ...target,\n      components: [...target.components, ...newCompMetas],\n    };\n\n    // Deep clone the filteredIds object to avoid mutating the original bundle\n    target.filteredIds = Object.fromEntries(\n      Object.entries(target.filteredIds).map(([k, v]) => [k, [...v]])\n    );\n\n    from.projects.forEach((fromProject) => {\n      const projectId = fromProject.id;\n      const fromBundleFilteredIds = from.filteredIds[projectId] ?? [];\n      if (!existingProjects.has(projectId)) {\n        target.filteredIds[projectId] = [...fromBundleFilteredIds];\n      } else {\n        target.filteredIds[projectId] = intersect(\n          target.filteredIds[projectId] ?? [],\n          fromBundleFilteredIds\n        );\n      }\n    });\n  }\n\n  const existingModules = {\n    browser: new Set(target.modules.browser.map((m) => m.fileName)),\n    server: new Set(target.modules.server.map((m) => m.fileName)),\n  };\n  const newModules = {\n    browser: from.modules.browser.filter(\n      (m) => !existingModules.browser.has(m.fileName)\n    ),\n    server: from.modules.server.filter(\n      (m) => !existingModules.server.has(m.fileName)\n    ),\n  };\n  if (newModules.browser.length > 0 || newModules.server.length > 0) {\n    target = {\n      ...target,\n      modules: {\n        browser: [...target.modules.browser, ...newModules.browser],\n        server: [...target.modules.server, ...newModules.server],\n      },\n    };\n  }\n\n  const existingGlobalIds = new Set(target.globalGroups.map((g) => g.id));\n  const newGlobals = from.globalGroups.filter(\n    (g) => !existingGlobalIds.has(g.id)\n  );\n  if (newGlobals.length > 0) {\n    target = {\n      ...target,\n      globalGroups: [...target.globalGroups, ...newGlobals],\n    };\n  }\n\n  const existingSplitIds = new Set(target.activeSplits.map((s) => s.id));\n  const newSplits =\n    from.activeSplits.filter(\n      // Don't include splits belonging to projects already present\n      // in the target bundle\n      (s) => !existingSplitIds.has(s.id) && !existingProjects.has(s.projectId)\n    ) ?? [];\n  if (newSplits.length > 0) {\n    target = {\n      ...target,\n      activeSplits: [...target.activeSplits, ...newSplits],\n    };\n  }\n\n  // Avoid `undefined` as it cannot be serialized as JSON\n  target.bundleKey = target.bundleKey ?? from.bundleKey ?? null;\n  target.deferChunksByDefault =\n    target.deferChunksByDefault ?? from.deferChunksByDefault ?? false;\n\n  target.disableRootLoadingBoundaryByDefault =\n    target.disableRootLoadingBoundaryByDefault ??\n    from.disableRootLoadingBoundaryByDefault ??\n    false;\n\n  return target;\n}\n\nexport const convertBundlesToComponentRenderData = (\n  bundles: LoaderBundleOutput[],\n  compMetas: ComponentMeta[]\n): ComponentRenderData | null => {\n  if (bundles.length === 0) {\n    return null;\n  }\n\n  const mergedBundles = bundles.reduce((prev, cur) => mergeBundles(prev, cur));\n  return prepComponentData(mergedBundles, compMetas);\n};\n", "import { ComponentMeta } from \"@plasmicapp/loader-core\";\nimport pascalcase from \"pascalcase\";\nimport * as React from \"react\";\n\nexport const isBrowser = typeof window !== \"undefined\";\n\nexport type ComponentLookupSpec =\n  | string\n  | { name: string; projectId?: string; isCode?: boolean };\n\ninterface FullNameLookupSpec {\n  name: string;\n  rawName?: string;\n  projectId?: string;\n  isCode?: boolean;\n}\n\ninterface FullPathLookupSpec {\n  path: string;\n  projectId?: string;\n}\n\ntype FullLookupSpec = FullNameLookupSpec | FullPathLookupSpec;\n\nexport function useForceUpdate() {\n  const [, setTick] = React.useState(0);\n  const update = React.useCallback(() => {\n    setTick((tick) => tick + 1);\n  }, []);\n  return update;\n}\n\nexport function useStableLookupSpec(spec: ComponentLookupSpec) {\n  return useStableLookupSpecs(spec)[0];\n}\n\nexport function useStableLookupSpecs(...specs: ComponentLookupSpec[]) {\n  const [stableSpecs, setStableSpecs] = React.useState(specs);\n\n  React.useEffect(() => {\n    if (\n      specs.length !== stableSpecs.length ||\n      specs.some((s, i) => !areLookupSpecsEqual(s, stableSpecs[i]))\n    ) {\n      setStableSpecs(specs);\n    }\n  }, [specs, stableSpecs]);\n  return stableSpecs;\n}\n\nfunction areLookupSpecsEqual(\n  spec1: ComponentLookupSpec,\n  spec2: ComponentLookupSpec\n) {\n  if (spec1 === spec2) {\n    return true;\n  }\n  if (typeof spec1 !== typeof spec2) {\n    return false;\n  }\n\n  const fullSpec1 = toFullLookup(spec1);\n  const fullSpec2 = toFullLookup(spec2);\n  return (\n    ((isNameSpec(fullSpec1) &&\n      isNameSpec(fullSpec2) &&\n      fullSpec1.name === fullSpec2.name &&\n      fullSpec1.isCode === fullSpec2.isCode) ||\n      (isPathSpec(fullSpec1) &&\n        isPathSpec(fullSpec2) &&\n        fullSpec1.path === fullSpec2.path)) &&\n    fullSpec1.projectId === fullSpec2.projectId\n  );\n}\n\nfunction isNameSpec(lookup: FullLookupSpec): lookup is FullNameLookupSpec {\n  return \"name\" in lookup;\n}\n\nfunction isPathSpec(lookup: FullLookupSpec): lookup is FullPathLookupSpec {\n  return \"path\" in lookup;\n}\n\nfunction toFullLookup(lookup: ComponentLookupSpec): FullLookupSpec {\n  const namePart = typeof lookup === \"string\" ? lookup : lookup.name;\n  const projectId = typeof lookup === \"string\" ? undefined : lookup.projectId;\n  const codeComponent = typeof lookup === \"string\" ? undefined : lookup.isCode;\n\n  if (codeComponent !== true && namePart.startsWith(\"/\")) {\n    return { path: normalizePath(namePart), projectId };\n  } else {\n    return {\n      name: codeComponent ? namePart : normalizeName(namePart),\n      rawName: namePart.trim(),\n      projectId,\n      isCode: codeComponent,\n    };\n  }\n}\n\nfunction normalizePath(path: string) {\n  return path.trim();\n}\n\nfunction normalizeName(name: string) {\n  // Not a full normalization, but should be good enough\n  return pascalcase(name).trim();\n}\n\nexport function useIsMounted(): () => boolean {\n  const ref = React.useRef<boolean>(false);\n  const isMounted = React.useCallback(() => ref.current, []);\n\n  React.useEffect(() => {\n    ref.current = true;\n    return () => {\n      ref.current = false;\n    };\n  }, []);\n\n  return isMounted;\n}\n\n/**\n * Check if `lookup` resolves to `pagePath`. If it's a match, return an object\n * containing path params; otherwise, return false.\n *\n * For example,\n * - `matchesPagePath(\"/hello/[name]\", \"/hello/world\")` -> `{params: {name:\n *   \"world\"}}`\n * - `matchesPagePath(\"/hello/[name]\", \"/\")` -> `false`\n * - `matchesPagePath(\"/hello/[...catchall]\", \"/hello/a/b/c\")` -> `{params: {catchall: [\"a\", \"b\", \"c\"]}}`\n * - `matchesPagePath(\"/hello/[[...catchall]]\", \"/hello/\")` -> `{params: {catchall: []}}`\n * - `matchesPagePath(\"/\", \"\")` -> `{params: {}}`\n */\nexport function matchesPagePath(pattern: string, path: string) {\n  // (generated by ChatGPT 4 from the test cases)\n\n  // Normalize the path and pattern by ensuring they both start and end without slashes\n  const normalizedPattern = \"/\" + pattern.replace(/^\\/|\\/$/g, \"\");\n  const normalizedPath = \"/\" + path.replace(/^\\/|\\/$/g, \"\");\n\n  // Modify the regex to match optional leading slashes\n  const regexString = normalizedPattern\n    .replace(/\\/\\[\\[\\.\\.\\.([^\\]^]+)]]/g, \"(?:/([^]*))?\") // Optional catch-all\n    .replace(/\\/\\[\\.\\.\\.([^\\]^]+)]/g, \"/([^]*)\") // Catch-all\n    .replace(/\\[([^\\]^]+)]/g, \"([^/]+)\") // Normal slug\n    .replace(/\\//g, \"\\\\/\"); // Escape forward slashes\n\n  const regex = new RegExp(`^/?${regexString}$`); // Allow optional leading slash\n  const match = normalizedPath.match(regex);\n\n  if (!match) return false;\n\n  // Extract slug names from pattern\n  const slugNames = [...pattern.matchAll(/\\[\\.?\\.?\\.?([^[\\]]+)]/g)].map(\n    (m) => m[1]\n  );\n\n  // Construct params object\n  const params: Record<string, string | string[]> = {};\n  for (let i = 0; i < slugNames.length; i++) {\n    const slugName = slugNames[i];\n    const value = match[i + 1];\n\n    if (pattern.includes(`[[...${slugName}]]`)) {\n      // Handle optional catchall slugs\n      params[slugName] = value ? value.split(\"/\").filter(Boolean) : [];\n    } else if (pattern.includes(`[...${slugName}]`)) {\n      // Handle mandatory catchall slugs\n      params[slugName] = value.split(\"/\").filter(Boolean);\n    } else if (value !== undefined) {\n      // Handle normal slugs\n      params[slugName] = value;\n    }\n  }\n\n  return { params };\n}\n\nexport function isDynamicPagePath(path: string): boolean {\n  return !!path.match(/\\[[^/]*\\]/);\n}\n\nfunction matchesCompMeta(lookup: FullLookupSpec, meta: ComponentMeta) {\n  if (lookup.projectId && meta.projectId !== lookup.projectId) {\n    return false;\n  }\n\n  return isNameSpec(lookup)\n    ? (lookup.name === meta.name ||\n        lookup.rawName === meta.name ||\n        lookup.rawName === meta.displayName) &&\n        (lookup.isCode == null || lookup.isCode === meta.isCode)\n    : !!(meta.path && matchesPagePath(meta.path, lookup.path));\n}\n\nexport function getCompMetas(\n  metas: ComponentMeta[],\n  lookup: ComponentLookupSpec\n) {\n  const full = toFullLookup(lookup);\n  return metas\n    .filter((meta) => matchesCompMeta(full, meta))\n    .map<ComponentMeta & { params?: Record<string, string | string[]> }>(\n      (meta) => {\n        if (isNameSpec(full) || !meta.path) {\n          return meta;\n        }\n\n        const match = matchesPagePath(meta.path, full.path);\n        if (!match) {\n          return meta;\n        }\n\n        return { ...meta, params: match.params };\n      }\n    )\n    .sort(\n      (meta1, meta2) =>\n        // We sort the matched component metas by the number of path params, so\n        // if there are two pages `/products/foo` and `/products/[slug]`,\n        // the first one will have higher precedence.\n        Array.from(Object.keys(meta1.params || {})).length -\n        Array.from(Object.keys(meta2.params || {})).length\n    );\n}\n\nexport function getLookupSpecName(lookup: ComponentLookupSpec) {\n  if (typeof lookup === \"string\") {\n    return lookup;\n  } else if (lookup.projectId) {\n    return `${lookup.name} (project ${lookup.projectId})`;\n  } else {\n    return lookup.name;\n  }\n}\n\nexport function MaybeWrap(props: {\n  children: React.ReactNode;\n  cond: boolean;\n  wrapper: (children: React.ReactNode) => React.ReactElement;\n}) {\n  return (\n    props.cond ? props.wrapper(props.children) : props.children\n  ) as React.ReactElement;\n}\n\nexport function uniq<T>(elements: T[]): T[] {\n  return Array.from(new Set(elements));\n}\n\nexport function uniqBy<T, K>(elements: T[], iterator: (elt: T) => K): T[] {\n  const vis = new Set<K>();\n  const filtered: T[] = [];\n  for (const elt of elements) {\n    const key = iterator(elt);\n    if (!vis.has(key)) {\n      vis.add(key);\n      filtered.push(elt);\n    }\n  }\n  return filtered;\n}\n\nexport function intersect<T>(a: T[], b: T[]): T[] {\n  const setB = new Set(b);\n  return a.filter((elt) => setB.has(elt));\n}\n", "import {\n  AssetModule,\n  ComponentMeta,\n  FontMeta,\n  GlobalGroupMeta,\n  LoaderBundleOutput,\n  Registry,\n} from '@plasmicapp/loader-core';\nimport * as React from 'react';\nimport { ComponentLookupSpec, getCompMetas } from './utils';\n\nfunction getFirstCompMeta(metas: ComponentMeta[], lookup: ComponentLookupSpec) {\n  const filtered = getCompMetas(metas, lookup);\n  return filtered.length === 0 ? undefined : filtered[0];\n}\n\nexport class ComponentLookup {\n  constructor(private bundle: LoaderBundleOutput, private registry: Registry) {}\n\n  getComponentMeta(spec: ComponentLookupSpec): ComponentMeta | undefined {\n    const compMeta = getFirstCompMeta(this.bundle.components, spec);\n    return compMeta;\n  }\n\n  getComponent<P extends React.ComponentType = any>(\n    spec: ComponentLookupSpec,\n    opts: { forceOriginal?: boolean } = {}\n  ) {\n    const compMeta = getFirstCompMeta(this.bundle.components, spec);\n    if (!compMeta) {\n      throw new Error(`Component not found: ${spec}`);\n    }\n    const moduleName = compMeta.entry;\n    if (!this.registry.hasModule(moduleName, opts)) {\n      throw new Error(`Component not yet fetched: ${compMeta.name}`);\n    }\n    const entry = this.registry.load(moduleName, {\n      forceOriginal: opts.forceOriginal,\n    });\n    return !opts.forceOriginal &&\n      typeof entry?.getPlasmicComponent === 'function'\n      ? entry.getPlasmicComponent()\n      : (entry.default as P);\n  }\n\n  hasComponent(spec: ComponentLookupSpec) {\n    const compMeta = getFirstCompMeta(this.bundle.components, spec);\n    if (compMeta) {\n      return this.registry.hasModule(compMeta.entry);\n    }\n    return false;\n  }\n\n  getGlobalContexts(): { meta: GlobalGroupMeta; context: any }[] {\n    const customGlobalMetas = this.bundle.globalGroups.filter(\n      (m) => m.type === 'global-user-defined'\n    );\n    return customGlobalMetas.map((meta) => ({\n      meta,\n      context: this.registry.load(meta.contextFile).default,\n    }));\n  }\n\n  getGlobalContextsProvider(spec: ComponentLookupSpec) {\n    const compMeta = getFirstCompMeta(this.bundle.components, spec);\n    const projectMeta = compMeta\n      ? this.bundle.projects.find((x) => x.id === compMeta.projectId)\n      : undefined;\n\n    if (\n      !projectMeta ||\n      !projectMeta.globalContextsProviderFileName ||\n      !this.registry.hasModule(projectMeta.globalContextsProviderFileName)\n    ) {\n      return undefined;\n    }\n    const entry = this.registry.load(\n      projectMeta.globalContextsProviderFileName\n    );\n\n    return typeof entry?.getPlasmicComponent === 'function'\n      ? entry.getPlasmicComponent()\n      : entry.default;\n  }\n\n  getRootProvider() {\n    const entry = this.registry.load('root-provider.js');\n    return entry.default;\n  }\n\n  getCss(): AssetModule[] {\n    // We can probably always get the modules from the browser build\n    return this.bundle.modules.browser.filter(\n      (mod) => mod.type === 'asset' && mod.fileName.endsWith('css')\n    ) as AssetModule[];\n  }\n\n  getRemoteFonts(): FontMeta[] {\n    return this.bundle.projects.flatMap((p) => p.remoteFonts);\n  }\n}\n", "import type {\n  ExperimentSlice,\n  SegmentSlice,\n  Split,\n} from \"@plasmicapp/loader-core\";\nimport type { GlobalVariantSpec } from \"./PlasmicRootProvider\";\n\nexport function getPlasmicCookieValues() {\n  return Object.fromEntries(\n    document.cookie\n      .split(\"; \")\n      .filter((cookie) => cookie.includes(\"plasmic:\"))\n      .map((cookie) => cookie.split(\"=\"))\n      .map(([key, value]) => [key.split(\":\")[1], value])\n  );\n}\n\nexport function updatePlasmicCookieValue(key: string, value: string) {\n  document.cookie = `plasmic:${key}=${value}`;\n}\n\nexport const getGlobalVariantsFromSplits = (\n  splits: Split[],\n  variation: Record<string, string>\n) => {\n  const globalVariants: GlobalVariantSpec[] = [];\n\n  Object.keys(variation).map((variationKey: string) => {\n    const [_type, splitId] = variationKey.split(\".\");\n    const sliceId = variation[variationKey];\n    const split = splits.find(\n      (s) => s.id === splitId || s.externalId === splitId\n    );\n    if (split) {\n      const slice: ExperimentSlice | SegmentSlice | undefined = (\n        split.slices as Array<ExperimentSlice | SegmentSlice>\n      ).find((s: any) => s.id === sliceId || s.externalId === sliceId);\n      if (slice) {\n        slice.contents.map((x) => {\n          globalVariants.push({\n            name: x.group,\n            value: x.variant,\n            projectId: x.projectId,\n          });\n        });\n      }\n    }\n  });\n\n  return globalVariants;\n};\n\nexport const mergeGlobalVariantsSpec = (\n  target: GlobalVariantSpec[],\n  from: GlobalVariantSpec[]\n) => {\n  let result = [...target];\n  const existingGlobalVariants = new Set(\n    target.map((t) => `${t.name}-${t.projectId ?? \"\"}`)\n  );\n  const newGlobals = from.filter(\n    (t) => !existingGlobalVariants.has(`${t.name}-${t.projectId ?? \"\"}`)\n  );\n\n  if (newGlobals.length > 0) {\n    result = [...result, ...newGlobals];\n  }\n\n  return result;\n};\n", "import type { useMutablePlasmicQueryData } from \"@plasmicapp/query\";\n\n/**\n * It's not possible to `import { serialize } from \"swr\"` from RSC, as it\n * triggers \"`createContext` is not a function\" error :/\n *\n * So here we replicate the key serialization in order to generate the\n * appropriate cache key within data extraction.\n */\nexport function swrSerialize(\n  key: Parameters<typeof useMutablePlasmicQueryData>[0]\n): [string | null | undefined | false, any[]] {\n  if (typeof key === \"function\") {\n    try {\n      key = key();\n    } catch (err) {\n      // dependencies not ready\n      key = \"\";\n    }\n  }\n  const args = [].concat(key as any);\n  // If key is not falsy, or not an empty array, hash it.\n  key =\n    typeof key == \"string\"\n      ? key\n      : (Array.isArray(key) ? key.length : key)\n      ? stableHash(key)\n      : \"\";\n  return [key as any, args];\n}\n\nconst table = new WeakMap();\nlet counter = 0;\n\nfunction stableHash(arg: any) {\n  const type = typeof arg;\n  const constructor = arg && arg.constructor;\n  const isDate = constructor == Date;\n  let result: any;\n  let index;\n  if (Object(arg) === arg && !isDate && constructor != RegExp) {\n    // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n    // If it's already hashed, directly return the result.\n    result = table.get(arg);\n    if (result) return result;\n    // Store the hash first for circular reference detection before entering the\n    // recursive `stableHash` calls.\n    // For other objects like set and map, we use this id directly as the hash.\n    result = ++counter + \"~\";\n    table.set(arg, result);\n    if (constructor == Array) {\n      // Array.\n      result = \"@\";\n      for (index = 0; index < arg.length; index++) {\n        result += stableHash(arg[index]) + \",\";\n      }\n      table.set(arg, result);\n    }\n    if (constructor == Object) {\n      // Object, sort keys.\n      result = \"#\";\n      const keys = Object.keys(arg).sort();\n      while ((index = keys.pop()) !== undefined) {\n        if (arg[index] !== undefined) {\n          result += index + \":\" + stableHash(arg[index]) + \",\";\n        }\n      }\n      table.set(arg, result);\n    }\n  } else {\n    result = isDate\n      ? arg.toJSON()\n      : type == \"symbol\"\n      ? arg.toString()\n      : type == \"string\"\n      ? JSON.stringify(arg)\n      : \"\" + arg;\n  }\n  return result;\n}\n", "import { extractPlasmicQueryData as internalExtractQueryData } from \"@plasmicapp/prepass\";\nimport {\n  handlePlasmicPrepassContext,\n  handlePrepassPlasmicComponent,\n  handlePrepassPlasmicRootComponent,\n} from \"./loader-server\";\nimport type { PlasmicComponentLoader } from \"./loader-shared\";\nimport type { PlasmicRootProvider } from \"./PlasmicRootProvider\";\n\n/**\n * Performs a prepass over Plasmic content, kicking off the necessary\n * data fetches, and populating the fetched data into a cache.  This\n * cache can be passed as prefetchedQueryData into PlasmicRootProvider.\n *\n * To limit rendering errors that can occur when you do this, we recommend\n * that you pass in _only_ the PlasmicComponents that you are planning to use\n * as the argument.  For example:\n *\n *   const cache = await extractPlasmicQueryData(\n *     <ClientPlasmicRootProvider prefetchedData={plasmicData}>\n *       <PlasmicComponent component=\"Home\" componentProps={{\n *         // Specify the component prop overrides you are planning to use\n *         // to render the page, as they may change what data is fetched.\n *         ...\n *       }} />\n *       <PlasmicComponent component=\"NavBar\" componentProps={{\n *         ...\n *       }} />\n *       ...\n *     </ClientPlasmicRootProvider>,\n *     PLASMIC\n *   );\n *\n * If your PlasmicComponent will be wrapping components that require special\n * context set up, you should also wrap the element above with those context\n * providers. Avoid, however, wrapping the root provider, because we inspect\n * the props passed to the root element.\n *\n * You should avoid passing in elements that are not related to Plasmic, as any\n * rendering errors from those elements during the prepass may result in data\n * not being populated in the cache.\n *\n * @param element a React element containing instances of PlasmicComponent.\n *   Will attempt to satisfy all data needs from usePlasmicDataQuery()\n *   in this element tree.\n * @returns an object mapping query key to fetched data\n */\nexport async function extractPlasmicQueryData(\n  element: React.ReactElement,\n  loader: PlasmicComponentLoader\n): Promise<Record<string, any>> {\n  return await internalExtractQueryData(element, (elt) =>\n    handleClientComponentRef(elt, loader, element)\n  );\n}\n\nfunction handleClientComponentRef(\n  elt: React.ReactElement,\n  loader: PlasmicComponentLoader,\n  rootElement: React.ReactElement\n) {\n  try {\n    const refId: string = (elt.type as any).$$id;\n    // We try to detect the root provider by name, as well as by comparing to\n    // the root element.\n    if (refId.includes(\"PlasmicRootProvider\") || elt === rootElement) {\n      const props: Parameters<typeof PlasmicRootProvider>[0] = elt.props as any;\n      if (props.prefetchedData) {\n        handlePrepassPlasmicRootComponent({ ...props, loader });\n      }\n      return;\n    } else if (\n      refId.includes(\"PlasmicComponent\") &&\n      elt.props?.component != null\n    ) {\n      return handlePrepassPlasmicComponent(elt.props);\n    } else if (\n      refId.includes(\"PlasmicPrepassContext\") &&\n      elt.props?.cache != null\n    ) {\n      return handlePlasmicPrepassContext(elt.props);\n    }\n  } catch (err) {\n    console.warn(\"Error processing client reference: \", err);\n  }\n  return;\n}\n"],
  "mappings": "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",
  "names": ["import_loader_core", "import_loader_core", "pascalcase", "_a", "_b", "_a", "_a", "module", "_a", "React", "ReactDOM", "internalExtractQueryData", "_a"]
}
