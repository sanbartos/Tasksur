{
  "version": 3,
  "sources": ["../src/index.ts", "../src/loader-client.ts", "../src/PlasmicRootProvider.tsx", "../src/utils.tsx", "../src/variation.ts", "../src/global-variants.ts", "../src/loader-shared.ts", "../src/bundles.ts", "../src/component-lookup.ts", "../src/PlasmicComponent.tsx", "../src/usePlasmicComponent.tsx", "../src/prepass-client.ts", "../src/render.tsx"],
  "sourcesContent": ["import { InternalPlasmicComponentLoader } from \"./loader-client\";\nimport {\n  CodeComponentMeta,\n  CustomFunctionMeta,\n  FetchComponentDataOpts,\n  GlobalContextMeta,\n  InitOptions,\n  PlasmicComponentLoader,\n} from \"./loader-shared\";\n\nexport {\n  DataCtxReader,\n  DataProvider,\n  GlobalActionsContext,\n  GlobalActionsProvider,\n  PageParamsProvider,\n  PlasmicCanvasContext,\n  PlasmicCanvasHost,\n  PlasmicTranslatorContext,\n  repeatedElement,\n  useDataEnv,\n  usePlasmicCanvasComponentInfo,\n  usePlasmicCanvasContext,\n  useSelector,\n  useSelectors,\n} from \"@plasmicapp/host\";\nexport type { PropType, TokenRegistration } from \"@plasmicapp/host\";\nexport { usePlasmicQueryData } from \"@plasmicapp/query\";\nexport { PlasmicComponent } from \"./PlasmicComponent\";\nexport { PlasmicRootProvider } from \"./PlasmicRootProvider\";\nexport type {\n  GlobalVariantSpec,\n  PlasmicTranslator,\n} from \"./PlasmicRootProvider\";\nexport { extractPlasmicQueryData, plasmicPrepass } from \"./prepass-client\";\nexport {\n  extractPlasmicQueryDataFromElement,\n  hydrateFromElement,\n  renderToElement,\n  renderToString,\n} from \"./render\";\nexport * from \"./shared-exports\";\nexport { usePlasmicComponent } from \"./usePlasmicComponent\";\nexport type { ComponentLookupSpec } from \"./utils\";\nexport { InternalPlasmicComponentLoader, PlasmicComponentLoader };\nexport type {\n  CodeComponentMeta,\n  CustomFunctionMeta,\n  FetchComponentDataOpts,\n  GlobalContextMeta,\n};\n\nexport function initPlasmicLoader(opts: InitOptions): PlasmicComponentLoader {\n  const internal = new InternalPlasmicComponentLoader(opts);\n  return new PlasmicComponentLoader(internal);\n}\n", "import * as PlasmicDataSourcesContext from \"@plasmicapp/data-sources-context\";\n// eslint-disable-next-line no-restricted-imports\nimport * as PlasmicHost from \"@plasmicapp/host\";\nimport {\n  // eslint-disable-next-line no-restricted-imports\n  registerComponent,\n  registerFunction,\n  registerGlobalContext,\n  registerToken,\n  registerTrait,\n  stateHelpersKeys,\n  TokenRegistration,\n  TraitMeta,\n} from \"@plasmicapp/host\";\nimport { PlasmicModulesFetcher, PlasmicTracker } from \"@plasmicapp/loader-core\";\nimport * as PlasmicQuery from \"@plasmicapp/query\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as jsxDevRuntime from \"react/jsx-dev-runtime\";\nimport * as jsxRuntime from \"react/jsx-runtime\";\nimport { createUseGlobalVariant } from \"./global-variants\";\nimport {\n  BaseInternalPlasmicComponentLoader,\n  CodeComponentMeta,\n  CustomFunctionMeta,\n  GlobalContextMeta,\n  InitOptions,\n  internalSetRegisteredFunction,\n  PlasmicRootWatcher,\n  REGISTERED_CODE_COMPONENT_HELPERS,\n  REGISTERED_CUSTOM_FUNCTIONS,\n  SUBSTITUTED_COMPONENTS,\n  SUBSTITUTED_GLOBAL_VARIANT_HOOKS,\n} from \"./loader-shared\";\n\nexport class InternalPlasmicComponentLoader extends BaseInternalPlasmicComponentLoader {\n  private readonly roots: PlasmicRootWatcher[] = [];\n\n  constructor(opts: InitOptions) {\n    const tracker = new PlasmicTracker({\n      ...opts,\n      projectIds: opts.projects.map((p) => p.id),\n    });\n    super({\n      opts,\n      tracker,\n      fetcher: new PlasmicModulesFetcher(opts),\n      onBundleMerged: () => {\n        this.refreshRegistry();\n      },\n      onBundleFetched: () => {\n        this.roots.forEach((watcher) => watcher.onDataFetched?.());\n      },\n      builtinModules: {\n        react: React,\n        \"react-dom\": ReactDOM,\n        \"react/jsx-runtime\": jsxRuntime,\n        \"react/jsx-dev-runtime\": jsxDevRuntime,\n\n        // Also inject @plasmicapp/query and @plasmicapp/host to use the\n        // same contexts here and in loader-downloaded code.\n        \"@plasmicapp/query\": PlasmicQuery,\n        \"@plasmicapp/data-sources-context\": PlasmicDataSourcesContext,\n        \"@plasmicapp/host\": PlasmicHost,\n        \"@plasmicapp/loader-runtime-registry\": {\n          components: SUBSTITUTED_COMPONENTS,\n          globalVariantHooks: SUBSTITUTED_GLOBAL_VARIANT_HOOKS,\n          codeComponentHelpers: REGISTERED_CODE_COMPONENT_HELPERS,\n          functions: REGISTERED_CUSTOM_FUNCTIONS,\n        },\n      },\n    });\n  }\n\n  registerComponent<T extends React.ComponentType<any>>(\n    component: T,\n    meta: CodeComponentMeta<React.ComponentProps<T>>\n  ) {\n    // making the component meta consistent between codegen and loader\n    const stateHelpers = Object.fromEntries(\n      Object.entries(meta.states ?? {})\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        .filter(([_, stateSpec]) =>\n          Object.keys(stateSpec).some((key) => stateHelpersKeys.includes(key))\n        )\n        .map(([stateName, stateSpec]) => [\n          stateName,\n          Object.fromEntries(\n            stateHelpersKeys\n              .filter((key) => key in stateSpec)\n              .map((key) => [key, stateSpec[key]])\n          ),\n        ])\n    );\n    const helpers = { states: stateHelpers };\n    this.internalSubstituteComponent(\n      component,\n      { name: meta.name, isCode: true },\n      Object.keys(stateHelpers).length > 0 ? helpers : undefined\n    );\n    registerComponent(component, {\n      ...meta,\n      // Import path is not used as we will use component substitution\n      importPath: meta.importPath ?? \"\",\n      ...(Object.keys(stateHelpers).length > 0\n        ? {\n            componentHelpers: {\n              helpers,\n              importPath: \"\",\n              importName: \"\",\n            },\n          }\n        : {}),\n    });\n  }\n\n  registerFunction<F extends (...args: any[]) => any>(\n    fn: F,\n    meta: CustomFunctionMeta<F>\n  ) {\n    registerFunction(fn, {\n      ...meta,\n      importPath: meta.importPath ?? \"\",\n    });\n    internalSetRegisteredFunction(fn, meta);\n  }\n\n  registerGlobalContext<T extends React.ComponentType<any>>(\n    context: T,\n    meta: GlobalContextMeta<React.ComponentProps<T>>\n  ) {\n    this.substituteComponent(context, { name: meta.name, isCode: true });\n    // Import path is not used as we will use component substitution\n    registerGlobalContext(context, {\n      ...meta,\n      importPath: meta.importPath ?? \"\",\n    });\n  }\n\n  registerTrait(trait: string, meta: TraitMeta) {\n    registerTrait(trait, meta);\n  }\n\n  registerToken(token: TokenRegistration) {\n    registerToken(token);\n  }\n\n  subscribePlasmicRoot(watcher: PlasmicRootWatcher) {\n    this.roots.push(watcher);\n  }\n\n  unsubscribePlasmicRoot(watcher: PlasmicRootWatcher) {\n    const index = this.roots.indexOf(watcher);\n    if (index >= 0) {\n      this.roots.splice(index, 1);\n    }\n  }\n\n  refreshRegistry() {\n    // We swap global variants' useXXXGlobalVariant() hook with\n    // a fake one that just reads from the PlasmicRootContext. Because\n    // global variant values are not supplied by the generated global variant\n    // context providers, but instead by <PlasmicRootProvider/> and by\n    // PlasmicComponentLoader.setGlobalVariants(), we redirect these\n    // hooks to read from them instead.\n    for (const globalGroup of this.getBundle().globalGroups) {\n      if (globalGroup.type !== \"global-screen\") {\n        SUBSTITUTED_GLOBAL_VARIANT_HOOKS[globalGroup.id] =\n          createUseGlobalVariant(globalGroup.name, globalGroup.projectId);\n      }\n    }\n    super.refreshRegistry();\n  }\n}\n", "import { PlasmicDataSourceContextValue } from \"@plasmicapp/data-sources-context\";\nimport { PageParamsProvider } from \"@plasmicapp/host\";\nimport { AssetModule, ComponentMeta, Split } from \"@plasmicapp/loader-core\";\nimport { PlasmicQueryDataProvider } from \"@plasmicapp/query\";\nimport * as React from \"react\";\nimport { InternalPlasmicComponentLoader } from \"./loader-client\";\nimport { ComponentRenderData, PlasmicComponentLoader } from \"./loader-shared\";\nimport { MaybeWrap, useForceUpdate } from \"./utils\";\nimport {\n  getGlobalVariantsFromSplits,\n  mergeGlobalVariantsSpec,\n} from \"./variation\";\n\nexport interface PlasmicRootContextValue extends PlasmicDataSourceContextValue {\n  globalVariants?: GlobalVariantSpec[];\n  globalContextsProps?: Record<string, any>;\n  loader: InternalPlasmicComponentLoader;\n  variation?: Record<string, string>;\n  translator?: PlasmicTranslator;\n  Head?: React.ComponentType<any>;\n  Link?: React.ComponentType<any>;\n  disableLoadingBoundary?: boolean;\n  suspenseFallback?: React.ReactNode;\n}\n\nconst PlasmicRootContext = React.createContext<\n  PlasmicRootContextValue | undefined\n>(undefined);\n\nexport interface GlobalVariantSpec {\n  name: string;\n  projectId?: string;\n  value: any;\n}\n\nexport type PlasmicTranslator = (\n  str: string,\n  opts?: {\n    components?: {\n      [key: string]: React.ReactElement | React.ReactFragment;\n    };\n  }\n) => React.ReactNode;\n\n/**\n * PlasmicRootProvider should be used at the root of your page\n * or application.\n */\nexport function PlasmicRootProvider(\n  props: {\n    /**\n     * The global PlasmicComponentLoader instance you created via\n     * initPlasmicLoader().\n     */\n    loader: PlasmicComponentLoader;\n\n    /**\n     * Global variants to activate for Plasmic components\n     */\n    globalVariants?: GlobalVariantSpec[];\n\n    children?: React.ReactNode;\n\n    /**\n     * If true, will skip rendering css\n     */\n    skipCss?: boolean;\n\n    /**\n     * If true, will skip installing fonts\n     */\n    skipFonts?: boolean;\n\n    /**\n     * If you have pre-fetched component data via PlasmicComponentLoader,\n     * you can pass them in here; PlasmicComponent will avoid fetching\n     * component data that have already been pre-fetched.\n     */\n    prefetchedData?: ComponentRenderData;\n\n    /**\n     * If you have pre-fetched data that are needed by usePlasmicQueryData(),\n     * then pass in the pre-fetched cache here, mapping query key to fetched data.\n     */\n    prefetchedQueryData?: Record<string, any>;\n\n    /**\n     * Specifies whether usePlasmicQueryData() should be operating in suspense mode\n     * (throwing promises).\n     */\n    suspenseForQueryData?: boolean;\n\n    /**\n     * Override your Global Contexts Provider props. This is a map from\n     * globalContextComponentNameProps to object of props to use for that\n     * component.\n     */\n    globalContextsProps?: Record<string, any>;\n\n    /**\n     * Specifies a mapping of split id to slice id that should be activated\n     */\n    variation?: Record<string, string>;\n\n    /**\n     * Translator function to be used for text blocks\n     */\n    translator?: PlasmicTranslator;\n\n    /**\n     * Head component to use in PlasmicHead component (e.g. Head from next/head\n     * or Helmet from react-helmet).\n     */\n    Head?: React.ComponentType<any>;\n\n    /**\n     * Link component to use. Can be any component that takes in props passed\n     * to an <a/> tag.\n     */\n    Link?: React.ComponentType<any>;\n\n    /**\n     * Page route without params substitution (e.g. /products/[slug]).\n     */\n    pageRoute?: string;\n\n    /**\n     * Page path parameters (e.g. {slug: \"foo\"} if page path is\n     * /products/[slug] and URI is /products/foo).\n     */\n    pageParams?: Record<string, string | string[] | undefined>;\n\n    /**\n     * Page query parameters (e.g. {q: \"foo\"} if page path is\n     * /some/path?q=foo).\n     */\n    pageQuery?: Record<string, string | string[] | undefined>;\n    /**\n     * Whether the internal Plasmic React.Suspense boundaries should be removed\n     */\n    disableLoadingBoundary?: boolean;\n    /**\n     * Whether the root React.Suspense boundary should be removed\n     */\n    disableRootLoadingBoundary?: boolean;\n    /**\n     * Fallback value for React.Suspense boundary\n     */\n    suspenseFallback?: React.ReactNode;\n  } & PlasmicDataSourceContextValue\n) {\n  const {\n    globalVariants,\n    prefetchedData,\n    children,\n    skipCss,\n    skipFonts,\n    prefetchedQueryData,\n    suspenseForQueryData,\n    globalContextsProps,\n    variation,\n    translator,\n    Head,\n    Link,\n    pageRoute,\n    pageParams,\n    pageQuery,\n    suspenseFallback,\n    disableLoadingBoundary,\n    disableRootLoadingBoundary,\n  } = props;\n  const loader = (props.loader as any)\n    .__internal as InternalPlasmicComponentLoader;\n\n  if (prefetchedData) {\n    loader.registerPrefetchedBundle(prefetchedData.bundle);\n  }\n\n  const [splits, setSplits] = React.useState<Split[]>(loader.getActiveSplits());\n  const forceUpdate = useForceUpdate();\n  const watcher = React.useMemo(\n    () => ({\n      onDataFetched: () => {\n        setSplits(loader.getActiveSplits());\n        forceUpdate();\n      },\n    }),\n    [loader, forceUpdate]\n  );\n\n  React.useEffect(() => {\n    loader.subscribePlasmicRoot(watcher);\n    return () => loader.unsubscribePlasmicRoot(watcher);\n  }, [watcher, loader]);\n\n  const currentContextValue = React.useContext(PlasmicRootContext);\n\n  const { user, userAuthToken, isUserLoading, authRedirectUri } = props;\n\n  const value = React.useMemo<PlasmicRootContextValue>(() => {\n    // Fallback to the value in `currentContextValue` if none is provided\n    const withCurrentContextValueFallback = <\n      K extends keyof PlasmicRootContextValue\n    >(\n      v: PlasmicRootContextValue[K],\n      key: K\n    ): PlasmicRootContextValue[K] => {\n      return (v !== undefined ? v : currentContextValue?.[key])!;\n    };\n    return {\n      globalVariants: [\n        ...mergeGlobalVariantsSpec(\n          globalVariants ?? [],\n          getGlobalVariantsFromSplits(splits, variation ?? {})\n        ),\n        ...(currentContextValue?.globalVariants ?? []),\n      ],\n      globalContextsProps: {\n        ...(currentContextValue?.globalContextsProps ?? {}),\n        ...(globalContextsProps ?? {}),\n      },\n      loader: withCurrentContextValueFallback(loader, \"loader\"),\n      variation: {\n        ...(currentContextValue?.variation ?? {}),\n        ...(variation ?? {}),\n      },\n      translator: withCurrentContextValueFallback(translator, \"translator\"),\n      Head: withCurrentContextValueFallback(Head, \"Head\"),\n      Link: withCurrentContextValueFallback(Link, \"Link\"),\n      user: withCurrentContextValueFallback(user, \"user\"),\n      userAuthToken: withCurrentContextValueFallback(\n        userAuthToken,\n        \"userAuthToken\"\n      ),\n      isUserLoading: withCurrentContextValueFallback(\n        isUserLoading,\n        \"isUserLoading\"\n      ),\n      authRedirectUri: withCurrentContextValueFallback(\n        authRedirectUri,\n        \"authRedirectUri\"\n      ),\n      suspenseFallback: withCurrentContextValueFallback(\n        suspenseFallback,\n        \"suspenseFallback\"\n      ),\n      disableLoadingBoundary: withCurrentContextValueFallback(\n        disableLoadingBoundary,\n        \"disableLoadingBoundary\"\n      ),\n    };\n  }, [\n    globalVariants,\n    variation,\n    globalContextsProps,\n    loader,\n    splits,\n    translator,\n    Head,\n    Link,\n    user,\n    userAuthToken,\n    isUserLoading,\n    authRedirectUri,\n    suspenseFallback,\n    disableLoadingBoundary,\n    currentContextValue,\n  ]);\n\n  React.useEffect(() => {\n    loader.trackRender({\n      renderCtx: {\n        // We track the provider as a single entity\n        rootComponentId: \"provider\",\n        teamIds: loader.getTeamIds(),\n        projectIds: loader.getProjectIds(),\n      },\n      variation: value.variation,\n    });\n  }, [loader, value]);\n\n  const reactMajorVersion = +React.version.split(\".\")[0];\n\n  const shouldDisableRootLoadingBoundary =\n    disableRootLoadingBoundary ??\n    loader.getBundle().disableRootLoadingBoundaryByDefault;\n\n  return (\n    <PlasmicQueryDataProvider\n      prefetchedCache={prefetchedQueryData}\n      suspense={suspenseForQueryData}\n    >\n      <PlasmicRootContext.Provider value={value}>\n        {!skipCss && (\n          <PlasmicCss\n            loader={loader}\n            prefetchedData={prefetchedData}\n            skipFonts={skipFonts}\n          />\n        )}\n        <PageParamsProvider\n          route={pageRoute}\n          params={pageParams}\n          query={pageQuery}\n        >\n          <MaybeWrap\n            cond={!shouldDisableRootLoadingBoundary && reactMajorVersion >= 18}\n            wrapper={(contents) => (\n              <React.Suspense fallback={suspenseFallback ?? \"Loading...\"}>\n                {contents}\n              </React.Suspense>\n            )}\n          >\n            {children}\n          </MaybeWrap>\n        </PageParamsProvider>\n      </PlasmicRootContext.Provider>\n    </PlasmicQueryDataProvider>\n  );\n}\n\n/**\n * Inject all css modules as <style/> tags. We can't use the usual styleInjector postcss\n * uses because that doesn't work on the server side for SSR.\n */\nconst PlasmicCss = React.memo(function PlasmicCss(props: {\n  loader: InternalPlasmicComponentLoader;\n  prefetchedData?: ComponentRenderData;\n  skipFonts?: boolean;\n}) {\n  const { loader, prefetchedData, skipFonts } = props;\n  const [useScopedCss, setUseScopedCss] = React.useState(!!prefetchedData);\n  const builtCss = buildCss(loader, {\n    scopedCompMetas:\n      useScopedCss && prefetchedData\n        ? prefetchedData.bundle.components\n        : undefined,\n    skipFonts,\n  });\n  const forceUpdate = useForceUpdate();\n  const watcher = React.useMemo(\n    () => ({\n      onDataFetched: () => {\n        // If new data has been fetched, then use all the fetched css\n        setUseScopedCss(false);\n        forceUpdate();\n      },\n    }),\n    [loader, forceUpdate]\n  );\n\n  React.useEffect(() => {\n    loader.subscribePlasmicRoot(watcher);\n    return () => loader.unsubscribePlasmicRoot(watcher);\n  }, [watcher, loader]);\n\n  return <style dangerouslySetInnerHTML={{ __html: builtCss }} />;\n});\n\nfunction buildCss(\n  loader: InternalPlasmicComponentLoader,\n  opts: {\n    scopedCompMetas?: ComponentMeta[];\n    skipFonts?: boolean;\n  }\n) {\n  const { scopedCompMetas, skipFonts } = opts;\n  const cssFiles =\n    scopedCompMetas &&\n    new Set<string>([\n      \"entrypoint.css\",\n      ...scopedCompMetas.map((c) => c.cssFile),\n    ]);\n  const cssModules = loader\n    .getLookup()\n    .getCss()\n    .filter((f) => !cssFiles || cssFiles.has(f.fileName));\n\n  const getPri = (fileName: string) => (fileName === \"entrypoint.css\" ? 0 : 1);\n  const compareModules = (a: AssetModule, b: AssetModule) =>\n    getPri(a.fileName) !== getPri(b.fileName)\n      ? getPri(a.fileName) - getPri(b.fileName)\n      : a.fileName.localeCompare(b.fileName);\n  cssModules.sort(compareModules);\n\n  const remoteFonts = loader.getLookup().getRemoteFonts();\n\n  // Make sure the @import statements come at the front of css\n  return `\n    ${\n      skipFonts\n        ? \"\"\n        : remoteFonts.map((f) => `@import url('${f.url}');`).join(\"\\n\")\n    }\n    ${cssModules.map((mod) => mod.source).join(\"\\n\")}\n  `;\n}\n\nexport function usePlasmicRootContext() {\n  return React.useContext(PlasmicRootContext);\n}\n", "import { ComponentMeta } from \"@plasmicapp/loader-core\";\nimport pascalcase from \"pascalcase\";\nimport * as React from \"react\";\n\nexport const isBrowser = typeof window !== \"undefined\";\n\nexport type ComponentLookupSpec =\n  | string\n  | { name: string; projectId?: string; isCode?: boolean };\n\ninterface FullNameLookupSpec {\n  name: string;\n  rawName?: string;\n  projectId?: string;\n  isCode?: boolean;\n}\n\ninterface FullPathLookupSpec {\n  path: string;\n  projectId?: string;\n}\n\ntype FullLookupSpec = FullNameLookupSpec | FullPathLookupSpec;\n\nexport function useForceUpdate() {\n  const [, setTick] = React.useState(0);\n  const update = React.useCallback(() => {\n    setTick((tick) => tick + 1);\n  }, []);\n  return update;\n}\n\nexport function useStableLookupSpec(spec: ComponentLookupSpec) {\n  return useStableLookupSpecs(spec)[0];\n}\n\nexport function useStableLookupSpecs(...specs: ComponentLookupSpec[]) {\n  const [stableSpecs, setStableSpecs] = React.useState(specs);\n\n  React.useEffect(() => {\n    if (\n      specs.length !== stableSpecs.length ||\n      specs.some((s, i) => !areLookupSpecsEqual(s, stableSpecs[i]))\n    ) {\n      setStableSpecs(specs);\n    }\n  }, [specs, stableSpecs]);\n  return stableSpecs;\n}\n\nfunction areLookupSpecsEqual(\n  spec1: ComponentLookupSpec,\n  spec2: ComponentLookupSpec\n) {\n  if (spec1 === spec2) {\n    return true;\n  }\n  if (typeof spec1 !== typeof spec2) {\n    return false;\n  }\n\n  const fullSpec1 = toFullLookup(spec1);\n  const fullSpec2 = toFullLookup(spec2);\n  return (\n    ((isNameSpec(fullSpec1) &&\n      isNameSpec(fullSpec2) &&\n      fullSpec1.name === fullSpec2.name &&\n      fullSpec1.isCode === fullSpec2.isCode) ||\n      (isPathSpec(fullSpec1) &&\n        isPathSpec(fullSpec2) &&\n        fullSpec1.path === fullSpec2.path)) &&\n    fullSpec1.projectId === fullSpec2.projectId\n  );\n}\n\nfunction isNameSpec(lookup: FullLookupSpec): lookup is FullNameLookupSpec {\n  return \"name\" in lookup;\n}\n\nfunction isPathSpec(lookup: FullLookupSpec): lookup is FullPathLookupSpec {\n  return \"path\" in lookup;\n}\n\nfunction toFullLookup(lookup: ComponentLookupSpec): FullLookupSpec {\n  const namePart = typeof lookup === \"string\" ? lookup : lookup.name;\n  const projectId = typeof lookup === \"string\" ? undefined : lookup.projectId;\n  const codeComponent = typeof lookup === \"string\" ? undefined : lookup.isCode;\n\n  if (codeComponent !== true && namePart.startsWith(\"/\")) {\n    return { path: normalizePath(namePart), projectId };\n  } else {\n    return {\n      name: codeComponent ? namePart : normalizeName(namePart),\n      rawName: namePart.trim(),\n      projectId,\n      isCode: codeComponent,\n    };\n  }\n}\n\nfunction normalizePath(path: string) {\n  return path.trim();\n}\n\nfunction normalizeName(name: string) {\n  // Not a full normalization, but should be good enough\n  return pascalcase(name).trim();\n}\n\nexport function useIsMounted(): () => boolean {\n  const ref = React.useRef<boolean>(false);\n  const isMounted = React.useCallback(() => ref.current, []);\n\n  React.useEffect(() => {\n    ref.current = true;\n    return () => {\n      ref.current = false;\n    };\n  }, []);\n\n  return isMounted;\n}\n\n/**\n * Check if `lookup` resolves to `pagePath`. If it's a match, return an object\n * containing path params; otherwise, return false.\n *\n * For example,\n * - `matchesPagePath(\"/hello/[name]\", \"/hello/world\")` -> `{params: {name:\n *   \"world\"}}`\n * - `matchesPagePath(\"/hello/[name]\", \"/\")` -> `false`\n * - `matchesPagePath(\"/hello/[...catchall]\", \"/hello/a/b/c\")` -> `{params: {catchall: [\"a\", \"b\", \"c\"]}}`\n * - `matchesPagePath(\"/hello/[[...catchall]]\", \"/hello/\")` -> `{params: {catchall: []}}`\n * - `matchesPagePath(\"/\", \"\")` -> `{params: {}}`\n */\nexport function matchesPagePath(pattern: string, path: string) {\n  // (generated by ChatGPT 4 from the test cases)\n\n  // Normalize the path and pattern by ensuring they both start and end without slashes\n  const normalizedPattern = \"/\" + pattern.replace(/^\\/|\\/$/g, \"\");\n  const normalizedPath = \"/\" + path.replace(/^\\/|\\/$/g, \"\");\n\n  // Modify the regex to match optional leading slashes\n  const regexString = normalizedPattern\n    .replace(/\\/\\[\\[\\.\\.\\.([^\\]^]+)]]/g, \"(?:/([^]*))?\") // Optional catch-all\n    .replace(/\\/\\[\\.\\.\\.([^\\]^]+)]/g, \"/([^]*)\") // Catch-all\n    .replace(/\\[([^\\]^]+)]/g, \"([^/]+)\") // Normal slug\n    .replace(/\\//g, \"\\\\/\"); // Escape forward slashes\n\n  const regex = new RegExp(`^/?${regexString}$`); // Allow optional leading slash\n  const match = normalizedPath.match(regex);\n\n  if (!match) return false;\n\n  // Extract slug names from pattern\n  const slugNames = [...pattern.matchAll(/\\[\\.?\\.?\\.?([^[\\]]+)]/g)].map(\n    (m) => m[1]\n  );\n\n  // Construct params object\n  const params: Record<string, string | string[]> = {};\n  for (let i = 0; i < slugNames.length; i++) {\n    const slugName = slugNames[i];\n    const value = match[i + 1];\n\n    if (pattern.includes(`[[...${slugName}]]`)) {\n      // Handle optional catchall slugs\n      params[slugName] = value ? value.split(\"/\").filter(Boolean) : [];\n    } else if (pattern.includes(`[...${slugName}]`)) {\n      // Handle mandatory catchall slugs\n      params[slugName] = value.split(\"/\").filter(Boolean);\n    } else if (value !== undefined) {\n      // Handle normal slugs\n      params[slugName] = value;\n    }\n  }\n\n  return { params };\n}\n\nexport function isDynamicPagePath(path: string): boolean {\n  return !!path.match(/\\[[^/]*\\]/);\n}\n\nfunction matchesCompMeta(lookup: FullLookupSpec, meta: ComponentMeta) {\n  if (lookup.projectId && meta.projectId !== lookup.projectId) {\n    return false;\n  }\n\n  return isNameSpec(lookup)\n    ? (lookup.name === meta.name ||\n        lookup.rawName === meta.name ||\n        lookup.rawName === meta.displayName) &&\n        (lookup.isCode == null || lookup.isCode === meta.isCode)\n    : !!(meta.path && matchesPagePath(meta.path, lookup.path));\n}\n\nexport function getCompMetas(\n  metas: ComponentMeta[],\n  lookup: ComponentLookupSpec\n) {\n  const full = toFullLookup(lookup);\n  return metas\n    .filter((meta) => matchesCompMeta(full, meta))\n    .map<ComponentMeta & { params?: Record<string, string | string[]> }>(\n      (meta) => {\n        if (isNameSpec(full) || !meta.path) {\n          return meta;\n        }\n\n        const match = matchesPagePath(meta.path, full.path);\n        if (!match) {\n          return meta;\n        }\n\n        return { ...meta, params: match.params };\n      }\n    )\n    .sort(\n      (meta1, meta2) =>\n        // We sort the matched component metas by the number of path params, so\n        // if there are two pages `/products/foo` and `/products/[slug]`,\n        // the first one will have higher precedence.\n        Array.from(Object.keys(meta1.params || {})).length -\n        Array.from(Object.keys(meta2.params || {})).length\n    );\n}\n\nexport function getLookupSpecName(lookup: ComponentLookupSpec) {\n  if (typeof lookup === \"string\") {\n    return lookup;\n  } else if (lookup.projectId) {\n    return `${lookup.name} (project ${lookup.projectId})`;\n  } else {\n    return lookup.name;\n  }\n}\n\nexport function MaybeWrap(props: {\n  children: React.ReactNode;\n  cond: boolean;\n  wrapper: (children: React.ReactNode) => React.ReactElement;\n}) {\n  return (\n    props.cond ? props.wrapper(props.children) : props.children\n  ) as React.ReactElement;\n}\n\nexport function uniq<T>(elements: T[]): T[] {\n  return Array.from(new Set(elements));\n}\n\nexport function uniqBy<T, K>(elements: T[], iterator: (elt: T) => K): T[] {\n  const vis = new Set<K>();\n  const filtered: T[] = [];\n  for (const elt of elements) {\n    const key = iterator(elt);\n    if (!vis.has(key)) {\n      vis.add(key);\n      filtered.push(elt);\n    }\n  }\n  return filtered;\n}\n\nexport function intersect<T>(a: T[], b: T[]): T[] {\n  const setB = new Set(b);\n  return a.filter((elt) => setB.has(elt));\n}\n", "import type {\n  ExperimentSlice,\n  SegmentSlice,\n  Split,\n} from \"@plasmicapp/loader-core\";\nimport type { GlobalVariantSpec } from \"./PlasmicRootProvider\";\n\nexport function getPlasmicCookieValues() {\n  return Object.fromEntries(\n    document.cookie\n      .split(\"; \")\n      .filter((cookie) => cookie.includes(\"plasmic:\"))\n      .map((cookie) => cookie.split(\"=\"))\n      .map(([key, value]) => [key.split(\":\")[1], value])\n  );\n}\n\nexport function updatePlasmicCookieValue(key: string, value: string) {\n  document.cookie = `plasmic:${key}=${value}`;\n}\n\nexport const getGlobalVariantsFromSplits = (\n  splits: Split[],\n  variation: Record<string, string>\n) => {\n  const globalVariants: GlobalVariantSpec[] = [];\n\n  Object.keys(variation).map((variationKey: string) => {\n    const [_type, splitId] = variationKey.split(\".\");\n    const sliceId = variation[variationKey];\n    const split = splits.find(\n      (s) => s.id === splitId || s.externalId === splitId\n    );\n    if (split) {\n      const slice: ExperimentSlice | SegmentSlice | undefined = (\n        split.slices as Array<ExperimentSlice | SegmentSlice>\n      ).find((s: any) => s.id === sliceId || s.externalId === sliceId);\n      if (slice) {\n        slice.contents.map((x) => {\n          globalVariants.push({\n            name: x.group,\n            value: x.variant,\n            projectId: x.projectId,\n          });\n        });\n      }\n    }\n  });\n\n  return globalVariants;\n};\n\nexport const mergeGlobalVariantsSpec = (\n  target: GlobalVariantSpec[],\n  from: GlobalVariantSpec[]\n) => {\n  let result = [...target];\n  const existingGlobalVariants = new Set(\n    target.map((t) => `${t.name}-${t.projectId ?? \"\"}`)\n  );\n  const newGlobals = from.filter(\n    (t) => !existingGlobalVariants.has(`${t.name}-${t.projectId ?? \"\"}`)\n  );\n\n  if (newGlobals.length > 0) {\n    result = [...result, ...newGlobals];\n  }\n\n  return result;\n};\n", "/**\n * We don't actually make use of the global variant React contexts generated\n * in the bundle.  That's because we would have to wait until the data is\n * loaded before we can set up the context providers, but setting up context\n * providers will mutate the React tree and invalidate all the children. That means\n * once data comes in, we'll re-render the React tree from the providers down\n * in a way that will lose all existing React state.  Therefore, instead,\n * we always have a single context provided -- the PlasmicRootContext -- and we\n * create these fake useGlobalVariant() hooks that just read from that\n * PlasmicRootContext.  This allows us to have a stable React tree before and\n * after the data load.\n */\n\nimport { InternalPlasmicComponentLoader } from \"./loader-client\";\nimport { usePlasmicRootContext } from \"./PlasmicRootProvider\";\n\nexport function createUseGlobalVariant(name: string, projectId: string) {\n  return () => {\n    const rootContext = usePlasmicRootContext();\n    if (!rootContext) {\n      return undefined;\n    }\n\n    const loader = rootContext.loader as InternalPlasmicComponentLoader;\n    const spec = [\n      ...loader.getGlobalVariants(),\n      ...(rootContext.globalVariants ?? []),\n    ].find(\n      (spec2) =>\n        spec2.name === name &&\n        (!spec2.projectId || spec2.projectId === projectId)\n    );\n    return spec ? spec.value : undefined;\n  };\n}\n", "import type {\n  ComponentHelpers,\n  ComponentHelpers as InternalCodeComponentHelpers,\n  CodeComponentMeta as InternalCodeComponentMeta,\n  CustomFunctionMeta as InternalCustomFunctionMeta,\n  GlobalContextMeta as InternalGlobalContextMeta,\n  StateHelpers,\n  StateSpec,\n  TokenRegistration,\n  TraitMeta,\n  useDataEnv,\n  useSelector,\n  useSelectors,\n} from \"@plasmicapp/host\";\nimport {\n  LoaderBundleCache,\n  PageMeta,\n  PlasmicModulesFetcher,\n  PlasmicTracker,\n  Registry,\n  TrackRenderOptions,\n} from \"@plasmicapp/loader-core\";\nimport {\n  CodeModule,\n  ComponentMeta,\n  LoaderBundleOutput,\n  internal_getCachedBundleInNodeServer,\n} from \"@plasmicapp/loader-fetcher\";\nimport { getActiveVariation, getExternalIds } from \"@plasmicapp/loader-splits\";\nimport type { useMutablePlasmicQueryData } from \"@plasmicapp/query\";\nimport type { GlobalVariantSpec } from \"./PlasmicRootProvider\";\nimport { mergeBundles, prepComponentData } from \"./bundles\";\nimport { ComponentLookup } from \"./component-lookup\";\nimport {\n  ComponentLookupSpec,\n  getCompMetas,\n  getLookupSpecName,\n  isBrowser,\n  isDynamicPagePath,\n  uniq,\n} from \"./utils\";\nimport { getPlasmicCookieValues, updatePlasmicCookieValue } from \"./variation\";\n\nexport interface InitOptions {\n  projects: {\n    id: string;\n    token: string;\n    version?: string;\n  }[];\n  cache?: LoaderBundleCache;\n  platform?: \"react\" | \"nextjs\" | \"gatsby\";\n  platformOptions?: {\n    nextjs?: {\n      appDir: boolean;\n    };\n  };\n  preview?: boolean;\n  host?: string;\n  onClientSideFetch?: \"warn\" | \"error\";\n  i18n?: {\n    keyScheme: \"content\" | \"hash\" | \"path\";\n    tagPrefix?: string;\n  };\n  /**\n   * @deprecated use i18n.keyScheme instead\n   */\n  i18nKeyScheme?: \"content\" | \"hash\";\n\n  /**\n   * By default, fetchComponentData() and fetchPages() calls cached in memory\n   * with the PlasmicComponentLoader instance.  If alwaysFresh is true, then\n   * data is always freshly fetched over the network.\n   */\n  alwaysFresh?: boolean;\n\n  /**\n   * If true, generated code from the server won't include page metadata tags\n   */\n  skipHead?: boolean;\n\n  /**\n   * If true, uses browser / node's native fetch\n   */\n  nativeFetch?: boolean;\n\n  /**\n   * If true, will not redirect to the codegen server automatically, and will\n   * try to reuse the existing bundle in the cache.\n   */\n  manualRedirect?: boolean;\n}\n\nexport interface ComponentRenderData {\n  entryCompMetas: (ComponentMeta & { params?: Record<string, string> })[];\n  bundle: LoaderBundleOutput;\n  remoteFontUrls: string[];\n}\n\nexport interface ComponentSubstitutionSpec {\n  lookup: ComponentLookupSpec;\n  component: React.ComponentType<any>;\n  codeComponentHelpers?: InternalCodeComponentHelpers<\n    React.ComponentProps<any>\n  >;\n}\n\nexport interface PlasmicRootWatcher {\n  onDataFetched?: () => void;\n}\n\n/**\n * Helper functions to describe code component behaviors, in order to allow\n * data extraction in RSC / Next.js App routing.\n */\nexport interface ReactServerOps {\n  readDataEnv: typeof useDataEnv;\n  readDataSelector: typeof useSelector;\n  readDataSelectors: typeof useSelectors;\n  /**\n   * The contexts are passed using a key instead of the context provider\n   * Notice it cannot access the default context value if none has been provided,\n   * since React server components cannot create contexts.\n   */\n  readContext: (contextKey: string) => any;\n  /**\n   * Allows data fetching from the code component and caching the result,\n   * which will be stored in the `queryCache` returned by\n   * `extractPlasmicQueryData`.\n   */\n  fetchData: typeof useMutablePlasmicQueryData;\n}\n\n/**\n * Represents data provided by a code component via `DataProvider`\n */\nexport interface ServerProvidedData {\n  name: string;\n  data: any;\n}\n\n/**\n * Provides a new value for a given context key, similar to Context.Provider.\n * The context itself is not available (RSC doesn't allow calling\n * `createContext`) so each context will need to be represented as a unique\n * \"context key\". Also it means the default context value is not available\n * in case no value is passed (and reading that context will return `undefined`)\n */\nexport interface ServerProvidedContext {\n  /**\n   * Identifier to the context, required to read it later via\n   * `ReactServerOps.readContext()`.\n   */\n  contextKey: string;\n  /**\n   * Context value being provided (similar to `Context.Provider`).\n   */\n  value: any;\n}\n\n/**\n *  Each child of a code component might receive separate `DataProvider` and\n *  Context values.\n */\nexport interface ServerChildData {\n  providedData?: ServerProvidedData | ServerProvidedData[];\n  providedContexts?: ServerProvidedContext | ServerProvidedContext[];\n  node: React.ReactNode;\n}\n\nexport interface ServerInfo {\n  /**\n   * Optional: Indicates the React Nodes created by the component and the\n   * respective contexts provided to them. If not specified, it will render the\n   * children passed to the component as props.\n   */\n  children?: ServerChildData | ServerChildData[];\n  providedData?: ServerProvidedData | ServerProvidedData[];\n  providedContexts?: ServerProvidedContext | ServerProvidedContext[];\n}\n\nexport type CodeComponentMeta<P> = Omit<\n  InternalCodeComponentMeta<P>,\n  \"importPath\" | \"componentHelpers\" | \"states\"\n> & {\n  /**\n   * The path to be used when importing the component in the generated code.\n   * It can be the name of the package that contains the component, or the path\n   * to the file in the project (relative to the root directory).\n   * Optional: not used by Plasmic headless API, only by codegen.\n   */\n  importPath?: string;\n  /**\n   * The states helpers are registered together with the states for the Plasmic headless API\n   */\n  states?: Record<string, StateSpec<P> & StateHelpers<P, any>>;\n\n  /**\n   * Helper function to enable data extraction when running Plasmic from\n   * Next.js App Router.\n   */\n  getServerInfo?: (props: P, ops: ReactServerOps) => ServerInfo;\n};\n\nexport type GlobalContextMeta<P> = Omit<\n  InternalGlobalContextMeta<P>,\n  \"importPath\"\n> & {\n  /**\n   * The path to be used when importing the component in the generated code.\n   * It can be the name of the package that contains the component, or the path\n   * to the file in the project (relative to the root directory).\n   * Optional: not used by Plasmic headless API, only by codegen.\n   */\n  importPath?: string;\n};\n\nexport type CustomFunctionMeta<F extends (...args: any[]) => any> = Omit<\n  InternalCustomFunctionMeta<F>,\n  \"importPath\"\n> & {\n  /**\n   * The path to be used when importing the function in the generated code.\n   * It can be the name of the package that contains the function, or the path\n   * to the file in the project (relative to the root directory).\n   * Optional: not used by Plasmic headless API, only by codegen.\n   */\n  importPath?: string;\n};\n\nexport type FetchPagesOpts = {\n  /**\n   * Whether to include dynamic pages in fetchPages() output. A page is\n   * considered dynamic if its path contains some param between brackets,\n   * e.g. \"[slug]\".\n   */\n  includeDynamicPages?: boolean;\n};\n\nexport const SUBSTITUTED_COMPONENTS: Record<\n  string,\n  React.ComponentType<any>\n> = {};\nexport const REGISTERED_CODE_COMPONENT_HELPERS: Record<\n  string,\n  InternalCodeComponentHelpers<React.ComponentProps<any>>\n> = {};\nexport const SUBSTITUTED_GLOBAL_VARIANT_HOOKS: Record<string, () => any> = {};\nexport const REGISTERED_CUSTOM_FUNCTIONS: Record<\n  string,\n  (...args: any[]) => any\n> = {};\n\nexport function customFunctionImportAlias<F extends (...args: any[]) => any>(\n  meta: CustomFunctionMeta<F>\n) {\n  const customFunctionPrefix = `__fn_`;\n  return meta.namespace\n    ? `${customFunctionPrefix}${meta.namespace}__${meta.name}`\n    : `${customFunctionPrefix}${meta.name}`;\n}\n\nexport function internalSetRegisteredFunction<\n  F extends (...args: any[]) => any\n>(fn: F, meta: CustomFunctionMeta<F>) {\n  REGISTERED_CUSTOM_FUNCTIONS[customFunctionImportAlias(meta)] = fn;\n}\n\ninterface BuiltinRegisteredModules {\n  react: typeof import(\"react\");\n  \"react-dom\": typeof import(\"react-dom\");\n  \"react/jsx-runtime\": typeof import(\"react/jsx-runtime\");\n  \"react/jsx-dev-runtime\": typeof import(\"react/jsx-dev-runtime\");\n  \"@plasmicapp/query\": typeof import(\"@plasmicapp/query\");\n  \"@plasmicapp/data-sources-context\": typeof import(\"@plasmicapp/data-sources-context\");\n  \"@plasmicapp/host\": typeof import(\"@plasmicapp/host\");\n  \"@plasmicapp/loader-runtime-registry\": {\n    components: Record<string, React.ComponentType<any>>;\n    globalVariantHooks: Record<string, () => any>;\n    codeComponentHelpers: Record<string, ComponentHelpers<any>>;\n    functions: Record<string, (...args: any[]) => any>;\n  };\n}\n\nexport interface FetchComponentDataOpts {\n  /**\n   * Will fetch either code targeting SSR or browser hydration in the\n   * returned bundle.\n   *\n   * By default, the target is browser. That's okay, because even when\n   * doing SSR, as long as you are using the same instance of PlasmicLoader\n   * that was used to fetch component data, it will still know how to get at\n   * the server code.\n   *\n   * But, if you are building your own SSR solution, where fetching and rendering\n   * are using different instances of PlasmicLoader, then you'll want to make\n   * sure that when you fetch, you are fetching the right one to be used in the\n   * right environment for either SSR or browser hydration.\n   */\n  target?: \"server\" | \"browser\";\n}\n\nfunction parseFetchComponentDataArgs(\n  specs: ComponentLookupSpec[],\n  opts?: FetchComponentDataOpts\n): { specs: ComponentLookupSpec[]; opts?: FetchComponentDataOpts };\nfunction parseFetchComponentDataArgs(...specs: ComponentLookupSpec[]): {\n  specs: ComponentLookupSpec[];\n  opts?: FetchComponentDataOpts;\n};\nfunction parseFetchComponentDataArgs(...args: any[]) {\n  let specs: ComponentLookupSpec[];\n  let opts: FetchComponentDataOpts | undefined;\n  if (Array.isArray(args[0])) {\n    specs = args[0];\n    opts = args[1];\n  } else {\n    specs = args;\n    opts = undefined;\n  }\n  return { specs, opts };\n}\n\n/** Subset of loader functionality that works on Client and React Server Components. */\nexport abstract class BaseInternalPlasmicComponentLoader {\n  public readonly opts: InitOptions;\n  private readonly registry = new Registry();\n  private readonly tracker: PlasmicTracker;\n  private readonly fetcher: PlasmicModulesFetcher;\n  private readonly onBundleMerged?: () => void;\n  private readonly onBundleFetched?: () => void;\n  private globalVariants: GlobalVariantSpec[] = [];\n  private subs: ComponentSubstitutionSpec[] = [];\n\n  private bundle: LoaderBundleOutput = {\n    modules: {\n      browser: [],\n      server: [],\n    },\n    components: [],\n    globalGroups: [],\n    projects: [],\n    activeSplits: [],\n    bundleKey: null,\n    deferChunksByDefault: false,\n    disableRootLoadingBoundaryByDefault: false,\n    filteredIds: {},\n  };\n\n  constructor(args: {\n    opts: InitOptions;\n    fetcher: PlasmicModulesFetcher;\n    tracker: PlasmicTracker;\n    /** Called after `mergeBundle` (including `fetch` calls). */\n    onBundleMerged?: () => void;\n    /** Called after any `fetch` calls. */\n    onBundleFetched?: () => void;\n    builtinModules: BuiltinRegisteredModules;\n  }) {\n    this.opts = args.opts;\n    this.fetcher = args.fetcher;\n    this.tracker = args.tracker;\n    this.onBundleMerged = args.onBundleMerged;\n    this.onBundleFetched = args.onBundleFetched;\n    this.registerModules(args.builtinModules);\n  }\n\n  private maybeGetCompMetas(...specs: ComponentLookupSpec[]) {\n    const found = new Set<ComponentMeta>();\n    const missing: ComponentLookupSpec[] = [];\n    for (const spec of specs) {\n      const filteredMetas = getCompMetas(this.bundle.components, spec);\n      if (filteredMetas.length > 0) {\n        filteredMetas.forEach((meta) => found.add(meta));\n      } else {\n        missing.push(spec);\n      }\n    }\n    return { found: Array.from(found.keys()), missing };\n  }\n\n  async maybeFetchComponentData(\n    specs: ComponentLookupSpec[],\n    opts?: FetchComponentDataOpts\n  ): Promise<ComponentRenderData | null>;\n  async maybeFetchComponentData(\n    ...specs: ComponentLookupSpec[]\n  ): Promise<ComponentRenderData | null>;\n  async maybeFetchComponentData(\n    ...args: any[]\n  ): Promise<ComponentRenderData | null> {\n    const { specs, opts } = parseFetchComponentDataArgs(...args);\n    const returnWithSpecsToFetch = async (\n      specsToFetch: ComponentLookupSpec[]\n    ) => {\n      await this.fetchMissingData({ missingSpecs: specsToFetch });\n      const { found: existingMetas2, missing: missingSpecs2 } =\n        this.maybeGetCompMetas(...specs);\n      if (missingSpecs2.length > 0) {\n        return null;\n      }\n\n      return prepComponentData(this.bundle, existingMetas2, opts);\n    };\n\n    if (this.opts.alwaysFresh) {\n      // If alwaysFresh, then we treat all specs as missing\n      return await returnWithSpecsToFetch(specs);\n    }\n\n    // Else we only fetch actually missing specs\n    const { found: existingMetas, missing: missingSpecs } =\n      this.maybeGetCompMetas(...specs);\n    if (missingSpecs.length === 0) {\n      return prepComponentData(this.bundle, existingMetas, opts);\n    }\n\n    return await returnWithSpecsToFetch(missingSpecs);\n  }\n\n  async fetchComponentData(\n    specs: ComponentLookupSpec[],\n    opts?: FetchComponentDataOpts\n  ): Promise<ComponentRenderData>;\n  async fetchComponentData(\n    ...specs: ComponentLookupSpec[]\n  ): Promise<ComponentRenderData>;\n  async fetchComponentData(...args: any[]): Promise<ComponentRenderData> {\n    const { specs, opts } = parseFetchComponentDataArgs(...args);\n    const data = await this.maybeFetchComponentData(specs, opts);\n\n    if (!data) {\n      const { missing: missingSpecs } = this.maybeGetCompMetas(...specs);\n      throw new Error(\n        `Unable to find components ${missingSpecs\n          .map(getLookupSpecName)\n          .join(\", \")}`\n      );\n    }\n\n    return data;\n  }\n\n  async fetchPages(opts?: FetchPagesOpts) {\n    this.maybeReportClientSideFetch(\n      () => `Plasmic: fetching all page metadata in the browser`\n    );\n    const data = await this.fetchAllData();\n    return data.components.filter(\n      (comp) =>\n        comp.isPage &&\n        comp.path &&\n        (opts?.includeDynamicPages || !isDynamicPagePath(comp.path))\n    ) as PageMeta[];\n  }\n\n  async fetchComponents() {\n    this.maybeReportClientSideFetch(\n      () => `Plasmic: fetching all component metadata in the browser`\n    );\n    const data = await this.fetchAllData();\n    return data.components;\n  }\n\n  getActiveSplits() {\n    return this.bundle.activeSplits;\n  }\n\n  getChunksUrl(bundle: LoaderBundleOutput, modules: CodeModule[]) {\n    return this.fetcher.getChunksUrl(bundle, modules);\n  }\n\n  private async fetchMissingData(opts: {\n    missingSpecs: ComponentLookupSpec[];\n  }) {\n    // TODO: do better than just fetching everything\n    this.maybeReportClientSideFetch(\n      () =>\n        `Plasmic: fetching missing components in the browser: ${opts.missingSpecs\n          .map((spec) => getLookupSpecName(spec))\n          .join(\", \")}`\n    );\n    return this.fetchAllData();\n  }\n\n  private maybeReportClientSideFetch(mkMsg: () => string) {\n    if (isBrowser && this.opts.onClientSideFetch) {\n      const msg = mkMsg();\n      if (this.opts.onClientSideFetch === \"warn\") {\n        console.warn(msg);\n      } else {\n        throw new Error(msg);\n      }\n    }\n  }\n\n  private async fetchAllData() {\n    const bundle = await this.fetcher.fetchAllData();\n    this.tracker.trackFetch();\n    this.mergeBundle(bundle);\n    this.onBundleFetched?.();\n    return bundle;\n  }\n\n  mergeBundle(newBundle: LoaderBundleOutput) {\n    newBundle.bundleKey = newBundle.bundleKey ?? null;\n    if (\n      newBundle.bundleKey &&\n      this.bundle.bundleKey &&\n      newBundle.bundleKey !== this.bundle.bundleKey\n    ) {\n      console.warn(\n        `Plasmic Error: Different code export hashes. This can happen if your app is using different loaders with different project IDs or project versions.\nConflicting values:\n${newBundle.bundleKey}\n${this.bundle.bundleKey}`\n      );\n    }\n    // Merge the old bundle into the new bundle, this way\n    // the new bundle will enforce the latest data from the server\n    // allowing elements to be deleted by newer bundles\n    this.bundle = mergeBundles(newBundle, this.bundle);\n\n    this.onBundleMerged?.();\n  }\n\n  getBundle(): LoaderBundleOutput {\n    return this.bundle;\n  }\n\n  clearCache() {\n    this.bundle = {\n      modules: {\n        browser: [],\n        server: [],\n      },\n      components: [],\n      globalGroups: [],\n      projects: [],\n      activeSplits: [],\n      bundleKey: null,\n      deferChunksByDefault: false,\n      disableRootLoadingBoundaryByDefault: false,\n      filteredIds: {},\n    };\n    this.registry.clear();\n  }\n\n  registerModules(modules: Record<string, any>) {\n    if (\n      Object.keys(modules).some(\n        (name) => this.registry.getRegisteredModule(name) !== modules[name]\n      )\n    ) {\n      if (!this.registry.isEmpty()) {\n        console.warn(\n          \"Calling PlasmicComponentLoader.registerModules() after Plasmic component has rendered; starting over.\"\n        );\n        this.registry.clear();\n      }\n      for (const key of Object.keys(modules)) {\n        this.registry.register(key, modules[key]);\n      }\n    }\n  }\n\n  substituteComponent<P>(\n    component: React.ComponentType<P>,\n    name: ComponentLookupSpec\n  ) {\n    this.internalSubstituteComponent(component, name, undefined);\n  }\n\n  protected internalSubstituteComponent<P>(\n    component: React.ComponentType<P>,\n    name: ComponentLookupSpec,\n    codeComponentHelpers:\n      | InternalCodeComponentHelpers<\n          React.ComponentProps<React.ComponentType<P>>\n        >\n      | undefined\n  ) {\n    if (!this.isRegistryEmpty()) {\n      console.warn(\n        \"Calling PlasmicComponentLoader.registerSubstitution() after Plasmic component has rendered; starting over.\"\n      );\n      this.clearRegistry();\n    }\n    this.subs.push({ lookup: name, component, codeComponentHelpers });\n  }\n\n  abstract registerComponent<T extends React.ComponentType<any>>(\n    component: T,\n    meta: CodeComponentMeta<React.ComponentProps<T>>\n  ): void;\n  abstract registerFunction<F extends (...args: any[]) => any>(\n    fn: F,\n    meta: CustomFunctionMeta<F>\n  ): void;\n  abstract registerGlobalContext<T extends React.ComponentType<any>>(\n    context: T,\n    meta: GlobalContextMeta<React.ComponentProps<T>>\n  ): void;\n  abstract registerTrait(trait: string, meta: TraitMeta): void;\n  abstract registerToken(token: TokenRegistration): void;\n\n  protected refreshRegistry() {\n    // Once we have received data, we register components to\n    // substitute.  We had to wait for data to do this so\n    // that we can look up the right module name to substitute\n    // in component meta.\n    for (const sub of this.subs) {\n      const metas = getCompMetas(this.getBundle().components, sub.lookup);\n      metas.forEach((meta) => {\n        SUBSTITUTED_COMPONENTS[meta.id] = sub.component;\n        if (sub.codeComponentHelpers) {\n          REGISTERED_CODE_COMPONENT_HELPERS[meta.id] = sub.codeComponentHelpers;\n        }\n      });\n    }\n\n    this.registry.updateModules(this.getBundle());\n  }\n\n  isRegistryEmpty() {\n    return this.registry.isEmpty();\n  }\n\n  clearRegistry() {\n    this.registry.clear();\n  }\n\n  setGlobalVariants(globalVariants: GlobalVariantSpec[]) {\n    this.globalVariants = globalVariants;\n  }\n\n  getGlobalVariants() {\n    return this.globalVariants;\n  }\n\n  registerPrefetchedBundle(bundle: LoaderBundleOutput) {\n    // For React Server Components (Next.js 13+),\n    // we need to pass server modules in LoaderBundleOutput from Server Components to Client Components.\n    // We don't want to pass them via normal page props because that will be serialized to the browser.\n    // Instead, we pass the bundle (including the server modules) via the Node `global` variable.\n    //\n    // This is the code that reads the stored bundle and merges it back into the loader.\n    if (!isBrowser) {\n      // Check if we have a cached bundle on this Node server.\n      const cachedBundle = internal_getCachedBundleInNodeServer(this.opts);\n      if (cachedBundle) {\n        // If it's there, merge the cached bundle first.\n        this.mergeBundle(cachedBundle);\n      }\n    }\n    this.mergeBundle(bundle);\n  }\n\n  getLookup() {\n    return new ComponentLookup(this.getBundle(), this.registry);\n  }\n\n  trackConversion(value = 0) {\n    this.tracker.trackConversion(value);\n  }\n\n  public async getActiveVariation(\n    opts: Omit<Parameters<typeof getActiveVariation>[0], \"splits\">\n  ) {\n    await this.fetchComponents();\n    return getActiveVariation({\n      ...opts,\n      splits: this.getBundle().activeSplits,\n    });\n  }\n\n  public getTeamIds(): string[] {\n    return uniq(\n      this.getBundle()\n        .projects.map((p) =>\n          p.teamId ? `${p.teamId}${p.indirect ? \"@indirect\" : \"\"}` : null\n        )\n        .filter((x): x is string => !!x)\n    );\n  }\n\n  public getProjectIds(): string[] {\n    return uniq(\n      this.getBundle().projects.map(\n        (p) => `${p.id}${p.indirect ? \"@indirect\" : \"\"}`\n      )\n    );\n  }\n\n  public trackRender(opts?: TrackRenderOptions) {\n    this.tracker.trackRender(opts);\n  }\n\n  public loadServerQueriesModule(fileName: string) {\n    return this.registry.load(fileName);\n  }\n}\n\n/**\n * Library for fetching component data, and registering\n * custom components.\n */\nexport class PlasmicComponentLoader {\n  private __internal: BaseInternalPlasmicComponentLoader;\n\n  constructor(internal: BaseInternalPlasmicComponentLoader) {\n    this.__internal = internal;\n  }\n\n  /**\n   * Sets global variants to be used for all components.  Note that\n   * this is not reactive, and will not re-render all components\n   * already mounted; instead, it should be used to activate global\n   * variants that should always be activated for the lifetime of this\n   * app.  If you'd like to reactively change the global variants,\n   * you should specify them via <PlasmicRootProvider />\n   */\n  setGlobalVariants(globalVariants: GlobalVariantSpec[]) {\n    this.__internal.setGlobalVariants(globalVariants);\n  }\n\n  registerModules(modules: Record<string, any>) {\n    this.__internal.registerModules(modules);\n  }\n\n  /**\n   * Register custom components that should be swapped in for\n   * components defined in your project.  You can use this to\n   * swap in / substitute a Plasmic component with a \"real\" component.\n   */\n  substituteComponent<P>(\n    component: React.ComponentType<P>,\n    name: ComponentLookupSpec\n  ) {\n    this.__internal.substituteComponent(component, name);\n  }\n\n  /**\n   * Register code components to be used on Plasmic Editor.\n   */\n  registerComponent<T extends React.ComponentType<any>>(\n    component: T,\n    meta: CodeComponentMeta<React.ComponentProps<T>>\n  ): void;\n\n  /**\n   * [[deprecated]] Please use `substituteComponent` instead for component\n   * substitution, or the other `registerComponent` overload to register\n   * code components to be used on Plasmic Editor.\n   *\n   * @see `substituteComponent`\n   */\n  registerComponent<T extends React.ComponentType<any>>(\n    component: T,\n    name: ComponentLookupSpec\n  ): void;\n\n  registerComponent<T extends React.ComponentType<any>>(\n    component: T,\n    metaOrName: ComponentLookupSpec | CodeComponentMeta<React.ComponentProps<T>>\n  ) {\n    // 'props' is a required field in CodeComponentMeta\n    if (metaOrName && typeof metaOrName === \"object\" && \"props\" in metaOrName) {\n      this.__internal.registerComponent(component, metaOrName);\n    } else {\n      // Deprecated call\n      if (\n        process.env.NODE_ENV === \"development\" &&\n        !this.warnedRegisterComponent\n      ) {\n        console.warn(\n          `PlasmicLoader: Using deprecated method \\`registerComponent\\` for component substitution. ` +\n            `Please consider using \\`substituteComponent\\` instead.`\n        );\n        this.warnedRegisterComponent = true;\n      }\n      this.substituteComponent(component, metaOrName);\n    }\n  }\n  private warnedRegisterComponent = false;\n\n  registerFunction<F extends (...args: any[]) => any>(\n    fn: F,\n    meta: CustomFunctionMeta<F>\n  ) {\n    this.__internal.registerFunction(fn, meta);\n  }\n\n  registerGlobalContext<T extends React.ComponentType<any>>(\n    context: T,\n    meta: GlobalContextMeta<React.ComponentProps<T>>\n  ) {\n    this.__internal.registerGlobalContext(context, meta);\n  }\n\n  registerTrait(trait: string, meta: TraitMeta) {\n    this.__internal.registerTrait(trait, meta);\n  }\n\n  registerToken(token: TokenRegistration) {\n    this.__internal.registerToken(token);\n  }\n\n  /**\n   * Pre-fetches component data needed to for PlasmicLoader to render\n   * these components.  Should be passed into PlasmicRootProvider as\n   * the prefetchedData prop.\n   *\n   * You can look up a component either by:\n   * - the name of the component\n   * - the path for a page component\n   * - an array of strings that make up parts of the path\n   * - object { name: \"name_or_path\", projectId: ...}, to specify which project\n   *   to use, if multiple projects have the same component name\n   *\n   * Throws an Error if a specified component to fetch does not exist in\n   * the Plasmic project.\n   */\n  fetchComponentData(\n    ...specs: ComponentLookupSpec[]\n  ): Promise<ComponentRenderData>;\n  fetchComponentData(\n    specs: ComponentLookupSpec[],\n    opts?: FetchComponentDataOpts\n  ): Promise<ComponentRenderData>;\n  fetchComponentData(...args: any[]): Promise<ComponentRenderData> {\n    return this.__internal.fetchComponentData(...args);\n  }\n\n  /**\n   * Like fetchComponentData(), but returns null instead of throwing an Error\n   * when a component is not found.  Useful when you are implementing a catch-all\n   * page and want to check if a specific path had been defined for Plasmic.\n   */\n  async maybeFetchComponentData(\n    ...specs: ComponentLookupSpec[]\n  ): Promise<ComponentRenderData | null>;\n  async maybeFetchComponentData(\n    specs: ComponentLookupSpec[],\n    opts?: FetchComponentDataOpts\n  ): Promise<ComponentRenderData | null>;\n  async maybeFetchComponentData(\n    ...args: any[]\n  ): Promise<ComponentRenderData | null> {\n    return this.__internal.maybeFetchComponentData(...args);\n  }\n\n  /**\n   * Returns all the page component metadata for these projects.\n   */\n  async fetchPages(opts?: FetchPagesOpts) {\n    return this.__internal.fetchPages(opts);\n  }\n\n  /**\n   * Returns all components metadata for these projects.\n   */\n  async fetchComponents() {\n    return this.__internal.fetchComponents();\n  }\n\n  protected async _getActiveVariation(\n    opts: Parameters<typeof this.__internal.getActiveVariation>[0]\n  ) {\n    return this.__internal.getActiveVariation(opts);\n  }\n\n  async getActiveVariation(opts: {\n    known?: Record<string, string>;\n    traits: Record<string, string | number | boolean>;\n  }) {\n    return this._getActiveVariation({\n      traits: opts.traits,\n      getKnownValue: (key: string) => {\n        if (opts.known) {\n          return opts.known[key];\n        } else {\n          const cookies = getPlasmicCookieValues();\n          return cookies[key];\n        }\n      },\n      updateKnownValue: (key: string, value: string) => {\n        if (!opts.known) {\n          updatePlasmicCookieValue(key, value);\n        }\n      },\n    });\n  }\n\n  getChunksUrl(bundle: LoaderBundleOutput, modules: CodeModule[]) {\n    return this.__internal.getChunksUrl(bundle, modules);\n  }\n\n  getExternalVariation(\n    variation: Record<string, string>,\n    filters?: Parameters<typeof getExternalIds>[2]\n  ) {\n    return getExternalIds(this.getActiveSplits(), variation, filters);\n  }\n\n  getActiveSplits() {\n    return this.__internal.getActiveSplits();\n  }\n\n  trackConversion(value = 0) {\n    this.__internal.trackConversion(value);\n  }\n\n  clearCache() {\n    return this.__internal.clearCache();\n  }\n\n  async unstable__getServerQueriesData(\n    renderData: ComponentRenderData,\n    $ctx: Record<string, any>\n  ) {\n    if (renderData.entryCompMetas.length === 0) {\n      return {};\n    }\n\n    const fileName = renderData.entryCompMetas[0].serverQueriesExecFuncFileName;\n\n    if (!fileName) {\n      return {};\n    }\n\n    const module = this.__internal.loadServerQueriesModule(fileName);\n    const { executeServerQueries } = module;\n\n    try {\n      const $serverQueries = await executeServerQueries($ctx);\n      return $serverQueries;\n    } catch (err) {\n      console.error(\"Error executing server queries function\", err);\n      return {};\n    }\n  }\n}\n", "import {\n  ComponentMeta,\n  getBundleSubset,\n  LoaderBundleOutput,\n} from \"@plasmicapp/loader-core\";\nimport type { ComponentRenderData } from \"./loader-shared\";\nimport { intersect } from \"./utils\";\n\nfunction getUsedComps(allComponents: ComponentMeta[], entryCompIds: string[]) {\n  const q: string[] = [...entryCompIds];\n  const seenIds = new Set<string>(entryCompIds);\n  const componentMetaById = new Map<string, ComponentMeta>(\n    allComponents.map((meta) => [meta.id, meta])\n  );\n  const usedComps: ComponentMeta[] = [];\n  while (q.length > 0) {\n    const [id] = q.splice(0, 1);\n    const meta = componentMetaById.get(id);\n    if (!meta) {\n      continue;\n    }\n    usedComps.push(meta);\n    meta.usedComponents.forEach((usedCompId) => {\n      if (!seenIds.has(usedCompId)) {\n        seenIds.add(usedCompId);\n        q.push(usedCompId);\n      }\n    });\n  }\n  return usedComps;\n}\n\nexport function prepComponentData(\n  bundle: LoaderBundleOutput,\n  compMetas: ComponentMeta[],\n  opts?: {\n    target?: \"browser\" | \"server\";\n  }\n): ComponentRenderData {\n  if (compMetas.length === 0) {\n    return {\n      entryCompMetas: bundle.components,\n      bundle: bundle,\n      remoteFontUrls: [],\n    };\n  }\n\n  const usedComps = getUsedComps(\n    bundle.components,\n    compMetas.map((compMeta) => compMeta.id)\n  );\n  const compPaths = usedComps.map((compMeta) => compMeta.entry);\n  const subBundle = getBundleSubset(\n    bundle,\n    [\n      \"entrypoint.css\",\n      ...compPaths,\n      \"root-provider.js\",\n      ...bundle.projects\n        .map((x) => x.globalContextsProviderFileName)\n        .filter((x) => !!x),\n      // We need to explicitly include global context provider components\n      // to make sure they are kept in bundle.components. That's because\n      // for esbuild, just the globalContextsProviderFileName is not enough,\n      // because it will import a chunk that includes the global context\n      // component, instead of importing that global context component's\n      // entry file. And because nothing depends on the global context component's\n      // entry file, we end up excluding the global context component from\n      // bundle.components, which then makes its substitution not work.\n      // Instead, we forcibly include it here (we'll definitely need it anyway!).\n      ...bundle.components\n        .filter((c) => c.isGlobalContextProvider)\n        .map((c) => c.entry),\n      ...bundle.globalGroups.map((g) => g.contextFile),\n    ],\n    opts\n  );\n\n  const remoteFontUrls: string[] = [];\n  subBundle.projects.forEach((p) =>\n    remoteFontUrls.push(...p.remoteFonts.map((f) => f.url))\n  );\n\n  return {\n    entryCompMetas: compMetas,\n    bundle: subBundle,\n    remoteFontUrls,\n  };\n}\n\n// It's important to deep clone any attributes that are going to be changed in the\n// target bundle, since the build of pages can be done in multiple stages/processes\n// we don't want to mutate the original bundle, which can impact other pages.\nexport function mergeBundles(\n  target: LoaderBundleOutput,\n  from: LoaderBundleOutput\n) {\n  const existingProjects = new Set(target.projects.map((p) => p.id));\n  const newProjects = from.projects.filter((p) => !existingProjects.has(p.id));\n  if (newProjects.length > 0) {\n    target = {\n      ...target,\n      projects: [...target.projects, ...newProjects],\n    };\n  }\n\n  const existingCompIds = new Set(target.components.map((c) => c.id));\n\n  function shouldIncludeComponentInBundle(c: ComponentMeta) {\n    // If the component is already present in the target bundle, don't include it\n    if (existingCompIds.has(c.id)) {\n      return false;\n    }\n    // If the component belongs to a project that is not present in the target bundle,\n    // include it\n    if (!existingProjects.has(c.projectId)) {\n      return true;\n    }\n    // If the component is present in the filteredIds of the project it belongs to,\n    // in the target bundle, we consider that the component was not deleted in the target\n    // bundle, so we can include it\n    const targetBundleFilteredIds = target.filteredIds[c.projectId] ?? [];\n    return targetBundleFilteredIds.includes(c.id);\n  }\n\n  const newCompMetas = from.components.filter((m) =>\n    shouldIncludeComponentInBundle(m)\n  );\n  if (newCompMetas.length > 0) {\n    target = {\n      ...target,\n      components: [...target.components, ...newCompMetas],\n    };\n\n    // Deep clone the filteredIds object to avoid mutating the original bundle\n    target.filteredIds = Object.fromEntries(\n      Object.entries(target.filteredIds).map(([k, v]) => [k, [...v]])\n    );\n\n    from.projects.forEach((fromProject) => {\n      const projectId = fromProject.id;\n      const fromBundleFilteredIds = from.filteredIds[projectId] ?? [];\n      if (!existingProjects.has(projectId)) {\n        target.filteredIds[projectId] = [...fromBundleFilteredIds];\n      } else {\n        target.filteredIds[projectId] = intersect(\n          target.filteredIds[projectId] ?? [],\n          fromBundleFilteredIds\n        );\n      }\n    });\n  }\n\n  const existingModules = {\n    browser: new Set(target.modules.browser.map((m) => m.fileName)),\n    server: new Set(target.modules.server.map((m) => m.fileName)),\n  };\n  const newModules = {\n    browser: from.modules.browser.filter(\n      (m) => !existingModules.browser.has(m.fileName)\n    ),\n    server: from.modules.server.filter(\n      (m) => !existingModules.server.has(m.fileName)\n    ),\n  };\n  if (newModules.browser.length > 0 || newModules.server.length > 0) {\n    target = {\n      ...target,\n      modules: {\n        browser: [...target.modules.browser, ...newModules.browser],\n        server: [...target.modules.server, ...newModules.server],\n      },\n    };\n  }\n\n  const existingGlobalIds = new Set(target.globalGroups.map((g) => g.id));\n  const newGlobals = from.globalGroups.filter(\n    (g) => !existingGlobalIds.has(g.id)\n  );\n  if (newGlobals.length > 0) {\n    target = {\n      ...target,\n      globalGroups: [...target.globalGroups, ...newGlobals],\n    };\n  }\n\n  const existingSplitIds = new Set(target.activeSplits.map((s) => s.id));\n  const newSplits =\n    from.activeSplits.filter(\n      // Don't include splits belonging to projects already present\n      // in the target bundle\n      (s) => !existingSplitIds.has(s.id) && !existingProjects.has(s.projectId)\n    ) ?? [];\n  if (newSplits.length > 0) {\n    target = {\n      ...target,\n      activeSplits: [...target.activeSplits, ...newSplits],\n    };\n  }\n\n  // Avoid `undefined` as it cannot be serialized as JSON\n  target.bundleKey = target.bundleKey ?? from.bundleKey ?? null;\n  target.deferChunksByDefault =\n    target.deferChunksByDefault ?? from.deferChunksByDefault ?? false;\n\n  target.disableRootLoadingBoundaryByDefault =\n    target.disableRootLoadingBoundaryByDefault ??\n    from.disableRootLoadingBoundaryByDefault ??\n    false;\n\n  return target;\n}\n\nexport const convertBundlesToComponentRenderData = (\n  bundles: LoaderBundleOutput[],\n  compMetas: ComponentMeta[]\n): ComponentRenderData | null => {\n  if (bundles.length === 0) {\n    return null;\n  }\n\n  const mergedBundles = bundles.reduce((prev, cur) => mergeBundles(prev, cur));\n  return prepComponentData(mergedBundles, compMetas);\n};\n", "import {\n  AssetModule,\n  ComponentMeta,\n  FontMeta,\n  GlobalGroupMeta,\n  LoaderBundleOutput,\n  Registry,\n} from '@plasmicapp/loader-core';\nimport * as React from 'react';\nimport { ComponentLookupSpec, getCompMetas } from './utils';\n\nfunction getFirstCompMeta(metas: ComponentMeta[], lookup: ComponentLookupSpec) {\n  const filtered = getCompMetas(metas, lookup);\n  return filtered.length === 0 ? undefined : filtered[0];\n}\n\nexport class ComponentLookup {\n  constructor(private bundle: LoaderBundleOutput, private registry: Registry) {}\n\n  getComponentMeta(spec: ComponentLookupSpec): ComponentMeta | undefined {\n    const compMeta = getFirstCompMeta(this.bundle.components, spec);\n    return compMeta;\n  }\n\n  getComponent<P extends React.ComponentType = any>(\n    spec: ComponentLookupSpec,\n    opts: { forceOriginal?: boolean } = {}\n  ) {\n    const compMeta = getFirstCompMeta(this.bundle.components, spec);\n    if (!compMeta) {\n      throw new Error(`Component not found: ${spec}`);\n    }\n    const moduleName = compMeta.entry;\n    if (!this.registry.hasModule(moduleName, opts)) {\n      throw new Error(`Component not yet fetched: ${compMeta.name}`);\n    }\n    const entry = this.registry.load(moduleName, {\n      forceOriginal: opts.forceOriginal,\n    });\n    return !opts.forceOriginal &&\n      typeof entry?.getPlasmicComponent === 'function'\n      ? entry.getPlasmicComponent()\n      : (entry.default as P);\n  }\n\n  hasComponent(spec: ComponentLookupSpec) {\n    const compMeta = getFirstCompMeta(this.bundle.components, spec);\n    if (compMeta) {\n      return this.registry.hasModule(compMeta.entry);\n    }\n    return false;\n  }\n\n  getGlobalContexts(): { meta: GlobalGroupMeta; context: any }[] {\n    const customGlobalMetas = this.bundle.globalGroups.filter(\n      (m) => m.type === 'global-user-defined'\n    );\n    return customGlobalMetas.map((meta) => ({\n      meta,\n      context: this.registry.load(meta.contextFile).default,\n    }));\n  }\n\n  getGlobalContextsProvider(spec: ComponentLookupSpec) {\n    const compMeta = getFirstCompMeta(this.bundle.components, spec);\n    const projectMeta = compMeta\n      ? this.bundle.projects.find((x) => x.id === compMeta.projectId)\n      : undefined;\n\n    if (\n      !projectMeta ||\n      !projectMeta.globalContextsProviderFileName ||\n      !this.registry.hasModule(projectMeta.globalContextsProviderFileName)\n    ) {\n      return undefined;\n    }\n    const entry = this.registry.load(\n      projectMeta.globalContextsProviderFileName\n    );\n\n    return typeof entry?.getPlasmicComponent === 'function'\n      ? entry.getPlasmicComponent()\n      : entry.default;\n  }\n\n  getRootProvider() {\n    const entry = this.registry.load('root-provider.js');\n    return entry.default;\n  }\n\n  getCss(): AssetModule[] {\n    // We can probably always get the modules from the browser build\n    return this.bundle.modules.browser.filter(\n      (mod) => mod.type === 'asset' && mod.fileName.endsWith('css')\n    ) as AssetModule[];\n  }\n\n  getRemoteFonts(): FontMeta[] {\n    return this.bundle.projects.flatMap((p) => p.remoteFonts);\n  }\n}\n", "import * as React from \"react\";\nimport { usePlasmicRootContext } from \"./PlasmicRootProvider\";\nimport { usePlasmicComponent } from \"./usePlasmicComponent\";\nimport { MaybeWrap } from \"./utils\";\n\nconst PlasmicComponentContext = React.createContext(false);\n\nexport function PlasmicComponent(props: {\n  /**\n   * Name of the component to render, or the path of the page component\n   */\n  component: string;\n  /**\n   * Optionally specify a projectId if there are multiple components\n   * of the same name from different projects\n   */\n  projectId?: string;\n  /**\n   * If you used registerComponent(), then if the name matches a registered\n   * component, that component is used.  If you want the Plasmic-generated\n   * component instead, specify forceOriginal.\n   */\n  forceOriginal?: boolean;\n  componentProps?: any;\n}): React.ReactElement | null {\n  const { component, projectId, componentProps, forceOriginal } = props;\n\n  const rootContext = usePlasmicRootContext();\n  const isRootLoader = !React.useContext(PlasmicComponentContext);\n\n  if (!rootContext) {\n    // no existing PlasmicRootProvider\n    throw new Error(\n      `You must use <PlasmicRootProvider/> at the root of your app`\n    );\n  }\n\n  const {\n    loader,\n    globalContextsProps,\n    variation,\n    userAuthToken,\n    isUserLoading,\n    authRedirectUri,\n    translator,\n    ...rest\n  } = rootContext;\n\n  const Component = usePlasmicComponent(\n    { name: component, projectId, isCode: false },\n    { forceOriginal }\n  );\n\n  React.useEffect(() => {\n    if (isRootLoader) {\n      const meta = loader\n        .getLookup()\n        .getComponentMeta({ name: component, projectId });\n\n      if (meta) {\n        loader.trackRender({\n          renderCtx: {\n            rootProjectId: meta.projectId,\n            rootComponentId: meta.id,\n            rootComponentName: component,\n            teamIds: loader.getTeamIds(),\n            projectIds: loader.getProjectIds(),\n          },\n          variation,\n        });\n      }\n    }\n  }, [component, projectId, loader, variation]);\n\n  const element = React.useMemo(() => {\n    if (!Component) {\n      return null;\n    }\n\n    let elt = <Component {...componentProps} />;\n\n    if (isRootLoader) {\n      // If this is the root PlasmicComponent, then wrap the content with the\n      // react-web's PlasmicRootProvider.  We are doing this here, instead of\n      // say PlasmicRootProvider, because we don't have access to this context\n      // provider until data has been loaded.  If we insert this provider into\n      // the tree at the root after data is loaded, then we'll invalidate the\n      // React tree and tree state, which is bad.  Instead, we do it at the\n      // \"root-most PlasmicComponent\"; we won't risk invalidating the sub-tree\n      // here because there were no children before the data came in.\n      const lookup = loader.getLookup();\n      const ReactWebRootProvider = lookup.getRootProvider();\n      const GlobalContextsProvider = lookup.getGlobalContextsProvider({\n        name: component,\n        projectId,\n      });\n      elt = (\n        <ReactWebRootProvider\n          {...rest}\n          userAuthToken={userAuthToken}\n          isUserLoading={isUserLoading}\n          authRedirectUri={authRedirectUri}\n          i18n={{\n            translator,\n            tagPrefix: loader.opts.i18n?.tagPrefix,\n          }}\n        >\n          <MaybeWrap\n            cond={!!GlobalContextsProvider}\n            wrapper={(children) => (\n              <GlobalContextsProvider {...globalContextsProps}>\n                {children}\n              </GlobalContextsProvider>\n            )}\n          >\n            <PlasmicComponentContext.Provider value={true}>\n              {elt}\n            </PlasmicComponentContext.Provider>\n          </MaybeWrap>\n        </ReactWebRootProvider>\n      );\n    }\n    return elt;\n  }, [\n    Component,\n    componentProps,\n    loader,\n    isRootLoader,\n    component,\n    projectId,\n    globalContextsProps,\n    userAuthToken, // Just use the token to memo, `user` should be derived from it\n    isUserLoading,\n    authRedirectUri,\n  ]);\n  return element;\n}\n", "import * as React from 'react';\nimport { usePlasmicRootContext } from './PlasmicRootProvider';\nimport {\n  ComponentLookupSpec,\n  useForceUpdate,\n  useIsMounted,\n  useStableLookupSpec,\n} from './utils';\n\n/**\n * Hook that fetches and returns a React component for rendering the argument\n * Plasmic component.  Returns undefined if the component data is still\n * being fetched.\n *\n * @param opts.forceOriginal if you used PlasmicComponentLoader.registerComponent,\n *   then normally usePlasmicComponent will return the registered component.\n *   You can set forceOriginal to true if you want to return the Plasmic-generated\n *   component instead.\n */\nexport function usePlasmicComponent<P extends React.ComponentType = any>(\n  spec: ComponentLookupSpec,\n  opts: { forceOriginal?: boolean } = {}\n) {\n  const rootContext = usePlasmicRootContext();\n  if (!rootContext) {\n    throw new Error(\n      `You can only use usePlasmicComponent if wrapped in <PlasmicRootProvider />`\n    );\n  }\n\n  const loader = rootContext.loader;\n  const lookup = loader.getLookup();\n\n  const component = lookup.hasComponent(spec)\n    ? lookup.getComponent(spec, opts)\n    : undefined;\n\n  const stableSpec = useStableLookupSpec(spec);\n  const isMounted = useIsMounted();\n  const forceUpdate = useForceUpdate();\n\n  React.useEffect(() => {\n    if (!component) {\n      (async () => {\n        await loader.fetchComponentData(stableSpec);\n        if (isMounted()) {\n          forceUpdate();\n        }\n      })();\n    }\n  }, [component, stableSpec]);\n\n  return component as P;\n}\n", "import {\n  extractPlasmicQueryData as internalExtractQueryData,\n  plasmicPrepass as internalPlasmicPrepass,\n} from \"@plasmicapp/prepass\";\n\n/**\n * Performs a prepass over Plasmic content, kicking off the necessary\n * data fetches, and populating the fetched data into a cache.  This\n * cache can be passed as prefetchedQueryData into PlasmicRootProvider.\n *\n * To limit rendering errors that can occur when you do this, we recommend\n * that you pass in _only_ the PlasmicComponents that you are planning to use\n * as the argument.  For example:\n *\n *   const cache = await extractPlasmicQueryData(\n *     <PlasmicRootProvider loader={PLASMIC} prefetchedData={plasmicData}>\n *       <PlasmicComponent component=\"Home\" componentProps={{\n *         // Specify the component prop overrides you are planning to use\n *         // to render the page, as they may change what data is fetched.\n *         ...\n *       }} />\n *       <PlasmicComponent component=\"NavBar\" componentProps={{\n *         ...\n *       }} />\n *       ...\n *     </PlasmicRootProvider>\n *   );\n *\n * If your PlasmicComponent will be wrapping components that require special\n * context set up, you should also wrap the element above with those context\n * providers.\n *\n * You should avoid passing in elements that are not related to Plasmic, as any\n * rendering errors from those elements during the prepass may result in data\n * not being populated in the cache.\n *\n * @param element a React element containing instances of PlasmicComponent.\n *   Will attempt to satisfy all data needs from usePlasmicDataQuery()\n *   in this element tree.\n * @returns an object mapping query key to fetched data\n */\nexport function extractPlasmicQueryData(\n  element: React.ReactElement\n): Promise<Record<string, any>> {\n  return internalExtractQueryData(element);\n}\n\n/**\n * @deprecated Maintained for backwards compatibility\n */\nexport function plasmicPrepass(element: React.ReactElement): Promise<void> {\n  return internalPlasmicPrepass(element);\n}\n", "import { extractPlasmicQueryData } from \"@plasmicapp/prepass\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { renderToString as reactRenderToString } from \"react-dom/server\";\nimport { ComponentRenderData, PlasmicComponentLoader } from \"./loader-shared\";\nimport { PlasmicComponent } from \"./PlasmicComponent\";\nimport { GlobalVariantSpec, PlasmicRootProvider } from \"./PlasmicRootProvider\";\nimport { ComponentLookupSpec } from \"./utils\";\n\nexport async function renderToElement(\n  loader: PlasmicComponentLoader,\n  target: HTMLElement,\n  lookup: ComponentLookupSpec,\n  opts: {\n    prefetchedData?: ComponentRenderData;\n    componentProps?: any;\n    globalVariants?: GlobalVariantSpec[];\n    prefetchedQueryData?: Record<string, any>;\n    pageParams?: Record<string, any>;\n    pageQuery?: Record<string, any>;\n  } = {}\n) {\n  return new Promise<void>((resolve) => {\n    const element = makeElement(loader, lookup, opts);\n    ReactDOM.render(element, target, () => resolve());\n  });\n}\n\nexport function renderToString(\n  loader: PlasmicComponentLoader,\n  lookup: ComponentLookupSpec,\n  opts: {\n    prefetchedData?: ComponentRenderData;\n    componentProps?: any;\n    globalVariants?: GlobalVariantSpec[];\n    prefetchedQueryData?: Record<string, any>;\n  } = {}\n) {\n  const element = makeElement(loader, lookup, opts);\n  return reactRenderToString(element);\n}\n\nexport async function extractPlasmicQueryDataFromElement(\n  loader: PlasmicComponentLoader,\n  lookup: ComponentLookupSpec,\n  opts: {\n    prefetchedData?: ComponentRenderData;\n    componentProps?: any;\n    globalVariants?: GlobalVariantSpec[];\n    prefetchedQueryData?: Record<string, any>;\n  } = {}\n) {\n  const element = makeElement(loader, lookup, opts);\n  return extractPlasmicQueryData(element);\n}\n\nexport async function hydrateFromElement(\n  loader: PlasmicComponentLoader,\n  target: HTMLElement,\n  lookup: ComponentLookupSpec,\n  opts: {\n    prefetchedData?: ComponentRenderData;\n    componentProps?: any;\n    globalVariants?: GlobalVariantSpec[];\n    prefetchedQueryData?: Record<string, any>;\n  } = {}\n) {\n  return new Promise<void>((resolve) => {\n    const element = makeElement(loader, lookup, opts);\n    ReactDOM.hydrate(element, target, () => resolve());\n  });\n}\n\nfunction makeElement(\n  loader: PlasmicComponentLoader,\n  lookup: ComponentLookupSpec,\n  opts: {\n    prefetchedData?: ComponentRenderData;\n    componentProps?: any;\n    globalVariants?: GlobalVariantSpec[];\n    prefetchedQueryData?: Record<string, any>;\n    pageParams?: Record<string, any>;\n    pageQuery?: Record<string, any>;\n  } = {}\n) {\n  return (\n    <PlasmicRootProvider\n      loader={loader}\n      prefetchedData={opts.prefetchedData}\n      globalVariants={opts.globalVariants}\n      prefetchedQueryData={opts.prefetchedQueryData}\n      pageParams={opts.pageParams}\n      pageQuery={opts.pageQuery}\n    >\n      <PlasmicComponent\n        component={typeof lookup === \"string\" ? lookup : lookup.name}\n        projectId={typeof lookup === \"string\" ? undefined : lookup.projectId}\n        componentProps={opts.componentProps}\n      />\n    </PlasmicRootProvider>\n  );\n}\n"],
  "mappings": "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",
  "names": ["import_host", "import_loader_core", "React", "pascalcase", "PlasmicCss", "import_loader_core", "_a", "_b", "module", "React", "ReactDOM", "import_host", "import_query", "React", "React", "_a", "internalExtractQueryData", "internalPlasmicPrepass", "import_prepass", "import_react", "import_react_dom", "ReactDOM", "reactRenderToString", "React"]
}
