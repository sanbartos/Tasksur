import type { $ZodStringFormats } from "../core/checks.js";
import type * as errors from "../core/errors.js";
import * as util from "../core/util.js";

function getBelarusianPlural(count: number, one: string, few: string, many: string): string {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;

  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }

  if (lastDigit === 1) {
    return one;
  }

  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }

  return many;
}

interface BelarusianSizable {
  unit: {
    one: string;
    few: string;
    many: string;
  };
  verb: string;
}
const error: () => errors.$ZodErrorMap = () => {
  const Sizable: Record<string, BelarusianSizable> = {
    string: {
      unit: {
        one: "ÑÑ–Ð¼Ð²Ð°Ð»",
        few: "ÑÑ–Ð¼Ð²Ð°Ð»Ñ‹",
        many: "ÑÑ–Ð¼Ð²Ð°Ð»Ð°Ñž",
      },
      verb: "Ð¼ÐµÑ†ÑŒ",
    },
    array: {
      unit: {
        one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚",
        few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹",
        many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°Ñž",
      },
      verb: "Ð¼ÐµÑ†ÑŒ",
    },
    set: {
      unit: {
        one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚",
        few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹",
        many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°Ñž",
      },
      verb: "Ð¼ÐµÑ†ÑŒ",
    },
    file: {
      unit: {
        one: "Ð±Ð°Ð¹Ñ‚",
        few: "Ð±Ð°Ð¹Ñ‚Ñ‹",
        many: "Ð±Ð°Ð¹Ñ‚Ð°Ñž",
      },
      verb: "Ð¼ÐµÑ†ÑŒ",
    },
  };

  function getSizing(origin: string): BelarusianSizable | null {
    return Sizable[origin] ?? null;
  }

  const parsedType = (data: any): string => {
    const t = typeof data;

    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Ð»Ñ–Ðº";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Ð¼Ð°ÑÑ–Ñž";
        }
        if (data === null) {
          return "null";
        }

        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };

  const Nouns: {
    [k in $ZodStringFormats | (string & {})]?: string;
  } = {
    regex: "ÑƒÐ²Ð¾Ð´",
    email: "email Ð°Ð´Ñ€Ð°Ñ",
    url: "URL",
    emoji: "ÑÐ¼Ð¾Ð´Ð·Ñ–",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO Ð´Ð°Ñ‚Ð° Ñ– Ñ‡Ð°Ñ",
    date: "ISO Ð´Ð°Ñ‚Ð°",
    time: "ISO Ñ‡Ð°Ñ",
    duration: "ISO Ð¿Ñ€Ð°Ñ†ÑÐ³Ð»Ð°ÑÑ†ÑŒ",
    ipv4: "IPv4 Ð°Ð´Ñ€Ð°Ñ",
    ipv6: "IPv6 Ð°Ð´Ñ€Ð°Ñ",
    cidrv4: "IPv4 Ð´Ñ‹ÑÐ¿Ð°Ð·Ð¾Ð½",
    cidrv6: "IPv6 Ð´Ñ‹ÑÐ¿Ð°Ð·Ð¾Ð½",
    base64: "Ñ€Ð°Ð´Ð¾Ðº Ñƒ Ñ„Ð°Ñ€Ð¼Ð°Ñ†Ðµ base64",
    base64url: "Ñ€Ð°Ð´Ð¾Ðº Ñƒ Ñ„Ð°Ñ€Ð¼Ð°Ñ†Ðµ base64url",
    json_string: "JSON Ñ€Ð°Ð´Ð¾Ðº",
    e164: "Ð½ÑƒÐ¼Ð°Ñ€ E.164",
    jwt: "JWT",
    template_literal: "ÑƒÐ²Ð¾Ð´",
  };

  return (issue) => {
    switch (issue.code) {
      case "invalid_type":
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´: Ñ‡Ð°ÐºÐ°ÑžÑÑ ${issue.expected}, Ð°Ñ‚Ñ€Ñ‹Ð¼Ð°Ð½Ð° ${parsedType(issue.input)}`;
      case "invalid_value":
        if (issue.values.length === 1) return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ ${util.stringifyPrimitive(issue.values[0])}`;
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ð²Ð°Ñ€Ñ‹ÑÐ½Ñ‚: Ñ‡Ð°ÐºÐ°ÑžÑÑ Ð°Ð´Ð·Ñ–Ð½ Ð· ${util.joinValues(issue.values, "|")}`;
      case "too_big": {
        const adj = issue.inclusive ? "<=" : "<";
        const sizing = getSizing(issue.origin);
        if (sizing) {
          const maxValue = Number(issue.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð²ÑÐ»Ñ–ÐºÑ–: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue.origin ?? "Ð·Ð½Ð°Ñ‡ÑÐ½Ð½Ðµ"} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° ${sizing.verb} ${adj}${issue.maximum.toString()} ${unit}`;
        }
        return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð²ÑÐ»Ñ–ÐºÑ–: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue.origin ?? "Ð·Ð½Ð°Ñ‡ÑÐ½Ð½Ðµ"} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° Ð±Ñ‹Ñ†ÑŒ ${adj}${issue.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue.inclusive ? ">=" : ">";
        const sizing = getSizing(issue.origin);
        if (sizing) {
          const minValue = Number(issue.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð¼Ð°Ð»Ñ‹: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue.origin} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° ${sizing.verb} ${adj}${issue.minimum.toString()} ${unit}`;
        }
        return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð¼Ð°Ð»Ñ‹: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue.origin} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° Ð±Ñ‹Ñ†ÑŒ ${adj}${issue.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue as errors.$ZodStringFormatIssues;
        if (_issue.format === "starts_with") return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð¿Ð°Ñ‡Ñ‹Ð½Ð°Ñ†Ñ†Ð° Ð· "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð·Ð°ÐºÐ°Ð½Ñ‡Ð²Ð°Ñ†Ñ†Ð° Ð½Ð° "${_issue.suffix}"`;
        if (_issue.format === "includes") return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð·Ð¼ÑÑˆÑ‡Ð°Ñ†ÑŒ "${_issue.includes}"`;
        if (_issue.format === "regex") return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð°Ð´Ð¿Ð°Ð²ÑÐ´Ð°Ñ†ÑŒ ÑˆÐ°Ð±Ð»Ð¾Ð½Ñƒ ${_issue.pattern}`;
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ${Nouns[_issue.format] ?? issue.format}`;
      }
      case "not_multiple_of":
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ð»Ñ–Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð±Ñ‹Ñ†ÑŒ ÐºÑ€Ð°Ñ‚Ð½Ñ‹Ð¼ ${issue.divisor}`;
      case "unrecognized_keys":
        return `ÐÐµÑ€Ð°ÑÐ¿Ð°Ð·Ð½Ð°Ð½Ñ‹ ${issue.keys.length > 1 ? "ÐºÐ»ÑŽÑ‡Ñ‹" : "ÐºÐ»ÑŽÑ‡"}: ${util.joinValues(issue.keys, ", ")}`;
      case "invalid_key":
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÐºÐ»ÑŽÑ‡ Ñƒ ${issue.origin}`;
      case "invalid_union":
        return "ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´";
      case "invalid_element":
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ð°Ðµ Ð·Ð½Ð°Ñ‡ÑÐ½Ð½Ðµ Ñž ${issue.origin}`;
      default:
        return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´`;
    }
  };
};

export default function (): { localeError: errors.$ZodErrorMap } {
  return {
    localeError: error(),
  };
}





